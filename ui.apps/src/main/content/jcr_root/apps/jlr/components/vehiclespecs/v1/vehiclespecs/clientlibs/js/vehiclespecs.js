/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main/webapp/components/VehicleSpecsRulesEngine/js/VehicleSpecsRulesEngine.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@configureconnect/rulesconnectjs/es/decimalformat.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@configureconnect/rulesconnectjs/es/decimalformat.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

  "use strict";
  __webpack_require__.r(__webpack_exports__);
  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
  
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  
  /*
  Based on Java DecimalFormat and https://gist.github.com/oskansavli/822382
  */
  var DecimalFormat = function () {
    function DecimalFormat(formatStr) {
      _classCallCheck(this, DecimalFormat);
  
      this._prefix = DecimalFormat._getPrefix(formatStr);
  
      var noPrefix = formatStr.substring(this._prefix.length);
      this._suffix = DecimalFormat._getSuffix(noPrefix);
  
      var numberStr = noPrefix.substr(0, noPrefix.length - this._suffix.length);
  
      this._suffix = this._suffix.replace(/[']/g, '');
      this._groupSize = 0;
      this._minInt = 1;
      this._minFrac = 0;
      this._maxFrac = 0;
  
      this._groupingSeparator = ',';
      this._outputDecimalSeparator = '.';
  
      if (numberStr.indexOf("#.#") !== -1) {
        this._groupingSeparator = '.';
        this._outputDecimalSeparator = ',';
      } else if (numberStr.indexOf("# #") !== -1) {
        this._groupingSeparator = ' ';
      } else if (numberStr.indexOf("#\xa0#") !== -1) {
        this._groupingSeparator = '\xa0';
      } else if (numberStr.indexOf("#'#") !== -1) {
        this._groupingSeparator = '\'';
      }
  
      var intStr = '';
      var fracStr = '';
      var point = numberStr.indexOf(this._outputDecimalSeparator);
      if (point != -1) {
        intStr = numberStr.substring(0, point);
        fracStr = numberStr.substring(point + 1);
      } else {
        intStr = numberStr;
      }
  
      var commaPos = intStr.lastIndexOf(this._groupingSeparator);
      if (commaPos != -1) {
        this._groupSize = intStr.length - 1 - commaPos;
      }
  
      intStr = intStr.replace(new RegExp("[\\" + this._groupingSeparator + "]", "g"), ''); // remove commas
      fracStr = fracStr.replace(new RegExp("[\\" + this._groupingSeparator + "]|[\\" + this._outputDecimalSeparator + "]+", "g"), '');
  
      this._maxFrac = fracStr.length;
  
      var tmp = intStr.replace(/[^0]/g, ''); // remove all except zero
      if (tmp.length > this._minInt) this._minInt = tmp.length;
      tmp = fracStr.replace(/[^0]/g, '');
      this._minFrac = tmp.length;
    }
  
    _createClass(DecimalFormat, [{
      key: 'getInputDecimalSeparator',
      value: function getInputDecimalSeparator(input) {
        return "."; // Always assume that the input is a `number` therefore is always a point.
      }
    }, {
      key: 'format',
      value: function format(numStr) {
        // 1223.06 --> $1,223.06
        // remove prefix, suffix and commas
        var numberStr = this.parseDecimal(numStr).toLowerCase();
  
        // do not format if not a number
        if (isNaN(numberStr) || numberStr.length == 0) return numStr;
  
        var negative = false;
        // remove sign
        if (numberStr.charAt(0) == '-') {
          negative = true;
          numberStr = numberStr.substring(1);
        } else if (numberStr.charAt(0) == '+') {
          numberStr = numberStr.substring(1);
        }
  
        var inputDecimapSeparator = this.getInputDecimalSeparator(numStr);
        var point = numberStr.indexOf(inputDecimapSeparator); // position of point character
        var intStr = '';
        var fracStr = '';
        if (point != -1) {
          intStr = numberStr.substring(0, point);
          fracStr = numberStr.substring(point + 1);
        } else {
          intStr = numberStr;
        }
        fracStr = fracStr.replace(new RegExp("[\\" + this._outputDecimalSeparator + "]"), ''); // remove other point characters
  
        if (fracStr.length > this._maxFrac) {
          // round
          //case 6143
          var num = new Number('0.' + fracStr);
          num = this._maxFrac == 0 ? Math.round(num) : num.toFixed(this._maxFrac);
          // toFixed method has bugs on IE (0.7 --> 0)
          fracStr = num.toString(10).substr(2);
          var c = num >= 1 ? 1 : 0; //carry
          var x,
              i = intStr.length - 1;
          while (c) {
            //increment intStr
            if (i == -1) {
              intStr = '1' + intStr;
              break;
            } else {
              x = intStr.charAt(i);
              if (x == 9) {
                x = '0';c = 1;
              } else {
                x = ++x + '';c = 0;
              }
              intStr = intStr.substring(0, i) + x + intStr.substring(i + 1, intStr.length);
              i--;
            }
          }
        }
        for (var i = fracStr.length; i < this._minFrac; i++) {
          // if minFrac=4 then 1.12 --> 1.1200
          fracStr = fracStr + '0';
        }
        while (fracStr.length > this._minFrac && fracStr.charAt(fracStr.length - 1) == '0') {
          // if minInt=4 then 00034 --> 0034)
          fracStr = fracStr.substring(0, fracStr.length - 1);
        }
  
        for (var i = intStr.length; i < this._minInt; i++) {
          // if minInt=4 then 034 --> 0034
          intStr = '0' + intStr;
        }
        while (intStr.length > this._minInt && intStr.charAt(0) == '0') {
          // if minInt=4 then 00034 --> 0034)
          intStr = intStr.substring(1);
        }
  
        var j = 0;
        for (var i = intStr.length; i > 0; i--) {
          // add commas
          if (j != 0 && j % this._groupSize == 0) {
            intStr = intStr.substring(0, i) + this._groupingSeparator + intStr.substring(i);
            j = 0;
          }
          j++;
        }
  
        var formattedValue;
        if (fracStr.length > 0) formattedValue = this._prefix + intStr + this._outputDecimalSeparator + fracStr + this._suffix;else formattedValue = this._prefix + intStr + this._suffix;
  
        if (negative) {
          formattedValue = '-' + formattedValue;
        }
  
        return formattedValue;
      }
    }, {
      key: 'parseDecimal',
      value: function parseDecimal(fNumStr) {
        // $1,223.06 --> 1223.06
        if (typeof fNumStr === "undefined" || fNumStr === null) return ''; //do not return undefined or null
        fNumStr += ''; //ensure it is string
        if (!isNaN(fNumStr)) return this.getNumericString(fNumStr);
  
        var fNumberStr = fNumStr;
        var negative = false;
        if (fNumStr.charAt(0) == '-') {
          fNumberStr = fNumberStr.substr(1);
          negative = true;
        }
  
        var pIndex = fNumberStr.indexOf(this._prefix);
        var sIndex = this._suffix == '' ? fNumberStr.length : fNumberStr.indexOf(this._suffix, this._prefix.length + 1);
  
        if (pIndex == 0 && sIndex > 0) {
          // remove suffix
          fNumberStr = fNumberStr.substr(0, sIndex);
          // remove prefix
          fNumberStr = fNumberStr.substr(this._prefix.length);
          // remove grouping separators
          fNumberStr = fNumberStr.replace(new RegExp("\\" + this._groupingSeparator, "g"), '');
          // convert decimal separator to traditional period
          fNumberStr = fNumberStr.replace(new RegExp("\\" + this._outputDecimalSeparator, "g"), '.');
  
          if (negative) fNumberStr = '-' + fNumberStr;
          if (!isNaN(fNumberStr)) return this.getNumericString(fNumberStr);
        }
  
        return fNumStr;
      }
  
      /**
       * @description We shouldn't return strings like 1.000 in parseDecimal method.
       * However, using only Number(str) is not enough, because it omits . in big numbers
       * like 23423423423342234.34 => 23423423423342236 . There's a conflict in cases
       * 6143 and 6541.
       * @methodOf DecimalFormat
       * @param {String} str Numberic string
       * @return {String} Corrected numeric string
       * @author Serdar Bicer
       */
  
    }, {
      key: 'getNumericString',
      value: function getNumericString(str) {
        //first convert to number
        var num = new Number(str);
        //check if there is a missing dot
        var numStr = num + '';
        if (str.indexOf('.') > -1 && numStr.indexOf('.') < 0) {
          //check if original string has all zeros after dot or not
          for (var i = str.indexOf('.') + 1; i < str.length; i++) {
            //if not, this means we lost precision
            if (str.charAt(i) !== '0') return str;
          }
          return numStr;
        }
        return str;
      }
    }], [{
      key: '_getPrefix',
      value: function _getPrefix(formatStr) {
        var prefix = '';
  
        var inQuote = false;
        for (var i = 0; i < formatStr.length; i++) {
          if (formatStr.charAt(i) == '\'') {
            inQuote = !inQuote;
          } else if (!inQuote && (formatStr.charAt(i) == '#' || formatStr.charAt(i) == '0')) {
            prefix = formatStr.substring(0, i).replace(/[']/g, '');
            break;
          }
        }
        return prefix;
      }
    }, {
      key: '_getSuffix',
      value: function _getSuffix(formatStr) {
        var suffix = '';
        for (var i = formatStr.length; i >= 0; i--) {
          if (formatStr.charAt(i) == '#' || formatStr.charAt(i) == '0') {
            suffix = formatStr.substring(i + 1);
            break;
          }
        }
        return suffix;
      }
    }]);
  
    return DecimalFormat;
  }();
  
  /* harmony default export */ __webpack_exports__["default"] = (DecimalFormat);
  
  /***/ }),
  
  /***/ "./node_modules/@configureconnect/rulesconnectjs/es/index.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/@configureconnect/rulesconnectjs/es/index.js ***!
    \*******************************************************************/
  /*! exports provided: RulesConnect, JSONP */
  /***/ (function(module, __webpack_exports__, __webpack_require__) {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony import */ var _rulesconnect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rulesconnect */ "./node_modules/@configureconnect/rulesconnectjs/es/rulesconnect.js");
  /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RulesConnect", function() { return _rulesconnect__WEBPACK_IMPORTED_MODULE_0__["default"]; });
  
  /* harmony import */ var _jsonp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jsonp */ "./node_modules/@configureconnect/rulesconnectjs/es/jsonp.js");
  /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JSONP", function() { return _jsonp__WEBPACK_IMPORTED_MODULE_1__["default"]; });
  
  
  
  
  
  /***/ }),
  
  /***/ "./node_modules/@configureconnect/rulesconnectjs/es/jsonp.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/@configureconnect/rulesconnectjs/es/jsonp.js ***!
    \*******************************************************************/
  /*! exports provided: default */
  /***/ (function(module, __webpack_exports__, __webpack_require__) {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony import */ var _pool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pool */ "./node_modules/@configureconnect/rulesconnectjs/es/pool.js");
  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
  
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  
  /*
    A simple JSONP loader which will maximise the use of cached data.
    Uses ES2015 Promises.
  
    e.g.
  
    new JSONP().get("http://example.com/jsonp").then((data)=>{ ... });
  */
  
  
  var JSONP = function () {
    function JSONP(callbackName) {
      _classCallCheck(this, JSONP);
  
      this._callbackName = callbackName || 'rcjson';
      this._pool = new _pool__WEBPACK_IMPORTED_MODULE_0__["default"]();
    }
  
    _createClass(JSONP, [{
      key: 'createScriptElement',
      value: function createScriptElement(url, errorHandler) {
        var script = document.createElement('script'),
            done = false;
        script.src = url;
        script.async = true;
  
        if (typeof errorHandler === 'function') {
          script.onerror = function (ex) {
            errorHandler({ url: url, event: ex });
          };
        }
  
        script.onload = script.onreadystatechange = function () {
          if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
            done = true;
            script.onload = script.onreadystatechange = null;
            if (script && script.parentNode) {
              script.parentNode.removeChild(script);
            }
          }
        };
  
        if (!this._head) {
          this._head = document.getElementsByTagName('head')[0];
        }
        this._head.appendChild(script);
  
        return script;
      }
    }, {
      key: 'get',
      value: function get(url) {
        var _this = this;
  
        var query = (url || '').indexOf('?') === -1 ? '?' : '&';
        var token = this._pool.getToken();
        var uniqueName = this._callbackName + token;
  
        var promise = new Promise(function (resolve, reject) {
  
          window[uniqueName] = function (data) {
            resolve(data);
            try {
              delete window[uniqueName];
            } catch (e) {}
            window[uniqueName] = null;
            token = _this._pool.releaseToken(token);
          };
  
          var errorHandler = function errorHandler(obj) {
            try {
              delete window[uniqueName];
            } catch (e) {}
            window[uniqueName] = null;
            token = _this._pool.releaseToken(token);
            reject(obj);
          };
  
          _this.createScriptElement(url + query + 'callback=' + uniqueName, errorHandler);
        });
  
        promise.uniqueName = uniqueName;
  
        return promise;
      }
    }, {
      key: 'callbackName',
      get: function get() {
        return this._callbackName;
      }
    }]);
  
    return JSONP;
  }();
  
  /* harmony default export */ __webpack_exports__["default"] = (JSONP);
  
  /***/ }),
  
  /***/ "./node_modules/@configureconnect/rulesconnectjs/es/pool.js":
  /*!******************************************************************!*\
    !*** ./node_modules/@configureconnect/rulesconnectjs/es/pool.js ***!
    \******************************************************************/
  /*! exports provided: default */
  /***/ (function(module, __webpack_exports__, __webpack_require__) {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
  
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  
  /*
    Represents a pool of tokens.  The default token is the empty string "".
    All other tokens are decimal string representations, sequential
    e.g. "1", "2", "3" etc.
    The pool will return the first free token.
  */
  
  var Pool = function () {
    function Pool() {
      _classCallCheck(this, Pool);
  
      this._count = 0;
      this._tokens = [];
    }
  
    _createClass(Pool, [{
      key: "getToken",
      value: function getToken() {
        var FREE = true;
  
        var freeIndex = -1;
        for (var i = 0; i < this._tokens.length; i++) {
          if (this._tokens[i] == FREE) {
            this._tokens[i] = !FREE;
            freeIndex = i;
            break;
          }
        }
  
        if (freeIndex === -1) {
          this._tokens.push(!FREE);
          freeIndex = this._tokens.length - 1;
        }
  
        if (freeIndex === 0) return "";
        return "" + freeIndex;
      }
    }, {
      key: "releaseToken",
      value: function releaseToken(token) {
        var FREE = true;
  
        var index = -1;
        if (token === "") {
          index = 0;
        } else {
          index = parseInt(token, 10);
        }
  
        if (!isNaN(index) && index >= 0) {
          this._tokens[index] = FREE;
        }
  
        return "notoken";
      }
    }]);
  
    return Pool;
  }();
  
  /* harmony default export */ __webpack_exports__["default"] = (Pool);
  
  /***/ }),
  
  /***/ "./node_modules/@configureconnect/rulesconnectjs/es/resourcebundle.js":
  /*!****************************************************************************!*\
    !*** ./node_modules/@configureconnect/rulesconnectjs/es/resourcebundle.js ***!
    \****************************************************************************/
  /*! exports provided: default */
  /***/ (function(module, __webpack_exports__, __webpack_require__) {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
  
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
  
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  
  /**
   * ResourceBundle for RulesConnect
   *
   * The ResourceBundle class parses the JSON object received from the
   * RulesConnect API and converts it into a JavaScript friendly object.
   *
   * Keys in the resoure bundle which contain dot notation are converted
   * into nested objects which can be accessed in the usual JavaScript/JSON
   * notation.
   *
   * Keys which contain integers in the dot notation (item.1.key) will be treated
   * as arrays e.g. item[1].key
   *
   * For example,
   *
   *     "banner.share.0.title": "FACEBOOK",
   *     "banner.share.0.url": "http://www.facebook.com/Jaguar",
   *     "banner.share.1.title": "FLICKR",
   *     "banner.share.1.url": "http://www.flickr.com/photos/jaguar_cars/",
   *
   * Becomes,
   *     banner: {
   *       share: [
   *         {
   *            title: "FACEBOOK",
   *            url: "http://www.facebook.com/Jaguar"
   *         },
   *         {
   *            title: "FLICKR",
   *            url: "http://www.flickr.com/photos/jaguar_cars/"
   *         }
   *       ]
   *    }
   *
   * This means you can access the values with,
   *     banner.share[0].title
   *
   * Each object in the tree is a ResourceBundle.  This means it supports the
   * message(key, ...args) function for token replacement.  Tokens can take the
   * form of {0} or in RulesConnect, more commonly $$0$$.
   *
   *    var bundle = ResourceBuncle({"share.key": "My name is {0} $$1$$"});
   *    bundle.message('share.key', 'Tony', 'Tiger') : "My name is Tony Tiger"
   *
   * Although not recommended, if a key has a value AND is also an array,
   * this is handled.
   *
   * e.g.
   *
   *    "bundle.key":"value",
   *    "bundle.key.0":"one"
   *
   * becomes,
   *
   *    { bundle.key: ["one"] }
   *    ... but ["one"].__default == "value"
   *
   * 1) toString of the array will return the assigned 'value'.
   * 2) A __default property of the array contains the assigned 'value'.
   * 3) The object will be an array.
   *
   */
  
  function _isLast(i, arr) {
    return i === arr.length - 1;
  }
  
  function _isInteger(str) {
    return (/^\d+$/.test(str)
    );
  }
  
  function _toString(obj) {
    if (typeof obj.__default === 'string') return obj.__default;else return 'ResourceBundle ' + JSON.stringify(obj);
  }
  
  function _message(obj, key) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
  
    var value = key.split('.').reduce(function (bundle, key) {
      return bundle ? bundle[key] : bundle;
    }, obj);
    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.hasOwnProperty('__default')) {
      value = value.__default;
    }
    var result = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? undefined : value;
  
    if (typeof result === 'string') {
      var _loop = function _loop(i) {
        result = result.replace(new RegExp("\\{" + i + "\\}", "g"), function () {
          return args[i];
        });
        result = result.replace(new RegExp("\\$\\$" + i + "\\$\\$", "g"), function () {
          return args[i];
        });
      };
  
      for (var i = 0; i < args.length; i++) {
        _loop(i);
      }
    }
  
    return result;
  }
  
  function _createArray(__default) {
    var arr = [];
    arr.message = function (nextkey) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
  
      return _message(arr, nextkey, args);
    };
    arr.toString = function () {
      return _toString(arr);
    };
    if (typeof __default !== 'undefined') {
      arr.__default = __default;
    }
    return arr;
  }
  
  function _createObjectOrArray(keys, i, __default) {
    if (_isInteger(keys[i + 1])) {
      return _createArray(__default);
    } else {
      return new ResourceBundle(typeof __default === 'undefined' ? {} : { __default: __default });
    }
  }
  
  var ResourceBundle = function () {
    function ResourceBundle() {
      var _this = this;
  
      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  
      _classCallCheck(this, ResourceBundle);
  
      Object.keys(obj).forEach(function (key) {
        var value = _typeof(obj[key]) !== 'object' ? obj[key] : new ResourceBundle(obj[key]);
  
        key.split('.').reduce(function (bundle, key, i, keys) {
          if (_isLast(i, keys)) {
            if (_typeof(bundle[key]) === 'object') {
              bundle[key].__default = value;
            } else {
              bundle[key] = value;
            }
          } else if (typeof bundle[key] === 'undefined') {
            bundle[key] = _createObjectOrArray(keys, i);
          } else if (_typeof(bundle[key]) !== 'object') {
            var defaultValue = bundle[key];
            bundle[key] = _createObjectOrArray(keys, i, defaultValue);
          }
  
          return bundle[key];
        }, _this);
      });
    }
  
    _createClass(ResourceBundle, [{
      key: 'message',
      value: function message(key) {
        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
  
        return _message.apply(undefined, [this, key].concat(args));
      }
    }, {
      key: 'toString',
      value: function toString() {
        return _toString(this);
      }
    }]);
  
    return ResourceBundle;
  }();
  
  /* harmony default export */ __webpack_exports__["default"] = (ResourceBundle);
  
  /***/ }),
  
  /***/ "./node_modules/@configureconnect/rulesconnectjs/es/rulesconnect.js":
  /*!**************************************************************************!*\
    !*** ./node_modules/@configureconnect/rulesconnectjs/es/rulesconnect.js ***!
    \**************************************************************************/
  /*! exports provided: default */
  /***/ (function(module, __webpack_exports__, __webpack_require__) {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony import */ var _jsonp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jsonp */ "./node_modules/@configureconnect/rulesconnectjs/es/jsonp.js");
  /* harmony import */ var _decimalformat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decimalformat */ "./node_modules/@configureconnect/rulesconnectjs/es/decimalformat.js");
  /* harmony import */ var _resourcebundle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resourcebundle */ "./node_modules/@configureconnect/rulesconnectjs/es/resourcebundle.js");
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
  
  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
  
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  
  /**
   * RulesConnect JSONP Handling v2.0.0
   *
   * Unlike v1, this version uses ES2015; does not use $.ajax.
   *
   * Does not require any external library to function.
   *
   * To load some RulesConnect JSONP simply call,
   *
   *     rc.loadJsonp("http://rules.configureconnect.com/rc/jag/gb/resources.jsonp")
   *       .then((data)=>{
   *         alert(data.metadata.meta["url"]);
   *       }).catch(()=>{
   *         alert("oh no an error occurred");
   *       });
   *
   * To load translations/resource bundle, use
   *
   *     rc.loadResources("jag","en_gb", "http://rules.config.jaguar.com");
   *
   * Or,
   *
   *     rc.loadResources("http://rules.config.jaguar.com/rc/jag/en_gb/resources.jsonp");
   *
   * To find out if there are any resources loaded, use,
   *
   *     rc.hasResources();
   *
   * To obtain resources, properties and metadata from the Resource Bundle use,
   *     rc.getResource(key);
   *     rc.getProperty(key);
   *     rc.getMetaData(key);
   *
   * To replace nouns in the resource bundle -- identified by {0} or $$1$$ style tokens,
   *     rc.getResource(key, "arg0", "arg1");
   *
   * To register a callback function to execute once resource/i18n data has loaded, use,
   *     rc.onResourceReady().then(()=> {  ...  });
   *
   **/
  
  
  
  
  
  var RulesConnect = function () {
    function RulesConnect() {
      var _this = this;
  
      _classCallCheck(this, RulesConnect);
  
      this._jsonp = new _jsonp__WEBPACK_IMPORTED_MODULE_0__["default"]('rcjson');
      this._resources = null;
      this._properties = null;
      this._metaData = null;
      this._language = null;
      this._i18nPromise = new Promise(function (resolve, reject) {
        _this._i18nResolve = resolve;
      });
      this._currencyFormats = {};
      this._defaultCurrency = "default";
    }
  
    _createClass(RulesConnect, [{
      key: 'setResources',
      value: function setResources(i18n) {
        this._resources = new _resourcebundle__WEBPACK_IMPORTED_MODULE_2__["default"]((i18n["resource-bundle"] || {})["client-resources"]);
        this._properties = new _resourcebundle__WEBPACK_IMPORTED_MODULE_2__["default"]((i18n["resource-bundle"] || {})["client-properties"]);
        this._metaData = new _resourcebundle__WEBPACK_IMPORTED_MODULE_2__["default"]((i18n["metadata"] || {})["meta"]);
        this._language = (i18n["resource-bundle"] || {}).language;
        this._i18nResolve();
      }
    }, {
      key: 'loadResources',
      value: function loadResources(app, locale, baseUrl) {
        var _this2 = this;
  
        var url;
        if (typeof baseUrl === "undefined" && typeof locale === "undefined" && typeof app === "string") {
          url = app;
        } else {
          if (typeof baseUrl !== "string") baseUrl = "";
          url = baseUrl + "/rc/" + app + "/" + locale + "/resources.jsonp";
        }
  
        var orgPromise = this.loadJsonp(url);
        var chainPromise = orgPromise.then(function (data) {
          _this2.setResources(data);
          return data;
        });
  
        chainPromise.uniqueName = orgPromise.uniqueName;
        return chainPromise;
      }
    }, {
      key: 'hasResources',
      value: function hasResources() {
        return this._resources != null;
      }
    }, {
      key: 'loadJsonp',
      value: function loadJsonp(url) {
        var _this3 = this;
  
        var orgPromise = this._jsonp.get(url);
        var chainPromise = orgPromise.then(function (data) {
          _this3.readCurrencyFormats(data);
          _this3.detectDefaultCurrency(data);
          _this3.overlayResourcesWithResponse(data);
          return data;
        });
  
        chainPromise.uniqueName = orgPromise.uniqueName;
        return chainPromise;
      }
    }, {
      key: 'overlayResourcesWithResponse',
      value: function overlayResourcesWithResponse(apiResponse) {
        if (this._resources) {
          var vehicleProperties = ((apiResponse['feature-dictionary'] || {}).vehicle || {}).property || {};
          var newResources = new _resourcebundle__WEBPACK_IMPORTED_MODULE_2__["default"](vehicleProperties);
          this.traverseResourceTree(newResources, this._resources);
        }
      }
  
      // left = new data model overrides
      // right = old resource bundle
  
    }, {
      key: 'traverseResourceTree',
      value: function traverseResourceTree(left, right) {
        var _this4 = this;
  
        Object.keys(left).forEach(function (key) {
          if (key in right) {
            if (typeof left[key] === 'string') {
              right[key] = left[key];
            } else if (typeof right[key] === 'string' && _typeof(left[key]) === 'object') {
              right[key] = left[key][_this4.language];
            } else if (_typeof(left[key]) === 'object') {
              _this4.traverseResourceTree(left[key], right[key]);
            }
          } else {
            if (typeof left[key] === 'string') {
              right[key] = left[key];
            } else if (_typeof(left[key]) === 'object') {
              // Detect it's an object because it's a multi language property or if it's just dot separated.
              if (left[key][_this4.language] !== undefined) {
                right[key] = left[key][_this4.language];
              } else {
                right[key] = {};
                _this4.traverseResourceTree(left[key], right[key]);
              }
            }
          }
        });
      }
    }, {
      key: 'readCurrencyFormats',
      value: function readCurrencyFormats(data) {
        if (Object.keys(this._currencyFormats).length == 0 && typeof data !== "undefined") {
          var formatStr = ((data["metadata"] || {})["meta"] || {})["currency-format"];
          if (typeof formatStr === "string") {
            var formatArr = formatStr.trim().split("~");
            var formatMap = {};
            for (var i = 0; i < formatArr.length; i++) {
              var pair = formatArr[i].split("=", 2);
              if (pair.length == 1) {
                formatMap["default"] = new _decimalformat__WEBPACK_IMPORTED_MODULE_1__["default"](pair[0].trim());
              }
              if (pair.length == 2) {
                var df = new _decimalformat__WEBPACK_IMPORTED_MODULE_1__["default"](pair[1].trim());
                formatMap[pair[0].toUpperCase()] = df;
                if (i == 0) {
                  formatMap["default"] = df;
                }
              }
            }
          }
          this._currencyFormats = formatMap;
        }
      }
    }, {
      key: 'detectDefaultCurrency',
      value: function detectDefaultCurrency(data) {
        var urlStr = (data["metadata"] || {})["url"];
        if (typeof urlStr === "string") {
          var parts = urlStr.split("/", 5);
          if (parts.length >= 4) {
            var localeStr = parts[3];
            var locale = localeStr.split("_", 3);
            if (locale.length == 3) {
              var currency = locale[2];
              var indexOfDot = currency.indexOf(".");
              if (indexOfDot !== -1) {
                currency = currency.substr(0, indexOfDot);
              }
              this._defaultCurrency = currency.toUpperCase();
              return;
            }
          }
        }
        this._defaultCurrency = "default";
      }
    }, {
      key: 'getFormattedPrice',
      value: function getFormattedPrice(price, currency) {
        currency = currency || this._defaultCurrency;
        var formatter = this._currencyFormats[currency] || this._currencyFormats["default"];
  
        if (formatter) {
          return formatter.format(price);
        }
  
        return "" + price;
      }
  
      // TODO add date formatting here
  
    }, {
      key: 'getFormattedDate',
      value: function getFormattedDate(dateObj) {
        return dateObj.toLocaleDateString();
      }
    }, {
      key: 'onResourceReady',
      value: function onResourceReady() {
        return this._i18nPromise;
      }
    }, {
      key: 'resources',
      get: function get() {
        return this._resources;
      }
    }, {
      key: 'language',
      get: function get() {
        return this._language;
      }
  
      // getResource(key, ...args) {
      //   var result=null;
      //   if(this._resources!=null) {
      //     result = this._resources[key];
      //
      //     if(typeof result !== "undefined") {
      //       for(let i=0; i<args.length; i++) {
      //         result = result.replace(new RegExp("\\{"+i+"\\}", "g"), args[i]);
      //         result = result.replace(new RegExp("\\$\\$"+i+"\\$\\$", "g"), args[i]);
      //       }
      //     }
      //   }
      //
      //
      //   return result;
      // }
  
    }, {
      key: 'properties',
      get: function get() {
        return this._properties;
      }
    }, {
      key: 'metaData',
      get: function get() {
        return this._metaData;
      }
    }]);
  
    return RulesConnect;
  }();
  
  /* harmony default export */ __webpack_exports__["default"] = (RulesConnect);
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/core-js/array/from.js":
  /*!**********************************************************!*\
    !*** ./node_modules/babel-runtime/core-js/array/from.js ***!
    \**********************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = { "default": __webpack_require__(/*! core-js/library/fn/array/from */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/array/from.js"), __esModule: true };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/core-js/get-iterator.js":
  /*!************************************************************!*\
    !*** ./node_modules/babel-runtime/core-js/get-iterator.js ***!
    \************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = { "default": __webpack_require__(/*! core-js/library/fn/get-iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/get-iterator.js"), __esModule: true };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/core-js/is-iterable.js":
  /*!***********************************************************!*\
    !*** ./node_modules/babel-runtime/core-js/is-iterable.js ***!
    \***********************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = { "default": __webpack_require__(/*! core-js/library/fn/is-iterable */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/is-iterable.js"), __esModule: true };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/core-js/map.js":
  /*!***************************************************!*\
    !*** ./node_modules/babel-runtime/core-js/map.js ***!
    \***************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = { "default": __webpack_require__(/*! core-js/library/fn/map */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/map.js"), __esModule: true };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/core-js/number/is-nan.js":
  /*!*************************************************************!*\
    !*** ./node_modules/babel-runtime/core-js/number/is-nan.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = { "default": __webpack_require__(/*! core-js/library/fn/number/is-nan */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/number/is-nan.js"), __esModule: true };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/core-js/object/assign.js":
  /*!*************************************************************!*\
    !*** ./node_modules/babel-runtime/core-js/object/assign.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/object/assign.js"), __esModule: true };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/core-js/object/define-property.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/babel-runtime/core-js/object/define-property.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-property */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-property.js"), __esModule: true };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/core-js/object/keys.js":
  /*!***********************************************************!*\
    !*** ./node_modules/babel-runtime/core-js/object/keys.js ***!
    \***********************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/keys */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/object/keys.js"), __esModule: true };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/core-js/promise.js":
  /*!*******************************************************!*\
    !*** ./node_modules/babel-runtime/core-js/promise.js ***!
    \*******************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = { "default": __webpack_require__(/*! core-js/library/fn/promise */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/promise.js"), __esModule: true };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/core-js/symbol.js":
  /*!******************************************************!*\
    !*** ./node_modules/babel-runtime/core-js/symbol.js ***!
    \******************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/symbol/index.js"), __esModule: true };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/core-js/symbol/iterator.js":
  /*!***************************************************************!*\
    !*** ./node_modules/babel-runtime/core-js/symbol/iterator.js ***!
    \***************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol/iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/symbol/iterator.js"), __esModule: true };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/helpers/asyncToGenerator.js":
  /*!****************************************************************!*\
    !*** ./node_modules/babel-runtime/helpers/asyncToGenerator.js ***!
    \****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  exports.__esModule = true;
  
  var _promise = __webpack_require__(/*! ../core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
  
  var _promise2 = _interopRequireDefault(_promise);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  exports.default = function (fn) {
    return function () {
      var gen = fn.apply(this, arguments);
      return new _promise2.default(function (resolve, reject) {
        function step(key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }
  
          if (info.done) {
            resolve(value);
          } else {
            return _promise2.default.resolve(value).then(function (value) {
              step("next", value);
            }, function (err) {
              step("throw", err);
            });
          }
        }
  
        return step("next");
      });
    };
  };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/helpers/classCallCheck.js":
  /*!**************************************************************!*\
    !*** ./node_modules/babel-runtime/helpers/classCallCheck.js ***!
    \**************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  exports.__esModule = true;
  
  exports.default = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/helpers/createClass.js":
  /*!***********************************************************!*\
    !*** ./node_modules/babel-runtime/helpers/createClass.js ***!
    \***********************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  exports.__esModule = true;
  
  var _defineProperty = __webpack_require__(/*! ../core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");
  
  var _defineProperty2 = _interopRequireDefault(_defineProperty);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  exports.default = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        (0, _defineProperty2.default)(target, descriptor.key, descriptor);
      }
    }
  
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/helpers/extends.js":
  /*!*******************************************************!*\
    !*** ./node_modules/babel-runtime/helpers/extends.js ***!
    \*******************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  exports.__esModule = true;
  
  var _assign = __webpack_require__(/*! ../core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");
  
  var _assign2 = _interopRequireDefault(_assign);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  exports.default = _assign2.default || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
  
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
  
    return target;
  };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/helpers/slicedToArray.js":
  /*!*************************************************************!*\
    !*** ./node_modules/babel-runtime/helpers/slicedToArray.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  exports.__esModule = true;
  
  var _isIterable2 = __webpack_require__(/*! ../core-js/is-iterable */ "./node_modules/babel-runtime/core-js/is-iterable.js");
  
  var _isIterable3 = _interopRequireDefault(_isIterable2);
  
  var _getIterator2 = __webpack_require__(/*! ../core-js/get-iterator */ "./node_modules/babel-runtime/core-js/get-iterator.js");
  
  var _getIterator3 = _interopRequireDefault(_getIterator2);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  exports.default = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
  
      try {
        for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
  
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
  
      return _arr;
    }
  
    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if ((0, _isIterable3.default)(Object(arr))) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/helpers/toConsumableArray.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/babel-runtime/helpers/toConsumableArray.js ***!
    \*****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  exports.__esModule = true;
  
  var _from = __webpack_require__(/*! ../core-js/array/from */ "./node_modules/babel-runtime/core-js/array/from.js");
  
  var _from2 = _interopRequireDefault(_from);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  exports.default = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
  
      return arr2;
    } else {
      return (0, _from2.default)(arr);
    }
  };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/helpers/typeof.js":
  /*!******************************************************!*\
    !*** ./node_modules/babel-runtime/helpers/typeof.js ***!
    \******************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  
  exports.__esModule = true;
  
  var _iterator = __webpack_require__(/*! ../core-js/symbol/iterator */ "./node_modules/babel-runtime/core-js/symbol/iterator.js");
  
  var _iterator2 = _interopRequireDefault(_iterator);
  
  var _symbol = __webpack_require__(/*! ../core-js/symbol */ "./node_modules/babel-runtime/core-js/symbol.js");
  
  var _symbol2 = _interopRequireDefault(_symbol);
  
  var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof(obj);
  } : function (obj) {
    return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
  };
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/array/from.js":
  /*!**********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/array/from.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ../../modules/es6.string.iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js");
  __webpack_require__(/*! ../../modules/es6.array.from */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.from.js");
  module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Array.from;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/get-iterator.js":
  /*!************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/get-iterator.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js");
  __webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js");
  module.exports = __webpack_require__(/*! ../modules/core.get-iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator.js");
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/is-iterable.js":
  /*!***********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/is-iterable.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js");
  __webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js");
  module.exports = __webpack_require__(/*! ../modules/core.is-iterable */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/core.is-iterable.js");
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/map.js":
  /*!***************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/map.js ***!
    \***************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ../modules/es6.object.to-string */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js");
  __webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js");
  __webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js");
  __webpack_require__(/*! ../modules/es6.map */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.map.js");
  __webpack_require__(/*! ../modules/es7.map.to-json */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.to-json.js");
  __webpack_require__(/*! ../modules/es7.map.of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.of.js");
  __webpack_require__(/*! ../modules/es7.map.from */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.from.js");
  module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Map;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/number/is-nan.js":
  /*!*************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/number/is-nan.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ../../modules/es6.number.is-nan */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.number.is-nan.js");
  module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Number.isNaN;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/object/assign.js":
  /*!*************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/object/assign.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ../../modules/es6.object.assign */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.assign.js");
  module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object.assign;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-property.js":
  /*!**********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-property.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ../../modules/es6.object.define-property */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-property.js");
  var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object;
  module.exports = function defineProperty(it, key, desc) {
    return $Object.defineProperty(it, key, desc);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/object/keys.js":
  /*!***********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/object/keys.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ../../modules/es6.object.keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.keys.js");
  module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object.keys;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/promise.js":
  /*!*******************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/promise.js ***!
    \*******************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ../modules/es6.object.to-string */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js");
  __webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js");
  __webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js");
  __webpack_require__(/*! ../modules/es6.promise */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.promise.js");
  __webpack_require__(/*! ../modules/es7.promise.finally */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.promise.finally.js");
  __webpack_require__(/*! ../modules/es7.promise.try */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.promise.try.js");
  module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Promise;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/symbol/index.js":
  /*!************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/symbol/index.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ../../modules/es6.symbol */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.symbol.js");
  __webpack_require__(/*! ../../modules/es6.object.to-string */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js");
  __webpack_require__(/*! ../../modules/es7.symbol.async-iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.symbol.async-iterator.js");
  __webpack_require__(/*! ../../modules/es7.symbol.observable */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.symbol.observable.js");
  module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Symbol;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/symbol/iterator.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/symbol/iterator.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ../../modules/es6.string.iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js");
  __webpack_require__(/*! ../../modules/web.dom.iterable */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js");
  module.exports = __webpack_require__(/*! ../../modules/_wks-ext */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-ext.js").f('iterator');
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js":
  /*!****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  module.exports = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_add-to-unscopables.js":
  /*!************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_add-to-unscopables.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  module.exports = function () { /* empty */ };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js":
  /*!*****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  module.exports = function (it, Constructor, name, forbiddenField) {
    if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
      throw TypeError(name + ': incorrect invocation!');
    } return it;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
  module.exports = function (it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-from-iterable.js":
  /*!*************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-from-iterable.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");
  
  module.exports = function (iter, ITERATOR) {
    var result = [];
    forOf(iter, false, result.push, result, ITERATOR);
    return result;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-includes.js":
  /*!********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-includes.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // false -> Array#indexOf
  // true  -> Array#includes
  var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-absolute-index.js");
  module.exports = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIObject($this);
      var length = toLength(O.length);
      var index = toAbsoluteIndex(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js":
  /*!*******************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 0 -> Array#forEach
  // 1 -> Array#map
  // 2 -> Array#filter
  // 3 -> Array#some
  // 4 -> Array#every
  // 5 -> Array#find
  // 6 -> Array#findIndex
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
  var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js");
  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
  var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-create.js");
  module.exports = function (TYPE, $create) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    var create = $create || asc;
    return function ($this, callbackfn, that) {
      var O = toObject($this);
      var self = IObject(O);
      var f = ctx(callbackfn, that, 3);
      var length = toLength(self.length);
      var index = 0;
      var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
      var val, res;
      for (;length > index; index++) if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res;   // map
          else if (res) switch (TYPE) {
            case 3: return true;             // some
            case 5: return val;              // find
            case 6: return index;            // findIndex
            case 2: result.push(val);        // filter
          } else if (IS_EVERY) return false; // every
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-constructor.js":
  /*!*******************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-constructor.js ***!
    \*******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
  var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js");
  var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('species');
  
  module.exports = function (original) {
    var C;
    if (isArray(original)) {
      C = original.constructor;
      // cross-realm fallback
      if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
      if (isObject(C)) {
        C = C[SPECIES];
        if (C === null) C = undefined;
      }
    } return C === undefined ? Array : C;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-create.js":
  /*!**************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-create.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 9.4.2.3 ArraySpeciesCreate(originalArray, length)
  var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-constructor.js");
  
  module.exports = function (original, length) {
    return new (speciesConstructor(original))(length);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js":
  /*!*************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // getting tag from 19.1.3.6 Object.prototype.toString()
  var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js");
  var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('toStringTag');
  // ES3 wrong here
  var ARG = cof(function () { return arguments; }()) == 'Arguments';
  
  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) { /* empty */ }
  };
  
  module.exports = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
      // builtinTag case
      : ARG ? cof(O)
      // ES3 arguments fallback
      : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js":
  /*!*********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js ***!
    \*********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  var toString = {}.toString;
  
  module.exports = function (it) {
    return toString.call(it).slice(8, -1);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-strong.js":
  /*!***********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-strong.js ***!
    \***********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
  var create = __webpack_require__(/*! ./_object-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js");
  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js");
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js");
  var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");
  var $iterDefine = __webpack_require__(/*! ./_iter-define */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js");
  var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js");
  var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-species.js");
  var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js");
  var fastKey = __webpack_require__(/*! ./_meta */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js").fastKey;
  var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js");
  var SIZE = DESCRIPTORS ? '_s' : 'size';
  
  var getEntry = function (that, key) {
    // fast case
    var index = fastKey(key);
    var entry;
    if (index !== 'F') return that._i[index];
    // frozen object case
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key) return entry;
    }
  };
  
  module.exports = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        anInstance(that, C, NAME, '_i');
        that._t = NAME;         // collection type
        that._i = create(null); // index
        that._f = undefined;    // first entry
        that._l = undefined;    // last entry
        that[SIZE] = 0;         // size
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        // 23.1.3.1 Map.prototype.clear()
        // 23.2.3.2 Set.prototype.clear()
        clear: function clear() {
          for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p) entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        // 23.1.3.3 Map.prototype.delete(key)
        // 23.2.3.4 Set.prototype.delete(value)
        'delete': function (key) {
          var that = validate(this, NAME);
          var entry = getEntry(that, key);
          if (entry) {
            var next = entry.n;
            var prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev) prev.n = next;
            if (next) next.p = prev;
            if (that._f == entry) that._f = next;
            if (that._l == entry) that._l = prev;
            that[SIZE]--;
          } return !!entry;
        },
        // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
        // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
        forEach: function forEach(callbackfn /* , that = undefined */) {
          validate(this, NAME);
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
          var entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            // revert to the last existing entry
            while (entry && entry.r) entry = entry.p;
          }
        },
        // 23.1.3.7 Map.prototype.has(key)
        // 23.2.3.7 Set.prototype.has(value)
        has: function has(key) {
          return !!getEntry(validate(this, NAME), key);
        }
      });
      if (DESCRIPTORS) dP(C.prototype, 'size', {
        get: function () {
          return validate(this, NAME)[SIZE];
        }
      });
      return C;
    },
    def: function (that, key, value) {
      var entry = getEntry(that, key);
      var prev, index;
      // change existing entry
      if (entry) {
        entry.v = value;
      // create new entry
      } else {
        that._l = entry = {
          i: index = fastKey(key, true), // <- index
          k: key,                        // <- key
          v: value,                      // <- value
          p: prev = that._l,             // <- previous entry
          n: undefined,                  // <- next entry
          r: false                       // <- removed
        };
        if (!that._f) that._f = entry;
        if (prev) prev.n = entry;
        that[SIZE]++;
        // add to index
        if (index !== 'F') that._i[index] = entry;
      } return that;
    },
    getEntry: getEntry,
    setStrong: function (C, NAME, IS_MAP) {
      // add .keys, .values, .entries, [@@iterator]
      // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
      $iterDefine(C, NAME, function (iterated, kind) {
        this._t = validate(iterated, NAME); // target
        this._k = kind;                     // kind
        this._l = undefined;                // previous
      }, function () {
        var that = this;
        var kind = that._k;
        var entry = that._l;
        // revert to the last existing entry
        while (entry && entry.r) entry = entry.p;
        // get next entry
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          // or finish the iteration
          that._t = undefined;
          return step(1);
        }
        // return step by kind
        if (kind == 'keys') return step(0, entry.k);
        if (kind == 'values') return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
  
      // add [@@species], 23.1.2.2, 23.2.2.2
      setSpecies(NAME);
    }
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-to-json.js":
  /*!************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-to-json.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // https://github.com/DavidBruant/Map-Set.prototype.toJSON
  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js");
  var from = __webpack_require__(/*! ./_array-from-iterable */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-from-iterable.js");
  module.exports = function (NAME) {
    return function toJSON() {
      if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
      return from(this);
    };
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection.js":
  /*!****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  var meta = __webpack_require__(/*! ./_meta */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js");
  var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js");
  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js");
  var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");
  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js");
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
  var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
  var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
  var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js")(0);
  var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js");
  
  module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME];
    var C = Base;
    var ADDER = IS_MAP ? 'set' : 'add';
    var proto = C && C.prototype;
    var O = {};
    if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
      new C().entries().next();
    }))) {
      // create collection constructor
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
      meta.NEED = true;
    } else {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME, '_c');
        target._c = new Base();
        if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
      });
      each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
          anInstance(this, C, KEY);
          if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
          var result = this._c[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      });
      IS_WEAK || dP(C.prototype, 'size', {
        get: function () {
          return this._c.size;
        }
      });
    }
  
    setToStringTag(C, NAME);
  
    O[NAME] = C;
    $export($export.G + $export.W + $export.F, O);
  
    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
  
    return C;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js":
  /*!**********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  var core = module.exports = { version: '2.5.3' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_create-property.js":
  /*!*********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_create-property.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
  var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
  
  module.exports = function (object, index, value) {
    if (index in object) $defineProperty.f(object, index, createDesc(0, value));
    else object[index] = value;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js":
  /*!*********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js ***!
    \*********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // optional / simple context binding
  var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
  module.exports = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js":
  /*!*************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js":
  /*!*****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // Thank's IE8 for his funny defineProperty
  module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  });
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js":
  /*!****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
  var document = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js").document;
  // typeof document.createElement is 'object' in old IE
  var is = isObject(document) && isObject(document.createElement);
  module.exports = function (it) {
    return is ? document.createElement(it) : {};
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js":
  /*!*******************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  // IE 8- don't enum bug keys
  module.exports = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-keys.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-keys.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // all enumerable object keys, includes symbols
  var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");
  var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js");
  var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js");
  module.exports = function (it) {
    var result = getKeys(it);
    var getSymbols = gOPS.f;
    if (getSymbols) {
      var symbols = getSymbols(it);
      var isEnum = pIE.f;
      var i = 0;
      var key;
      while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
    } return result;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js":
  /*!************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
  var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
  var PROTOTYPE = 'prototype';
  
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var IS_WRAP = type & $export.W;
    var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
    var expProto = exports[PROTOTYPE];
    var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
    var key, own, out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      if (own && key in exports) continue;
      // export native or passed
      out = own ? target[key] : source[key];
      // prevent global pollution for namespaces
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
      // bind timers to global for call from export context
      : IS_BIND && own ? ctx(out, global)
      // wrap global constructors for prevent change them in library
      : IS_WRAP && target[key] == out ? (function (C) {
        var F = function (a, b, c) {
          if (this instanceof C) {
            switch (arguments.length) {
              case 0: return new C();
              case 1: return new C(a);
              case 2: return new C(a, b);
            } return new C(a, b, c);
          } return C.apply(this, arguments);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      // make static versions for prototype methods
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out;
        // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
        if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
      }
    }
  };
  // type bitmap
  $export.F = 1;   // forced
  $export.G = 2;   // global
  $export.S = 4;   // static
  $export.P = 8;   // proto
  $export.B = 16;  // bind
  $export.W = 32;  // wrap
  $export.U = 64;  // safe
  $export.R = 128; // real proto method for `library`
  module.exports = $export;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js":
  /*!***********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  module.exports = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js":
  /*!************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
  var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js");
  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js");
  var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js");
  var BREAK = {};
  var RETURN = {};
  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
    var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
    var f = ctx(fn, that, entries ? 2 : 1);
    var index = 0;
    var length, step, iterator, result;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    // fast case for arrays with default iterator
    if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
      result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      if (result === BREAK || result === RETURN) return result;
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      result = call(iterator, f, step.value, entries);
      if (result === BREAK || result === RETURN) return result;
    }
  };
  exports.BREAK = BREAK;
  exports.RETURN = RETURN;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js":
  /*!************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self
    // eslint-disable-next-line no-new-func
    : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js":
  /*!*********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js ***!
    \*********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function (it, key) {
    return hasOwnProperty.call(it, key);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js":
  /*!**********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
  var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
  module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
    return dP.f(object, key, createDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js":
  /*!**********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var document = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js").document;
  module.exports = document && document.documentElement;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js":
  /*!********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
    return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
  });
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_invoke.js":
  /*!************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_invoke.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  // fast apply, http://jsperf.lnkit.com/fast-apply/5
  module.exports = function (fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0: return un ? fn()
                        : fn.call(that);
      case 1: return un ? fn(args[0])
                        : fn.call(that, args[0]);
      case 2: return un ? fn(args[0], args[1])
                        : fn.call(that, args[0], args[1]);
      case 3: return un ? fn(args[0], args[1], args[2])
                        : fn.call(that, args[0], args[1], args[2]);
      case 4: return un ? fn(args[0], args[1], args[2], args[3])
                        : fn.call(that, args[0], args[1], args[2], args[3]);
    } return fn.apply(that, args);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js":
  /*!*************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js");
  // eslint-disable-next-line no-prototype-builtins
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js":
  /*!*******************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // check on default Array iterator
  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
  var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
  var ArrayProto = Array.prototype;
  
  module.exports = function (it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js":
  /*!**************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js ***!
    \**************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 7.2.2 IsArray(argument)
  var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js");
  module.exports = Array.isArray || function isArray(arg) {
    return cof(arg) == 'Array';
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  module.exports = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // call something on iterator step with safe closing on error
  var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
  module.exports = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) anObject(ret.call(iterator));
      throw e;
    }
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-create.js":
  /*!*****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-create.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  var create = __webpack_require__(/*! ./_object-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js");
  var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
  var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
  var IteratorPrototype = {};
  
  // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
  __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator'), function () { return this; });
  
  module.exports = function (Constructor, NAME, next) {
    Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js":
  /*!*****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js");
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js");
  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
  var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
  var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-create.js");
  var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gpo.js");
  var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
  var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
  var FF_ITERATOR = '@@iterator';
  var KEYS = 'keys';
  var VALUES = 'values';
  
  var returnThis = function () { return this; };
  
  module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS: return function keys() { return new Constructor(this, kind); };
        case VALUES: return function values() { return new Constructor(this, kind); };
      } return function entries() { return new Constructor(this, kind); };
    };
    var TAG = NAME + ' Iterator';
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
    var $default = (!BUGGY && $native) || getMethod(DEFAULT);
    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype;
    // Fix native
    if ($anyNative) {
      IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        // Set @@toStringTag to native iterators
        setToStringTag(IteratorPrototype, TAG, true);
        // fix for some old engines
        if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
      }
    }
    // fix Array#{values, @@iterator}.name in V8 / FF
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() { return $native.call(this); };
    }
    // Define iterator
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    // Plug for library
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) redefine(proto, key, methods[key]);
      } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-detect.js":
  /*!*****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-detect.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
  var SAFE_CLOSING = false;
  
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function () { SAFE_CLOSING = true; };
    // eslint-disable-next-line no-throw-literal
    Array.from(riter, function () { throw 2; });
  } catch (e) { /* empty */ }
  
  module.exports = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7];
      var iter = arr[ITERATOR]();
      iter.next = function () { return { done: safe = true }; };
      arr[ITERATOR] = function () { return iter; };
      exec(arr);
    } catch (e) { /* empty */ }
    return safe;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  module.exports = function (done, value) {
    return { value: value, done: !!done };
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  module.exports = {};
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js":
  /*!*************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  module.exports = true;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js":
  /*!**********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var META = __webpack_require__(/*! ./_uid */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js")('meta');
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
  var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
  var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
  var id = 0;
  var isExtensible = Object.isExtensible || function () {
    return true;
  };
  var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
    return isExtensible(Object.preventExtensions({}));
  });
  var setMeta = function (it) {
    setDesc(it, META, { value: {
      i: 'O' + ++id, // object ID
      w: {}          // weak collections IDs
    } });
  };
  var fastKey = function (it, create) {
    // return primitive with prefix
    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F';
      // not necessary to add metadata
      if (!create) return 'E';
      // add missing metadata
      setMeta(it);
    // return object ID
    } return it[META].i;
  };
  var getWeak = function (it, create) {
    if (!has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true;
      // not necessary to add metadata
      if (!create) return false;
      // add missing metadata
      setMeta(it);
    // return hash weak collections IDs
    } return it[META].w;
  };
  // add metadata on freeze-family methods calling
  var onFreeze = function (it) {
    if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
    return it;
  };
  var meta = module.exports = {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_microtask.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_microtask.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
  var macrotask = __webpack_require__(/*! ./_task */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_task.js").set;
  var Observer = global.MutationObserver || global.WebKitMutationObserver;
  var process = global.process;
  var Promise = global.Promise;
  var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js")(process) == 'process';
  
  module.exports = function () {
    var head, last, notify;
  
    var flush = function () {
      var parent, fn;
      if (isNode && (parent = process.domain)) parent.exit();
      while (head) {
        fn = head.fn;
        head = head.next;
        try {
          fn();
        } catch (e) {
          if (head) notify();
          else last = undefined;
          throw e;
        }
      } last = undefined;
      if (parent) parent.enter();
    };
  
    // Node.js
    if (isNode) {
      notify = function () {
        process.nextTick(flush);
      };
    // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
    } else if (Observer && !(global.navigator && global.navigator.standalone)) {
      var toggle = true;
      var node = document.createTextNode('');
      new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
      notify = function () {
        node.data = toggle = !toggle;
      };
    // environments with maybe non-completely correct, but existent Promise
    } else if (Promise && Promise.resolve) {
      var promise = Promise.resolve();
      notify = function () {
        promise.then(flush);
      };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
    } else {
      notify = function () {
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(global, flush);
      };
    }
  
    return function (fn) {
      var task = { fn: fn, next: undefined };
      if (last) last.next = task;
      if (!head) {
        head = task;
        notify();
      } last = task;
    };
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_new-promise-capability.js":
  /*!****************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_new-promise-capability.js ***!
    \****************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  // 25.4.1.5 NewPromiseCapability(C)
  var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
  
  function PromiseCapability(C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = aFunction(resolve);
    this.reject = aFunction(reject);
  }
  
  module.exports.f = function (C) {
    return new PromiseCapability(C);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-assign.js":
  /*!*******************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-assign.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  // 19.1.2.1 Object.assign(target, source, ...)
  var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");
  var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js");
  var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js");
  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
  var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js");
  var $assign = Object.assign;
  
  // should work with symbols and should have deterministic property order (V8 bug)
  module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
    var A = {};
    var B = {};
    // eslint-disable-next-line no-undef
    var S = Symbol();
    var K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) { B[k] = k; });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source) { // eslint-disable-line no-unused-vars
    var T = toObject(target);
    var aLen = arguments.length;
    var index = 1;
    var getSymbols = gOPS.f;
    var isEnum = pIE.f;
    while (aLen > index) {
      var S = IObject(arguments[index++]);
      var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
      var length = keys.length;
      var j = 0;
      var key;
      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    } return T;
  } : $assign;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js":
  /*!*******************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
  var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dps.js");
  var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js");
  var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
  var Empty = function () { /* empty */ };
  var PROTOTYPE = 'prototype';
  
  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var createDict = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js")('iframe');
    var i = enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    __webpack_require__(/*! ./_html */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js").appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
    return createDict();
  };
  
  module.exports = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE] = anObject(O);
      result = new Empty();
      Empty[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : dPs(result, Properties);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
  var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js");
  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js");
  var dP = Object.defineProperty;
  
  exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
      return dP(O, P, Attributes);
    } catch (e) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dps.js":
  /*!****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dps.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
  var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
  var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");
  
  module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = getKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;
    while (length > i) dP.f(O, P = keys[i++], Properties[P]);
    return O;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopd.js":
  /*!*****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopd.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js");
  var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
  var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js");
  var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
  var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js");
  var gOPD = Object.getOwnPropertyDescriptor;
  
  exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
    O = toIObject(O);
    P = toPrimitive(P, true);
    if (IE8_DOM_DEFINE) try {
      return gOPD(O, P);
    } catch (e) { /* empty */ }
    if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopn-ext.js":
  /*!*********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopn-ext.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
  var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
  var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopn.js").f;
  var toString = {}.toString;
  
  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
    ? Object.getOwnPropertyNames(window) : [];
  
  var getWindowNames = function (it) {
    try {
      return gOPN(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  
  module.exports.f = function getOwnPropertyNames(it) {
    return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopn.js":
  /*!*****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopn.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
  var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js");
  var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js").concat('length', 'prototype');
  
  exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return $keys(O, hiddenKeys);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js":
  /*!*****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  exports.f = Object.getOwnPropertySymbols;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gpo.js":
  /*!****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gpo.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
  var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
  var ObjectProto = Object.prototype;
  
  module.exports = Object.getPrototypeOf || function (O) {
    O = toObject(O);
    if (has(O, IE_PROTO)) return O[IE_PROTO];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js":
  /*!**************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
  var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
  var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-includes.js")(false);
  var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
  
  module.exports = function (object, names) {
    var O = toIObject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js":
  /*!*****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js");
  var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js");
  
  module.exports = Object.keys || function keys(O) {
    return $keys(O, enumBugKeys);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js":
  /*!****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  exports.f = {}.propertyIsEnumerable;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-sap.js":
  /*!****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-sap.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // most Object methods by ES6 should accept primitives
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
  var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js");
  module.exports = function (KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY];
    var exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_perform.js":
  /*!*************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_perform.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  module.exports = function (exec) {
    try {
      return { e: false, v: exec() };
    } catch (e) {
      return { e: true, v: e };
    }
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_promise-resolve.js":
  /*!*********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_promise-resolve.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
  var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_new-promise-capability.js");
  
  module.exports = function (C, x) {
    anObject(C);
    if (isObject(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js":
  /*!*******************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  module.exports = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js":
  /*!******************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
  module.exports = function (target, src, safe) {
    for (var key in src) {
      if (safe && target[key]) target[key] = src[key];
      else hide(target, key, src[key]);
    } return target;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js":
  /*!**************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js ***!
    \**************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-from.js":
  /*!*************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-from.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  // https://tc39.github.io/proposal-setmap-offrom/
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
  var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");
  
  module.exports = function (COLLECTION) {
    $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];
      if (mapping) {
        n = 0;
        cb = ctx(mapFn, arguments[2], 2);
        forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        forOf(source, false, A.push, A);
      }
      return new this(A);
    } });
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-of.js":
  /*!***********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-of.js ***!
    \***********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  // https://tc39.github.io/proposal-setmap-offrom/
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  
  module.exports = function (COLLECTION) {
    $export($export.S, COLLECTION, { of: function of() {
      var length = arguments.length;
      var A = new Array(length);
      while (length--) A[length] = arguments[length];
      return new this(A);
    } });
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-species.js":
  /*!*****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-species.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
  var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
  var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
  var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js");
  var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('species');
  
  module.exports = function (KEY) {
    var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
    if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js":
  /*!***********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js ***!
    \***********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
  var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
  var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('toStringTag');
  
  module.exports = function (it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js":
  /*!****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var shared = __webpack_require__(/*! ./_shared */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js")('keys');
  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js");
  module.exports = function (key) {
    return shared[key] || (shared[key] = uid(key));
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js":
  /*!************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
  var SHARED = '__core-js_shared__';
  var store = global[SHARED] || (global[SHARED] = {});
  module.exports = function (key) {
    return store[key] || (store[key] = {});
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_species-constructor.js":
  /*!*************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_species-constructor.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 7.3.20 SpeciesConstructor(O, defaultConstructor)
  var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
  var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
  var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('species');
  module.exports = function (O, D) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_string-at.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_string-at.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js");
  var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js");
  // true  -> String#at
  // false -> String#codePointAt
  module.exports = function (TO_STRING) {
    return function (that, pos) {
      var s = String(defined(that));
      var i = toInteger(pos);
      var l = s.length;
      var a, b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_task.js":
  /*!**********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_task.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
  var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_invoke.js");
  var html = __webpack_require__(/*! ./_html */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js");
  var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js");
  var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
  var process = global.process;
  var setTask = global.setImmediate;
  var clearTask = global.clearImmediate;
  var MessageChannel = global.MessageChannel;
  var Dispatch = global.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var defer, channel, port;
  var run = function () {
    var id = +this;
    // eslint-disable-next-line no-prototype-builtins
    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };
  var listener = function (event) {
    run.call(event.data);
  };
  // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
  if (!setTask || !clearTask) {
    setTask = function setImmediate(fn) {
      var args = [];
      var i = 1;
      while (arguments.length > i) args.push(arguments[i++]);
      queue[++counter] = function () {
        // eslint-disable-next-line no-new-func
        invoke(typeof fn == 'function' ? fn : Function(fn), args);
      };
      defer(counter);
      return counter;
    };
    clearTask = function clearImmediate(id) {
      delete queue[id];
    };
    // Node.js 0.8-
    if (__webpack_require__(/*! ./_cof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js")(process) == 'process') {
      defer = function (id) {
        process.nextTick(ctx(run, id, 1));
      };
    // Sphere (JS game engine) Dispatch API
    } else if (Dispatch && Dispatch.now) {
      defer = function (id) {
        Dispatch.now(ctx(run, id, 1));
      };
    // Browsers with MessageChannel, includes WebWorkers
    } else if (MessageChannel) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = ctx(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
      defer = function (id) {
        global.postMessage(id + '', '*');
      };
      global.addEventListener('message', listener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in cel('script')) {
      defer = function (id) {
        html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
          html.removeChild(this);
          run.call(id);
        };
      };
    // Rest old browsers
    } else {
      defer = function (id) {
        setTimeout(ctx(run, id, 1), 0);
      };
    }
  }
  module.exports = {
    set: setTask,
    clear: clearTask
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-absolute-index.js":
  /*!***********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-absolute-index.js ***!
    \***********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js");
  var max = Math.max;
  var min = Math.min;
  module.exports = function (index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js":
  /*!****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  // 7.1.4 ToInteger
  var ceil = Math.ceil;
  var floor = Math.floor;
  module.exports = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js":
  /*!****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // to indexed object, toObject with fallback for non-array-like ES3 strings
  var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js");
  var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js");
  module.exports = function (it) {
    return IObject(defined(it));
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 7.1.15 ToLength
  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js");
  var min = Math.min;
  module.exports = function (it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 7.1.13 ToObject(argument)
  var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js");
  module.exports = function (it) {
    return Object(defined(it));
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js":
  /*!******************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 7.1.1 ToPrimitive(input [, PreferredType])
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  module.exports = function (it, S) {
    if (!isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js":
  /*!*********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js ***!
    \*********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  var id = 0;
  var px = Math.random();
  module.exports = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js":
  /*!*************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
  module.exports = function (it, TYPE) {
    if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
    return it;
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-define.js":
  /*!****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-define.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
  var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js");
  var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-ext.js");
  var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
  module.exports = function (name) {
    var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
    if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-ext.js":
  /*!*************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-ext.js ***!
    \*************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js");
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js":
  /*!*********************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js ***!
    \*********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var store = __webpack_require__(/*! ./_shared */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js")('wks');
  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js");
  var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js").Symbol;
  var USE_SYMBOL = typeof Symbol == 'function';
  
  var $exports = module.exports = function (name) {
    return store[name] || (store[name] =
      USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
  };
  
  $exports.store = store;
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js":
  /*!*****************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js ***!
    \*****************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js");
  var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
  module.exports = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR]
      || it['@@iterator']
      || Iterators[classof(it)];
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator.js":
  /*!**********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
  var get = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js");
  module.exports = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").getIterator = function (it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/core.is-iterable.js":
  /*!*********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/core.is-iterable.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js");
  var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
  module.exports = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").isIterable = function (it) {
    var O = Object(it);
    return O[ITERATOR] !== undefined
      || '@@iterator' in O
      // eslint-disable-next-line no-prototype-builtins
      || Iterators.hasOwnProperty(classof(O));
  };
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.from.js":
  /*!*******************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.from.js ***!
    \*******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
  var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js");
  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js");
  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
  var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_create-property.js");
  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js");
  
  $export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-detect.js")(function (iter) { Array.from(iter); }), 'Array', {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
      var O = toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var index = 0;
      var iterFn = getIterFn(O);
      var length, result, step, iterator;
      if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
      // if object isn't iterable or it's array with default iterator - use simple case
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }
      result.length = index;
      return result;
    }
  });
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.iterator.js":
  /*!***********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.iterator.js ***!
    \***********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_add-to-unscopables.js");
  var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js");
  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
  var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
  
  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
    this._t = toIObject(iterated); // target
    this._i = 0;                   // next index
    this._k = kind;                // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var kind = this._k;
    var index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys') return step(0, index);
    if (kind == 'values') return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  
  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  Iterators.Arguments = Iterators.Array;
  
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.map.js":
  /*!************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.map.js ***!
    \************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-strong.js");
  var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js");
  var MAP = 'Map';
  
  // 23.1 Map Objects
  module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection.js")(MAP, function (get) {
    return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
  }, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function get(key) {
      var entry = strong.getEntry(validate(this, MAP), key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function set(key, value) {
      return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
    }
  }, strong, true);
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.number.is-nan.js":
  /*!**********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.number.is-nan.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 20.1.2.4 Number.isNaN(number)
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  
  $export($export.S, 'Number', {
    isNaN: function isNaN(number) {
      // eslint-disable-next-line no-self-compare
      return number != number;
    }
  });
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.assign.js":
  /*!**********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.assign.js ***!
    \**********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 19.1.3.1 Object.assign(target, source)
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  
  $export($export.S + $export.F, 'Object', { assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-assign.js") });
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-property.js":
  /*!*******************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-property.js ***!
    \*******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
  $export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f });
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.keys.js":
  /*!********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.keys.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // 19.1.2.14 Object.keys(O)
  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
  var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");
  
  __webpack_require__(/*! ./_object-sap */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-sap.js")('keys', function () {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js":
  /*!*************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js ***!
    \*************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.promise.js":
  /*!****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.promise.js ***!
    \****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js");
  var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js");
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
  var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js");
  var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");
  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_species-constructor.js");
  var task = __webpack_require__(/*! ./_task */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_task.js").set;
  var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_microtask.js")();
  var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_new-promise-capability.js");
  var perform = __webpack_require__(/*! ./_perform */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_perform.js");
  var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_promise-resolve.js");
  var PROMISE = 'Promise';
  var TypeError = global.TypeError;
  var process = global.process;
  var $Promise = global[PROMISE];
  var isNode = classof(process) == 'process';
  var empty = function () { /* empty */ };
  var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
  var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
  
  var USE_NATIVE = !!function () {
    try {
      // correct subclassing with @@species support
      var promise = $Promise.resolve(1);
      var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('species')] = function (exec) {
        exec(empty, empty);
      };
      // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
      return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
    } catch (e) { /* empty */ }
  }();
  
  // helpers
  var isThenable = function (it) {
    var then;
    return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };
  var notify = function (promise, isReject) {
    if (promise._n) return;
    promise._n = true;
    var chain = promise._c;
    microtask(function () {
      var value = promise._v;
      var ok = promise._s == 1;
      var i = 0;
      var run = function (reaction) {
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then;
        try {
          if (handler) {
            if (!ok) {
              if (promise._h == 2) onHandleUnhandled(promise);
              promise._h = 1;
            }
            if (handler === true) result = value;
            else {
              if (domain) domain.enter();
              result = handler(value);
              if (domain) domain.exit();
            }
            if (result === reaction.promise) {
              reject(TypeError('Promise-chain cycle'));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (e) {
          reject(e);
        }
      };
      while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
      promise._c = [];
      promise._n = false;
      if (isReject && !promise._h) onUnhandled(promise);
    });
  };
  var onUnhandled = function (promise) {
    task.call(global, function () {
      var value = promise._v;
      var unhandled = isUnhandled(promise);
      var result, handler, console;
      if (unhandled) {
        result = perform(function () {
          if (isNode) {
            process.emit('unhandledRejection', value, promise);
          } else if (handler = global.onunhandledrejection) {
            handler({ promise: promise, reason: value });
          } else if ((console = global.console) && console.error) {
            console.error('Unhandled promise rejection', value);
          }
        });
        // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
        promise._h = isNode || isUnhandled(promise) ? 2 : 1;
      } promise._a = undefined;
      if (unhandled && result.e) throw result.v;
    });
  };
  var isUnhandled = function (promise) {
    return promise._h !== 1 && (promise._a || promise._c).length === 0;
  };
  var onHandleUnhandled = function (promise) {
    task.call(global, function () {
      var handler;
      if (isNode) {
        process.emit('rejectionHandled', promise);
      } else if (handler = global.onrejectionhandled) {
        handler({ promise: promise, reason: promise._v });
      }
    });
  };
  var $reject = function (value) {
    var promise = this;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise; // unwrap
    promise._v = value;
    promise._s = 2;
    if (!promise._a) promise._a = promise._c.slice();
    notify(promise, true);
  };
  var $resolve = function (value) {
    var promise = this;
    var then;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise; // unwrap
    try {
      if (promise === value) throw TypeError("Promise can't be resolved itself");
      if (then = isThenable(value)) {
        microtask(function () {
          var wrapper = { _w: promise, _d: false }; // wrap
          try {
            then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
          } catch (e) {
            $reject.call(wrapper, e);
          }
        });
      } else {
        promise._v = value;
        promise._s = 1;
        notify(promise, false);
      }
    } catch (e) {
      $reject.call({ _w: promise, _d: false }, e); // wrap
    }
  };
  
  // constructor polyfill
  if (!USE_NATIVE) {
    // 25.4.3.1 Promise(executor)
    $Promise = function Promise(executor) {
      anInstance(this, $Promise, PROMISE, '_h');
      aFunction(executor);
      Internal.call(this);
      try {
        executor(ctx($resolve, this, 1), ctx($reject, this, 1));
      } catch (err) {
        $reject.call(this, err);
      }
    };
    // eslint-disable-next-line no-unused-vars
    Internal = function Promise(executor) {
      this._c = [];             // <- awaiting reactions
      this._a = undefined;      // <- checked in isUnhandled reactions
      this._s = 0;              // <- state
      this._d = false;          // <- done
      this._v = undefined;      // <- value
      this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
      this._n = false;          // <- notify
    };
    Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js")($Promise.prototype, {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function then(onFulfilled, onRejected) {
        var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail = typeof onRejected == 'function' && onRejected;
        reaction.domain = isNode ? process.domain : undefined;
        this._c.push(reaction);
        if (this._a) this._a.push(reaction);
        if (this._s) notify(this, false);
        return reaction.promise;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function (onRejected) {
        return this.then(undefined, onRejected);
      }
    });
    OwnPromiseCapability = function () {
      var promise = new Internal();
      this.promise = promise;
      this.resolve = ctx($resolve, promise, 1);
      this.reject = ctx($reject, promise, 1);
    };
    newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
      return C === $Promise || C === Wrapper
        ? new OwnPromiseCapability(C)
        : newGenericPromiseCapability(C);
    };
  }
  
  $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
  __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js")($Promise, PROMISE);
  __webpack_require__(/*! ./_set-species */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-species.js")(PROMISE);
  Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js")[PROMISE];
  
  // statics
  $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
    // 25.4.4.5 Promise.reject(r)
    reject: function reject(r) {
      var capability = newPromiseCapability(this);
      var $$reject = capability.reject;
      $$reject(r);
      return capability.promise;
    }
  });
  $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
    // 25.4.4.6 Promise.resolve(x)
    resolve: function resolve(x) {
      return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
    }
  });
  $export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-detect.js")(function (iter) {
    $Promise.all(iter)['catch'](empty);
  })), PROMISE, {
    // 25.4.4.1 Promise.all(iterable)
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var values = [];
        var index = 0;
        var remaining = 1;
        forOf(iterable, false, function (promise) {
          var $index = index++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          C.resolve(promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[$index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.e) reject(result.v);
      return capability.promise;
    },
    // 25.4.4.4 Promise.race(iterable)
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var reject = capability.reject;
      var result = perform(function () {
        forOf(iterable, false, function (promise) {
          C.resolve(promise).then(capability.resolve, reject);
        });
      });
      if (result.e) reject(result.v);
      return capability.promise;
    }
  });
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js":
  /*!************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_string-at.js")(true);
  
  // 21.1.3.27 String.prototype[@@iterator]()
  __webpack_require__(/*! ./_iter-define */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js")(String, 'String', function (iterated) {
    this._t = String(iterated); // target
    this._i = 0;                // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var index = this._i;
    var point;
    if (index >= O.length) return { value: undefined, done: true };
    point = $at(O, index);
    this._i += point.length;
    return { value: point, done: false };
  });
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.symbol.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.symbol.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  // ECMAScript 6 symbols shim
  var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
  var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
  var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js");
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js");
  var META = __webpack_require__(/*! ./_meta */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js").KEY;
  var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js");
  var shared = __webpack_require__(/*! ./_shared */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js");
  var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js");
  var wks = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js");
  var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-ext.js");
  var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-define.js");
  var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-keys.js");
  var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js");
  var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
  var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js");
  var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
  var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js");
  var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopn-ext.js");
  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopd.js");
  var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
  var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");
  var gOPD = $GOPD.f;
  var dP = $DP.f;
  var gOPN = gOPNExt.f;
  var $Symbol = global.Symbol;
  var $JSON = global.JSON;
  var _stringify = $JSON && $JSON.stringify;
  var PROTOTYPE = 'prototype';
  var HIDDEN = wks('_hidden');
  var TO_PRIMITIVE = wks('toPrimitive');
  var isEnum = {}.propertyIsEnumerable;
  var SymbolRegistry = shared('symbol-registry');
  var AllSymbols = shared('symbols');
  var OPSymbols = shared('op-symbols');
  var ObjectProto = Object[PROTOTYPE];
  var USE_NATIVE = typeof $Symbol == 'function';
  var QObject = global.QObject;
  // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
  var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
  
  // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
  var setSymbolDesc = DESCRIPTORS && $fails(function () {
    return _create(dP({}, 'a', {
      get: function () { return dP(this, 'a', { value: 7 }).a; }
    })).a != 7;
  }) ? function (it, key, D) {
    var protoDesc = gOPD(ObjectProto, key);
    if (protoDesc) delete ObjectProto[key];
    dP(it, key, D);
    if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
  } : dP;
  
  var wrap = function (tag) {
    var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
    sym._k = tag;
    return sym;
  };
  
  var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    return it instanceof $Symbol;
  };
  
  var $defineProperty = function defineProperty(it, key, D) {
    if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
    anObject(it);
    key = toPrimitive(key, true);
    anObject(D);
    if (has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
        D = _create(D, { enumerable: createDesc(0, false) });
      } return setSymbolDesc(it, key, D);
    } return dP(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P));
    var i = 0;
    var l = keys.length;
    var key;
    while (l > i) $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key = toPrimitive(key, true));
    if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    it = toIObject(it);
    key = toPrimitive(key, true);
    if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
    var D = gOPD(it, key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = gOPN(toIObject(it));
    var result = [];
    var i = 0;
    var key;
    while (names.length > i) {
      if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
    } return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var IS_OP = it === ObjectProto;
    var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
    var result = [];
    var i = 0;
    var key;
    while (names.length > i) {
      if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
    } return result;
  };
  
  // 19.4.1.1 Symbol([description])
  if (!USE_NATIVE) {
    $Symbol = function Symbol() {
      if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
      var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
      var $set = function (value) {
        if (this === ObjectProto) $set.call(OPSymbols, value);
        if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      };
      if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
      return wrap(tag);
    };
    redefine($Symbol[PROTOTYPE], 'toString', function toString() {
      return this._k;
    });
  
    $GOPD.f = $getOwnPropertyDescriptor;
    $DP.f = $defineProperty;
    __webpack_require__(/*! ./_object-gopn */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
    __webpack_require__(/*! ./_object-pie */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js").f = $propertyIsEnumerable;
    __webpack_require__(/*! ./_object-gops */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js").f = $getOwnPropertySymbols;
  
    if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js")) {
      redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }
  
    wksExt.f = function (name) {
      return wrap(wks(name));
    };
  }
  
  $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
  
  for (var es6Symbols = (
    // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);
  
  for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);
  
  $export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
    // 19.4.2.1 Symbol.for(key)
    'for': function (key) {
      return has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = $Symbol(key);
    },
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
      for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
    },
    useSetter: function () { setter = true; },
    useSimple: function () { setter = false; }
  });
  
  $export($export.S + $export.F * !USE_NATIVE, 'Object', {
    // 19.1.2.2 Object.create(O [, Properties])
    create: $create,
    // 19.1.2.4 Object.defineProperty(O, P, Attributes)
    defineProperty: $defineProperty,
    // 19.1.2.3 Object.defineProperties(O, Properties)
    defineProperties: $defineProperties,
    // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: $getOwnPropertyNames,
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  
  // 24.3.2 JSON.stringify(value [, replacer [, space]])
  $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
    var S = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    // WebKit converts symbol values to JSON as null
    // V8 throws on boxed symbols
    return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
  })), 'JSON', {
    stringify: function stringify(it) {
      var args = [it];
      var i = 1;
      var replacer, $replacer;
      while (arguments.length > i) args.push(arguments[i++]);
      $replacer = replacer = args[1];
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return _stringify.apply($JSON, args);
    }
  });
  
  // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
  $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
  // 19.4.3.5 Symbol.prototype[@@toStringTag]
  setToStringTag($Symbol, 'Symbol');
  // 20.2.1.9 Math[@@toStringTag]
  setToStringTag(Math, 'Math', true);
  // 24.3.3 JSON[@@toStringTag]
  setToStringTag(global.JSON, 'JSON', true);
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.from.js":
  /*!*****************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.from.js ***!
    \*****************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
  __webpack_require__(/*! ./_set-collection-from */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-from.js")('Map');
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.of.js":
  /*!***************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.of.js ***!
    \***************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
  __webpack_require__(/*! ./_set-collection-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-of.js")('Map');
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.to-json.js":
  /*!********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.to-json.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  // https://github.com/DavidBruant/Map-Set.prototype.toJSON
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  
  $export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(/*! ./_collection-to-json */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-to-json.js")('Map') });
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.promise.finally.js":
  /*!************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.promise.finally.js ***!
    \************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  // https://github.com/tc39/proposal-promise-finally
  
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
  var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_species-constructor.js");
  var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_promise-resolve.js");
  
  $export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(
      isFunction ? function (x) {
        return promiseResolve(C, onFinally()).then(function () { return x; });
      } : onFinally,
      isFunction ? function (e) {
        return promiseResolve(C, onFinally()).then(function () { throw e; });
      } : onFinally
    );
  } });
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.promise.try.js":
  /*!********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.promise.try.js ***!
    \********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  "use strict";
  
  // https://github.com/tc39/proposal-promise-try
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
  var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_new-promise-capability.js");
  var perform = __webpack_require__(/*! ./_perform */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_perform.js");
  
  $export($export.S, 'Promise', { 'try': function (callbackfn) {
    var promiseCapability = newPromiseCapability.f(this);
    var result = perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  } });
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.symbol.async-iterator.js":
  /*!******************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.symbol.async-iterator.js ***!
    \******************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ./_wks-define */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-define.js")('asyncIterator');
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.symbol.observable.js":
  /*!**************************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.symbol.observable.js ***!
    \**************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ./_wks-define */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-define.js")('observable');
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js":
  /*!*********************************************************************************************!*\
    !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js ***!
    \*********************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.iterator.js");
  var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
  var TO_STRING_TAG = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('toStringTag');
  
  var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
    'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
    'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
    'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
    'TextTrackList,TouchList').split(',');
  
  for (var i = 0; i < DOMIterables.length; i++) {
    var NAME = DOMIterables[i];
    var Collection = global[NAME];
    var proto = Collection && Collection.prototype;
    if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = Iterators.Array;
  }
  
  
  /***/ }),
  
  /***/ "./node_modules/babel-runtime/regenerator/index.js":
  /*!*********************************************************!*\
    !*** ./node_modules/babel-runtime/regenerator/index.js ***!
    \*********************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime-module.js");
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_DataView.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_DataView.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
      root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
  
  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root, 'DataView');
  
  module.exports = DataView;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_Hash.js":
  /*!**************************************!*\
    !*** ./node_modules/lodash/_Hash.js ***!
    \**************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
      hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
      hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
      hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
      hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");
  
  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
  
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  
  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  
  module.exports = Hash;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_ListCache.js":
  /*!*******************************************!*\
    !*** ./node_modules/lodash/_ListCache.js ***!
    \*******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
      listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
      listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
      listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
      listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");
  
  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
  
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  
  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  
  module.exports = ListCache;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_Map.js":
  /*!*************************************!*\
    !*** ./node_modules/lodash/_Map.js ***!
    \*************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
      root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
  
  /* Built-in method references that are verified to be native. */
  var Map = getNative(root, 'Map');
  
  module.exports = Map;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_MapCache.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_MapCache.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
      mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
      mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
      mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
      mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");
  
  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
  
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  
  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  
  module.exports = MapCache;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_Promise.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/_Promise.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
      root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
  
  /* Built-in method references that are verified to be native. */
  var Promise = getNative(root, 'Promise');
  
  module.exports = Promise;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_Set.js":
  /*!*************************************!*\
    !*** ./node_modules/lodash/_Set.js ***!
    \*************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
      root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
  
  /* Built-in method references that are verified to be native. */
  var Set = getNative(root, 'Set');
  
  module.exports = Set;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_SetCache.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_SetCache.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
      setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
      setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");
  
  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
  
    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }
  
  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  
  module.exports = SetCache;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_Stack.js":
  /*!***************************************!*\
    !*** ./node_modules/lodash/_Stack.js ***!
    \***************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
      stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
      stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
      stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
      stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
      stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");
  
  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  
  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  
  module.exports = Stack;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_Symbol.js":
  /*!****************************************!*\
    !*** ./node_modules/lodash/_Symbol.js ***!
    \****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
  
  /** Built-in value references. */
  var Symbol = root.Symbol;
  
  module.exports = Symbol;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_Uint8Array.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_Uint8Array.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
  
  /** Built-in value references. */
  var Uint8Array = root.Uint8Array;
  
  module.exports = Uint8Array;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_WeakMap.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/_WeakMap.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
      root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
  
  /* Built-in method references that are verified to be native. */
  var WeakMap = getNative(root, 'WeakMap');
  
  module.exports = WeakMap;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_arrayFilter.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_arrayFilter.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];
  
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  
  module.exports = arrayFilter;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_arrayLikeKeys.js":
  /*!***********************************************!*\
    !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
    \***********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
      isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
      isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
      isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
      isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
      isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
  
  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;
  
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }
  
  module.exports = arrayLikeKeys;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_arrayMap.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_arrayMap.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);
  
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  
  module.exports = arrayMap;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_arrayPush.js":
  /*!*******************************************!*\
    !*** ./node_modules/lodash/_arrayPush.js ***!
    \*******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;
  
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  
  module.exports = arrayPush;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_arraySome.js":
  /*!*******************************************!*\
    !*** ./node_modules/lodash/_arraySome.js ***!
    \*******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;
  
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  
  module.exports = arraySome;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_assocIndexOf.js":
  /*!**********************************************!*\
    !*** ./node_modules/lodash/_assocIndexOf.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");
  
  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  
  module.exports = assocIndexOf;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseFindIndex.js":
  /*!***********************************************!*\
    !*** ./node_modules/lodash/_baseFindIndex.js ***!
    \***********************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);
  
    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  
  module.exports = baseFindIndex;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseFlatten.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_baseFlatten.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
      isFlattenable = __webpack_require__(/*! ./_isFlattenable */ "./node_modules/lodash/_isFlattenable.js");
  
  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;
  
    predicate || (predicate = isFlattenable);
    result || (result = []);
  
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  
  module.exports = baseFlatten;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseGet.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/_baseGet.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
      toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
  
  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = castPath(path, object);
  
    var index = 0,
        length = path.length;
  
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }
  
  module.exports = baseGet;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseGetAllKeys.js":
  /*!************************************************!*\
    !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
    \************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
      isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
  
  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  
  module.exports = baseGetAllKeys;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseGetTag.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_baseGetTag.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
      getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
      objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");
  
  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  
  /** Built-in value references. */
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
  
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }
  
  module.exports = baseGetTag;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseHasIn.js":
  /*!*******************************************!*\
    !*** ./node_modules/lodash/_baseHasIn.js ***!
    \*******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  
  module.exports = baseHasIn;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseIsArguments.js":
  /*!*************************************************!*\
    !*** ./node_modules/lodash/_baseIsArguments.js ***!
    \*************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
      isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
  
  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]';
  
  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  
  module.exports = baseIsArguments;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseIsEqual.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_baseIsEqual.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
      isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
  
  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  
  module.exports = baseIsEqual;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseIsEqualDeep.js":
  /*!*************************************************!*\
    !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
    \*************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
      equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
      equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
      equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
      getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
      isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
      isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
      isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
  
  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1;
  
  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      objectTag = '[object Object]';
  
  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag : getTag(object),
        othTag = othIsArr ? arrayTag : getTag(other);
  
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
  
    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;
  
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack);
      return (objIsArr || isTypedArray(object))
        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
  
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
  
        stack || (stack = new Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  
  module.exports = baseIsEqualDeep;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseIsMatch.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_baseIsMatch.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
      baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");
  
  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  
  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;
  
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if ((noCustomizer && data[2])
            ? data[1] !== object[data[0]]
            : !(data[0] in object)
          ) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];
  
      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined
              ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
              : result
            )) {
          return false;
        }
      }
    }
    return true;
  }
  
  module.exports = baseIsMatch;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseIsNative.js":
  /*!**********************************************!*\
    !*** ./node_modules/lodash/_baseIsNative.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
      isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
      isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
      toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");
  
  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  
  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  
  /** Used for built-in method references. */
  var funcProto = Function.prototype,
      objectProto = Object.prototype;
  
  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );
  
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  
  module.exports = baseIsNative;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseIsTypedArray.js":
  /*!**************************************************!*\
    !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
    \**************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
      isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
      isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
  
  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  
  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;
  
  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) &&
      isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  
  module.exports = baseIsTypedArray;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseIteratee.js":
  /*!**********************************************!*\
    !*** ./node_modules/lodash/_baseIteratee.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseMatches = __webpack_require__(/*! ./_baseMatches */ "./node_modules/lodash/_baseMatches.js"),
      baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ "./node_modules/lodash/_baseMatchesProperty.js"),
      identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
      isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
      property = __webpack_require__(/*! ./property */ "./node_modules/lodash/property.js");
  
  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == 'object') {
      return isArray(value)
        ? baseMatchesProperty(value[0], value[1])
        : baseMatches(value);
    }
    return property(value);
  }
  
  module.exports = baseIteratee;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseKeys.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_baseKeys.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
      nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");
  
  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }
  
  module.exports = baseKeys;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseMatches.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_baseMatches.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ "./node_modules/lodash/_baseIsMatch.js"),
      getMatchData = __webpack_require__(/*! ./_getMatchData */ "./node_modules/lodash/_getMatchData.js"),
      matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js");
  
  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  
  module.exports = baseMatches;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseMatchesProperty.js":
  /*!*****************************************************!*\
    !*** ./node_modules/lodash/_baseMatchesProperty.js ***!
    \*****************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"),
      get = __webpack_require__(/*! ./get */ "./node_modules/lodash/get.js"),
      hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js"),
      isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
      isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
      matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"),
      toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
  
  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  
  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return (objValue === undefined && objValue === srcValue)
        ? hasIn(object, path)
        : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  
  module.exports = baseMatchesProperty;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseProperty.js":
  /*!**********************************************!*\
    !*** ./node_modules/lodash/_baseProperty.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }
  
  module.exports = baseProperty;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_basePropertyDeep.js":
  /*!**************************************************!*\
    !*** ./node_modules/lodash/_basePropertyDeep.js ***!
    \**************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");
  
  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }
  
  module.exports = basePropertyDeep;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseTimes.js":
  /*!*******************************************!*\
    !*** ./node_modules/lodash/_baseTimes.js ***!
    \*******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);
  
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  
  module.exports = baseTimes;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseToString.js":
  /*!**********************************************!*\
    !*** ./node_modules/lodash/_baseToString.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
      arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
      isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
      isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
  
  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;
  
  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;
  
  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }
  
  module.exports = baseToString;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_baseUnary.js":
  /*!*******************************************!*\
    !*** ./node_modules/lodash/_baseUnary.js ***!
    \*******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  
  module.exports = baseUnary;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_cacheHas.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_cacheHas.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  
  module.exports = cacheHas;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_castPath.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_castPath.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
      isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
      stringToPath = __webpack_require__(/*! ./_stringToPath */ "./node_modules/lodash/_stringToPath.js"),
      toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");
  
  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }
  
  module.exports = castPath;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_coreJsData.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_coreJsData.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
  
  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];
  
  module.exports = coreJsData;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_createFind.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_createFind.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
      isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
      keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
  
  /**
   * Creates a `_.find` or `_.findLast` function.
   *
   * @private
   * @param {Function} findIndexFunc The function to find the collection index.
   * @returns {Function} Returns the new find function.
   */
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = baseIteratee(predicate, 3);
        collection = keys(collection);
        predicate = function(key) { return iteratee(iterable[key], key, iterable); };
      }
      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
    };
  }
  
  module.exports = createFind;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_equalArrays.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_equalArrays.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
      arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
      cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");
  
  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  
  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;
  
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;
  
    stack.set(array, other);
    stack.set(other, array);
  
    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];
  
      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!arraySome(other, function(othValue, othIndex) {
              if (!cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }
  
  module.exports = equalArrays;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_equalByTag.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_equalByTag.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
      Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
      eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
      equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
      mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
      setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");
  
  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  
  /** `Object#toString` result references. */
  var boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]';
  
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]';
  
  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  
  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
  
      case arrayBufferTag:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;
  
      case boolTag:
      case dateTag:
      case numberTag:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);
  
      case errorTag:
        return object.name == other.name && object.message == other.message;
  
      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');
  
      case mapTag:
        var convert = mapToArray;
  
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
  
        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
  
        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;
  
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  
  module.exports = equalByTag;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_equalObjects.js":
  /*!**********************************************!*\
    !*** ./node_modules/lodash/_equalObjects.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");
  
  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1;
  
  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;
  
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
  
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];
  
      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;
  
      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }
  
  module.exports = equalObjects;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_freeGlobal.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_freeGlobal.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  /* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  
  module.exports = freeGlobal;
  
  /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_getAllKeys.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_getAllKeys.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
      getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
      keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
  
  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  
  module.exports = getAllKeys;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_getMapData.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_getMapData.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");
  
  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }
  
  module.exports = getMapData;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_getMatchData.js":
  /*!**********************************************!*\
    !*** ./node_modules/lodash/_getMatchData.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
      keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
  
  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData(object) {
    var result = keys(object),
        length = result.length;
  
    while (length--) {
      var key = result[length],
          value = object[key];
  
      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  
  module.exports = getMatchData;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_getNative.js":
  /*!*******************************************!*\
    !*** ./node_modules/lodash/_getNative.js ***!
    \*******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
      getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");
  
  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  
  module.exports = getNative;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_getRawTag.js":
  /*!*******************************************!*\
    !*** ./node_modules/lodash/_getRawTag.js ***!
    \*******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");
  
  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;
  
  /** Built-in value references. */
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
  
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];
  
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}
  
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  
  module.exports = getRawTag;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_getSymbols.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_getSymbols.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
      stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");
  
  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  
  /** Built-in value references. */
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  
  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  
  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  
  module.exports = getSymbols;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_getTag.js":
  /*!****************************************!*\
    !*** ./node_modules/lodash/_getTag.js ***!
    \****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
      Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
      Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
      Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
      WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
      baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
      toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");
  
  /** `Object#toString` result references. */
  var mapTag = '[object Map]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      setTag = '[object Set]',
      weakMapTag = '[object WeakMap]';
  
  var dataViewTag = '[object DataView]';
  
  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);
  
  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;
  
  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
      (Map && getTag(new Map) != mapTag) ||
      (Promise && getTag(Promise.resolve()) != promiseTag) ||
      (Set && getTag(new Set) != setTag) ||
      (WeakMap && getTag(new WeakMap) != weakMapTag)) {
    getTag = function(value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';
  
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag;
          case mapCtorString: return mapTag;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag;
          case weakMapCtorString: return weakMapTag;
        }
      }
      return result;
    };
  }
  
  module.exports = getTag;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_getValue.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_getValue.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  
  module.exports = getValue;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_hasPath.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/_hasPath.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
      isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
      isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
      isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
      isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
      toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
  
  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
  
    var index = -1,
        length = path.length,
        result = false;
  
    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) &&
      (isArray(object) || isArguments(object));
  }
  
  module.exports = hasPath;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_hashClear.js":
  /*!*******************************************!*\
    !*** ./node_modules/lodash/_hashClear.js ***!
    \*******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
  
  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  
  module.exports = hashClear;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_hashDelete.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_hashDelete.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  
  module.exports = hashDelete;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_hashGet.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/_hashGet.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
  
  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  
  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  
  module.exports = hashGet;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_hashHas.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/_hashHas.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
  
  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
  }
  
  module.exports = hashHas;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_hashSet.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/_hashSet.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
  
  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }
  
  module.exports = hashSet;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_isFlattenable.js":
  /*!***********************************************!*\
    !*** ./node_modules/lodash/_isFlattenable.js ***!
    \***********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
      isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
      isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
  
  /** Built-in value references. */
  var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
  
  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) ||
      !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  
  module.exports = isFlattenable;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_isIndex.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/_isIndex.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;
  
  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
  
    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }
  
  module.exports = isIndex;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_isKey.js":
  /*!***************************************!*\
    !*** ./node_modules/lodash/_isKey.js ***!
    \***************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
      isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
  
  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;
  
  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }
  
  module.exports = isKey;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_isKeyable.js":
  /*!*******************************************!*\
    !*** ./node_modules/lodash/_isKeyable.js ***!
    \*******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }
  
  module.exports = isKeyable;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_isMasked.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_isMasked.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");
  
  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());
  
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }
  
  module.exports = isMasked;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_isPrototype.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_isPrototype.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
  
    return value === proto;
  }
  
  module.exports = isPrototype;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_isStrictComparable.js":
  /*!****************************************************!*\
    !*** ./node_modules/lodash/_isStrictComparable.js ***!
    \****************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
  
  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  
  module.exports = isStrictComparable;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_listCacheClear.js":
  /*!************************************************!*\
    !*** ./node_modules/lodash/_listCacheClear.js ***!
    \************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  
  module.exports = listCacheClear;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_listCacheDelete.js":
  /*!*************************************************!*\
    !*** ./node_modules/lodash/_listCacheDelete.js ***!
    \*************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
  
  /** Used for built-in method references. */
  var arrayProto = Array.prototype;
  
  /** Built-in value references. */
  var splice = arrayProto.splice;
  
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
  
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  
  module.exports = listCacheDelete;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_listCacheGet.js":
  /*!**********************************************!*\
    !*** ./node_modules/lodash/_listCacheGet.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
  
  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
  
    return index < 0 ? undefined : data[index][1];
  }
  
  module.exports = listCacheGet;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_listCacheHas.js":
  /*!**********************************************!*\
    !*** ./node_modules/lodash/_listCacheHas.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
  
  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  
  module.exports = listCacheHas;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_listCacheSet.js":
  /*!**********************************************!*\
    !*** ./node_modules/lodash/_listCacheSet.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
  
  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
  
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  
  module.exports = listCacheSet;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_mapCacheClear.js":
  /*!***********************************************!*\
    !*** ./node_modules/lodash/_mapCacheClear.js ***!
    \***********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
      ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
      Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");
  
  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map || ListCache),
      'string': new Hash
    };
  }
  
  module.exports = mapCacheClear;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_mapCacheDelete.js":
  /*!************************************************!*\
    !*** ./node_modules/lodash/_mapCacheDelete.js ***!
    \************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
  
  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  
  module.exports = mapCacheDelete;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_mapCacheGet.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_mapCacheGet.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
  
  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  
  module.exports = mapCacheGet;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_mapCacheHas.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_mapCacheHas.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
  
  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  
  module.exports = mapCacheHas;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_mapCacheSet.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_mapCacheSet.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
  
  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;
  
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  
  module.exports = mapCacheSet;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_mapToArray.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_mapToArray.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
  
    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  
  module.exports = mapToArray;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_matchesStrictComparable.js":
  /*!*********************************************************!*\
    !*** ./node_modules/lodash/_matchesStrictComparable.js ***!
    \*********************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue &&
        (srcValue !== undefined || (key in Object(object)));
    };
  }
  
  module.exports = matchesStrictComparable;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_memoizeCapped.js":
  /*!***********************************************!*\
    !*** ./node_modules/lodash/_memoizeCapped.js ***!
    \***********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var memoize = __webpack_require__(/*! ./memoize */ "./node_modules/lodash/memoize.js");
  
  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;
  
  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
  
    var cache = result.cache;
    return result;
  }
  
  module.exports = memoizeCapped;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_nativeCreate.js":
  /*!**********************************************!*\
    !*** ./node_modules/lodash/_nativeCreate.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");
  
  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');
  
  module.exports = nativeCreate;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_nativeKeys.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_nativeKeys.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");
  
  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = overArg(Object.keys, Object);
  
  module.exports = nativeKeys;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_nodeUtil.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_nodeUtil.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  /* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
  
  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  
  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  
  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;
  
  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;
  
  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;
  
      if (types) {
        return types;
      }
  
      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());
  
  module.exports = nodeUtil;
  
  /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_objectToString.js":
  /*!************************************************!*\
    !*** ./node_modules/lodash/_objectToString.js ***!
    \************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;
  
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  
  module.exports = objectToString;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_overArg.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/_overArg.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  
  module.exports = overArg;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_root.js":
  /*!**************************************!*\
    !*** ./node_modules/lodash/_root.js ***!
    \**************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
  
  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  
  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();
  
  module.exports = root;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_setCacheAdd.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_setCacheAdd.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  
  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  
  module.exports = setCacheAdd;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_setCacheHas.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_setCacheHas.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  
  module.exports = setCacheHas;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_setToArray.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_setToArray.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
  
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  
  module.exports = setToArray;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_stackClear.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/_stackClear.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");
  
  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }
  
  module.exports = stackClear;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_stackDelete.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/_stackDelete.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
  
    this.size = data.size;
    return result;
  }
  
  module.exports = stackDelete;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_stackGet.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_stackGet.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }
  
  module.exports = stackGet;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_stackHas.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_stackHas.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }
  
  module.exports = stackHas;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_stackSet.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_stackSet.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
      Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
      MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");
  
  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;
  
  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  
  module.exports = stackSet;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_stringToPath.js":
  /*!**********************************************!*\
    !*** ./node_modules/lodash/_stringToPath.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ "./node_modules/lodash/_memoizeCapped.js");
  
  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  
  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;
  
  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });
  
  module.exports = stringToPath;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_toKey.js":
  /*!***************************************!*\
    !*** ./node_modules/lodash/_toKey.js ***!
    \***************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
  
  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;
  
  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }
  
  module.exports = toKey;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/_toSource.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/_toSource.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /** Used for built-in method references. */
  var funcProto = Function.prototype;
  
  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;
  
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }
  
  module.exports = toSource;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/eq.js":
  /*!***********************************!*\
    !*** ./node_modules/lodash/eq.js ***!
    \***********************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }
  
  module.exports = eq;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/find.js":
  /*!*************************************!*\
    !*** ./node_modules/lodash/find.js ***!
    \*************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var createFind = __webpack_require__(/*! ./_createFind */ "./node_modules/lodash/_createFind.js"),
      findIndex = __webpack_require__(/*! ./findIndex */ "./node_modules/lodash/findIndex.js");
  
  /**
   * Iterates over elements of `collection`, returning the first element
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {*} Returns the matched element, else `undefined`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36, 'active': true },
   *   { 'user': 'fred',    'age': 40, 'active': false },
   *   { 'user': 'pebbles', 'age': 1,  'active': true }
   * ];
   *
   * _.find(users, function(o) { return o.age < 40; });
   * // => object for 'barney'
   *
   * // The `_.matches` iteratee shorthand.
   * _.find(users, { 'age': 1, 'active': true });
   * // => object for 'pebbles'
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.find(users, ['active', false]);
   * // => object for 'fred'
   *
   * // The `_.property` iteratee shorthand.
   * _.find(users, 'active');
   * // => object for 'barney'
   */
  var find = createFind(findIndex);
  
  module.exports = find;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/findIndex.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/findIndex.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
      baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
      toInteger = __webpack_require__(/*! ./toInteger */ "./node_modules/lodash/toInteger.js");
  
  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;
  
  /**
   * This method is like `_.find` except that it returns the index of the first
   * element `predicate` returns truthy for instead of the element itself.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.findIndex(users, function(o) { return o.user == 'barney'; });
   * // => 0
   *
   * // The `_.matches` iteratee shorthand.
   * _.findIndex(users, { 'user': 'fred', 'active': false });
   * // => 1
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findIndex(users, ['active', false]);
   * // => 0
   *
   * // The `_.property` iteratee shorthand.
   * _.findIndex(users, 'active');
   * // => 2
   */
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return baseFindIndex(array, baseIteratee(predicate, 3), index);
  }
  
  module.exports = findIndex;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/flatten.js":
  /*!****************************************!*\
    !*** ./node_modules/lodash/flatten.js ***!
    \****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js");
  
  /**
   * Flattens `array` a single level deep.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to flatten.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * _.flatten([1, [2, [3, [4]], 5]]);
   * // => [1, 2, [3, [4]], 5]
   */
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }
  
  module.exports = flatten;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/get.js":
  /*!************************************!*\
    !*** ./node_modules/lodash/get.js ***!
    \************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");
  
  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }
  
  module.exports = get;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/hasIn.js":
  /*!**************************************!*\
    !*** ./node_modules/lodash/hasIn.js ***!
    \**************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseHasIn = __webpack_require__(/*! ./_baseHasIn */ "./node_modules/lodash/_baseHasIn.js"),
      hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");
  
  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  
  module.exports = hasIn;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/identity.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/identity.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }
  
  module.exports = identity;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/isArguments.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/isArguments.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
      isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
  
  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /** Built-in value references. */
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };
  
  module.exports = isArguments;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/isArray.js":
  /*!****************************************!*\
    !*** ./node_modules/lodash/isArray.js ***!
    \****************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;
  
  module.exports = isArray;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/isArrayLike.js":
  /*!********************************************!*\
    !*** ./node_modules/lodash/isArrayLike.js ***!
    \********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
      isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");
  
  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  
  module.exports = isArrayLike;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/isBuffer.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/isBuffer.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  /* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
      stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");
  
  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  
  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  
  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;
  
  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined;
  
  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
  
  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;
  
  module.exports = isBuffer;
  
  /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))
  
  /***/ }),
  
  /***/ "./node_modules/lodash/isFunction.js":
  /*!*******************************************!*\
    !*** ./node_modules/lodash/isFunction.js ***!
    \*******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
      isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
  
  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';
  
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  
  module.exports = isFunction;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/isLength.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/isLength.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;
  
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  
  module.exports = isLength;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/isObject.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/isObject.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }
  
  module.exports = isObject;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/isObjectLike.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/isObjectLike.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }
  
  module.exports = isObjectLike;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/isSymbol.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/isSymbol.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
      isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
  
  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';
  
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag);
  }
  
  module.exports = isSymbol;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/isTypedArray.js":
  /*!*********************************************!*\
    !*** ./node_modules/lodash/isTypedArray.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
      baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
      nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
  
  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  
  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  
  module.exports = isTypedArray;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/keys.js":
  /*!*************************************!*\
    !*** ./node_modules/lodash/keys.js ***!
    \*************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
      baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
      isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
  
  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  
  module.exports = keys;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/memoize.js":
  /*!****************************************!*\
    !*** ./node_modules/lodash/memoize.js ***!
    \****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");
  
  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';
  
  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;
  
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }
  
  // Expose `MapCache`.
  memoize.Cache = MapCache;
  
  module.exports = memoize;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/property.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/property.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js"),
      basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ "./node_modules/lodash/_basePropertyDeep.js"),
      isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
      toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
  
  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  
  module.exports = property;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/stubArray.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/stubArray.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }
  
  module.exports = stubArray;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/stubFalse.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/stubFalse.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }
  
  module.exports = stubFalse;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/toFinite.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/toFinite.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");
  
  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;
  
  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = (value < 0 ? -1 : 1);
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  
  module.exports = toFinite;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/toInteger.js":
  /*!******************************************!*\
    !*** ./node_modules/lodash/toInteger.js ***!
    \******************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var toFinite = __webpack_require__(/*! ./toFinite */ "./node_modules/lodash/toFinite.js");
  
  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  function toInteger(value) {
    var result = toFinite(value),
        remainder = result % 1;
  
    return result === result ? (remainder ? result - remainder : result) : 0;
  }
  
  module.exports = toInteger;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/toNumber.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/toNumber.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
      isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
  
  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;
  
  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g;
  
  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  
  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;
  
  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;
  
  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;
  
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }
  
  module.exports = toNumber;
  
  
  /***/ }),
  
  /***/ "./node_modules/lodash/toString.js":
  /*!*****************************************!*\
    !*** ./node_modules/lodash/toString.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js");
  
  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }
  
  module.exports = toString;
  
  
  /***/ }),
  
  /***/ "./node_modules/regenerator-runtime/runtime-module.js":
  /*!************************************************************!*\
    !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
    \************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  
  // This method of obtaining a reference to the global object needs to be
  // kept identical to the way it is obtained in runtime.js
  var g = (function() { return this })() || Function("return this")();
  
  // Use `getOwnPropertyNames` because not all browsers support calling
  // `hasOwnProperty` on the global `self` object in a worker. See #183.
  var hadRuntime = g.regeneratorRuntime &&
    Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
  
  // Save the old regeneratorRuntime in case it needs to be restored later.
  var oldRuntime = hadRuntime && g.regeneratorRuntime;
  
  // Force reevalutation of runtime.js.
  g.regeneratorRuntime = undefined;
  
  module.exports = __webpack_require__(/*! ./runtime */ "./node_modules/regenerator-runtime/runtime.js");
  
  if (hadRuntime) {
    // Restore the original runtime.
    g.regeneratorRuntime = oldRuntime;
  } else {
    // Remove the global property added by runtime.js.
    try {
      delete g.regeneratorRuntime;
    } catch(e) {
      g.regeneratorRuntime = undefined;
    }
  }
  
  
  /***/ }),
  
  /***/ "./node_modules/regenerator-runtime/runtime.js":
  /*!*****************************************************!*\
    !*** ./node_modules/regenerator-runtime/runtime.js ***!
    \*****************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  
  !(function(global) {
    "use strict";
  
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  
    var inModule = typeof module === "object";
    var runtime = global.regeneratorRuntime;
    if (runtime) {
      if (inModule) {
        // If regeneratorRuntime is defined globally and we're in a module,
        // make the exports object identical to regeneratorRuntime.
        module.exports = runtime;
      }
      // Don't bother evaluating the rest of this file if the runtime was
      // already defined globally.
      return;
    }
  
    // Define the runtime globally (as expected by generated code) as either
    // module.exports (if we're in a module) or a new, empty object.
    runtime = global.regeneratorRuntime = inModule ? module.exports : {};
  
    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
  
      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);
  
      return generator;
    }
    runtime.wrap = wrap;
  
    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
  
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
  
    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};
  
    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
  
    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };
  
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }
  
    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] =
      GeneratorFunction.displayName = "GeneratorFunction";
  
    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        prototype[method] = function(arg) {
          return this._invoke(method, arg);
        };
      });
    }
  
    runtime.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };
  
    runtime.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
  
    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    runtime.awrap = function(arg) {
      return { __await: arg };
    };
  
    function AsyncIterator(generator) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return Promise.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }
  
          return Promise.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration. If the Promise is rejected, however, the
            // result for this iteration will be rejected with the same
            // reason. Note that rejections of yielded Promises are not
            // thrown back into the generator function, as is the case
            // when an awaited Promise is rejected. This difference in
            // behavior between yield and await is important, because it
            // allows the consumer to decide what to do with the yielded
            // rejection (swallow it and continue, manually .throw it back
            // into the generator, abandon iteration, whatever). With
            // await, by contrast, there is no opportunity to examine the
            // rejection reason outside the generator function, so the
            // only option is to throw it from the await expression, and
            // let the generator function handle the exception.
            result.value = unwrapped;
            resolve(result);
          }, reject);
        }
      }
  
      var previousPromise;
  
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new Promise(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
  
        return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }
  
      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }
  
    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };
    runtime.AsyncIterator = AsyncIterator;
  
    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    runtime.async = function(innerFn, outerFn, self, tryLocsList) {
      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList)
      );
  
      return runtime.isGeneratorFunction(outerFn)
        ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };
  
    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
  
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
  
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
  
          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }
  
        context.method = method;
        context.arg = arg;
  
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
  
          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
  
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
  
            context.dispatchException(context.arg);
  
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
  
          state = GenStateExecuting;
  
          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;
  
            if (record.arg === ContinueSentinel) {
              continue;
            }
  
            return {
              value: record.arg,
              done: context.done
            };
  
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }
  
    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;
  
        if (context.method === "throw") {
          if (delegate.iterator.return) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined;
            maybeInvokeDelegate(delegate, context);
  
            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }
  
          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }
  
        return ContinueSentinel;
      }
  
      var record = tryCatch(method, delegate.iterator, context.arg);
  
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
  
      var info = record.arg;
  
      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
  
      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;
  
        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;
  
        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined;
        }
  
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }
  
      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }
  
    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);
  
    Gp[toStringTagSymbol] = "Generator";
  
    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function() {
      return this;
    };
  
    Gp.toString = function() {
      return "[object Generator]";
    };
  
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
  
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
  
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
  
      this.tryEntries.push(entry);
    }
  
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
  
    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
  
    runtime.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();
  
      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }
  
        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };
  
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
  
        if (typeof iterable.next === "function") {
          return iterable;
        }
  
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }
  
            next.value = undefined;
            next.done = true;
  
            return next;
          };
  
          return next.next = next;
        }
      }
  
      // Return an iterator with no values.
      return { next: doneResult };
    }
    runtime.values = values;
  
    function doneResult() {
      return { value: undefined, done: true };
    }
  
    Context.prototype = {
      constructor: Context,
  
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined;
        this.done = false;
        this.delegate = null;
  
        this.method = "next";
        this.arg = undefined;
  
        this.tryEntries.forEach(resetTryEntry);
  
        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined;
            }
          }
        }
      },
  
      stop: function() {
        this.done = true;
  
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
  
        return this.rval;
      },
  
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
  
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
  
          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined;
          }
  
          return !! caught;
        }
  
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;
  
          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }
  
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");
  
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
  
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
  
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
  
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
  
      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
  
        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }
  
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
  
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
  
        return this.complete(record);
      },
  
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
  
        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
  
        return ContinueSentinel;
      },
  
      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
  
      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
  
        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },
  
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };
  
        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined;
        }
  
        return ContinueSentinel;
      }
    };
  })(
    // In sloppy mode, unbound `this` refers to the global object, fallback to
    // Function constructor if we're in global strict mode. That is sadly a form
    // of indirect eval which violates Content Security Policy.
    (function() { return this })() || Function("return this")()
  );
  
  
  /***/ }),
  
  /***/ "./node_modules/webpack/buildin/global.js":
  /*!***********************************!*\
    !*** (webpack)/buildin/global.js ***!
    \***********************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  var g;
  
  // This works in non-strict mode
  g = (function() {
      return this;
  })();
  
  try {
      // This works if eval is allowed (see CSP)
      g = g || Function("return this")() || (1, eval)("this");
  } catch (e) {
      // This works if the window reference is available
      if (typeof window === "object") g = window;
  }
  
  // g can still be undefined, but nothing to do about it...
  // We return undefined, instead of nothing here, so it's
  // easier to handle this case. if(!global) { ...}
  
  module.exports = g;
  
  
  /***/ }),
  
  /***/ "./node_modules/webpack/buildin/module.js":
  /*!***********************************!*\
    !*** (webpack)/buildin/module.js ***!
    \***********************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  module.exports = function(module) {
      if (!module.webpackPolyfill) {
          module.deprecate = function() {};
          module.paths = [];
          // module.parent = undefined by default
          if (!module.children) module.children = [];
          Object.defineProperty(module, "loaded", {
              enumerable: true,
              get: function() {
                  return module.l;
              }
          });
          Object.defineProperty(module, "id", {
              enumerable: true,
              get: function() {
                  return module.i;
              }
          });
          module.webpackPolyfill = 1;
      }
      return module;
  };
  
  
  /***/ }),
  
  /***/ "./src/main/webapp/components/DxAccordion/js/DxAccordion.js":
  /*!******************************************************************!*\
    !*** ./src/main/webapp/components/DxAccordion/js/DxAccordion.js ***!
    \******************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
  
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  
  var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
  
  var _createClass3 = _interopRequireDefault(_createClass2);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var DxAccordion = function () {
    function DxAccordion(el) {
      var _this = this;
  
      (0, _classCallCheck3.default)(this, DxAccordion);
  
      this.element = el;
      this.allowMultiple = el.hasAttribute('data-allow-multiple');
      this.sections = el.querySelectorAll('.dxAccordion__section');
  
      this.openAccordion(this.sections[0], 0);
  
      Array.prototype.forEach.call(this.sections, function (section, i) {
        var button = section.querySelector('.dxAccordion__trigger');
        button.addEventListener('click', function (e) {
          return _this.handleClick(e, section, i);
        });
      });
    }
  
    (0, _createClass3.default)(DxAccordion, [{
      key: 'handleClick',
      value: function handleClick(e, section, index) {
        if (section.classList.contains('dxAccordion__section--active')) {
          DxAccordion.closeAccordion(section);
        } else {
          this.openAccordion(section, index);
        }
      }
    }, {
      key: 'openAccordion',
      value: function openAccordion(section, index) {
        var button = section.querySelector('.dxAccordion__trigger');
        var panel = section.querySelector('.dxAccordion__panel');
  
        button.setAttribute('aria-expanded', 'true');
        panel.removeAttribute('hidden');
        section.classList.add('dxAccordion__section--active');
  
        if (!this.allowMultiple) {
          Array.prototype.forEach.call(this.sections, function (sect, i) {
            if (i !== index && sect.classList.contains('dxAccordion__section--active')) {
              DxAccordion.closeAccordion(sect);
            }
          });
        }
      }
    }], [{
      key: 'closeAccordion',
      value: function closeAccordion(section) {
        var button = section.querySelector('.dxAccordion__trigger');
        var panel = section.querySelector('.dxAccordion__panel');
  
        button.setAttribute('aria-expanded', 'false');
        panel.setAttribute('hidden', '');
        section.classList.remove('dxAccordion__section--active');
      }
    }]);
    return DxAccordion;
  }();
  
  exports.default = DxAccordion;
  
  /***/ }),
  
  /***/ "./src/main/webapp/components/DxDropdown/js/DxDropdown.js":
  /*!****************************************************************!*\
    !*** ./src/main/webapp/components/DxDropdown/js/DxDropdown.js ***!
    \****************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
  
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  
  var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
  
  var _createClass3 = _interopRequireDefault(_createClass2);
  
  var _aria = __webpack_require__(/*! ../../../resources/dev/js/utils/aria */ "./src/main/webapp/resources/dev/js/utils/aria.js");
  
  var _index = __webpack_require__(/*! ../../../resources/dev/js/utils/index */ "./src/main/webapp/resources/dev/js/utils/index.js");
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var DxDropdown = function () {
    function DxDropdown(el) {
      var _this = this;
  
      var preventDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      (0, _classCallCheck3.default)(this, DxDropdown);
  
      this.element = el;
      this.open = false;
      this.button = el.querySelector('.dxDropdown__button');
      this.listbox = el.querySelector('.dxDropdown__list');
  
      this.element.addEventListener('dxDropdown:Rebind', function () {
        return _this.rebindListBox();
      });
      this.element.addEventListener('click', function (e) {
        return _this.clickEventListeners(e, preventDefault);
      });
      this.button.addEventListener('keyup', function (e) {
        return _this.checkShow(e);
      });
      this.listbox.addEventListener('blur', function (e) {
        return _this.testBlur(e);
      });
      this.listbox.addEventListener('keydown', function (e) {
        return _this.keyDownEvents(e);
      });
  
      var firstItem = el.querySelector('.dxDropdown__list-item-link:not(.dxDropdown__list-item-link--disabled');
      this.addActiveDropdownItem(firstItem);
  
      window.addEventListener('click', function (e) {
        return _this.handleWindowClick(e);
      });
    }
  
    (0, _createClass3.default)(DxDropdown, [{
      key: 'testBlur',
      value: function testBlur(e) {
        if (!e.relatedTarget.classList.contains('dxDropdown__list-item') && !e.relatedTarget.classList.contains('dxDropdown__list-item-link')) {
          this.closeDropdown();
        }
      }
    }, {
      key: 'rebindListBox',
      value: function rebindListBox() {
        var _this2 = this;
  
        this.listbox = this.element.querySelector('.dxDropdown__list');
        this.listbox.addEventListener('blur', function (e) {
          return _this2.testBlur(e);
        });
        this.listbox.addEventListener('keydown', function (e) {
          return _this2.keyDownEvents(e);
        });
      }
    }, {
      key: 'handleWindowClick',
      value: function handleWindowClick(e) {
        var _this3 = this;
  
        var nodes = [];
        var el = e.target;
        var isDropdownEl = false;
  
        while (el.parentNode) {
          nodes.unshift(el.parentNode);
          el = el.parentNode;
        }
  
        nodes.forEach(function (node) {
          if (node.classList && node === _this3.element) {
            isDropdownEl = true;
          }
        });
  
        if (!isDropdownEl) {
          this.closeDropdown(false);
        }
      }
    }, {
      key: 'clickEventListeners',
      value: function clickEventListeners(e, preventDefault) {
        if (preventDefault) {
          e.preventDefault();
        }
        var el = e.target;
        if (el.classList.contains('dxDropdown__button')) {
          this.toggleDropdown();
        } else if (el.classList.contains('dxDropdown__list-item-link') && !el.classList.contains('dxDropdown__list-item-link--disabled')) {
          this.updateButtonText(e);
          this.closeDropdown();
        } else if (el.classList.contains('dxDropdown__list-item') && !el.querySelector('.dxDropdown__list-item-link').classList.contains('dxDropdown__list-item-link--disabled')) {
          var childLink = el.querySelector('.dxDropdown__list-item-link');
          this.updateButtonText(childLink);
          this.closeDropdown();
        }
      }
    }, {
      key: 'keyDownEvents',
      value: function keyDownEvents(e) {
        var key = e.which || e.keyCode;
        var DOWN = _aria.KeyCode.DOWN,
            UP = _aria.KeyCode.UP,
            ESC = _aria.KeyCode.ESC,
            RETURN = _aria.KeyCode.RETURN,
            TAB = _aria.KeyCode.TAB;
  
  
        switch (key) {
          case DOWN:
            e.preventDefault();
            this.nextItem(e);
            break;
          case TAB:
            e.preventDefault();
            if (e.shiftKey) {
              this.previousItem(e);
            } else {
              this.nextItem(e);
            }
            break;
          case UP:
            e.preventDefault();
            this.previousItem(e);
            break;
          case ESC:
            e.preventDefault();
            this.closeDropdown();
            break;
          case RETURN:
            e.preventDefault();
            this.updateButtonText(e);
            this.closeDropdown();
            break;
          default:
            break;
        }
      }
    }, {
      key: 'checkShow',
      value: function checkShow(e) {
        var key = e.which || e.keyCode;
        var UP = _aria.KeyCode.UP,
            DOWN = _aria.KeyCode.DOWN;
  
  
        switch (key) {
          case UP:
          case DOWN:
            e.preventDefault();
            this.openDropdown();
            break;
          default:
            break;
        }
      }
    }, {
      key: 'toggleDropdown',
      value: function toggleDropdown() {
        return this.open ? this.closeDropdown() : this.openDropdown();
      }
    }, {
      key: 'openDropdown',
      value: function openDropdown() {
        this.element.classList.add('dxDropdown--active');
        this.button.setAttribute('aria-expanded', 'true');
  
        this.focusFirstItem();
        this.open = true;
      }
    }, {
      key: 'closeDropdown',
      value: function closeDropdown() {
        var setFocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  
        this.element.classList.remove('dxDropdown--active');
        this.button.setAttribute('aria-expanded', 'false');
        this.open = false;
  
        if (setFocus) {
          this.button.focus();
        }
      }
    }, {
      key: 'updateButtonText',
      value: function updateButtonText(targetElement) {
        var target = targetElement.target ? targetElement.target : targetElement;
        this.button.innerHTML = target.innerHTML;
        this.fireEvent('DxDropdown:update', {
          target: target,
          value: this.button.innerHTML
        });
        this.addActiveDropdownItem(target);
      }
    }, {
      key: 'nextItem',
      value: function nextItem(e) {
        var _this4 = this;
  
        var itemList = this.listbox.querySelectorAll('.dxDropdown__list-item-link:not(.dxDropdown__list-item-link--disabled)');
  
        Array.prototype.forEach.call(itemList, function (el, i) {
          if (e.target === el) {
            if (i === itemList.length - 1) {
              _this4.focusFirstItem();
            } else {
              itemList[i + 1].focus();
            }
          }
        });
      }
    }, {
      key: 'previousItem',
      value: function previousItem(e) {
        var _this5 = this;
  
        var itemList = this.listbox.querySelectorAll('.dxDropdown__list-item-link:not(.dxDropdown__list-item-link--disabled)');
  
        Array.prototype.forEach.call(itemList, function (el, i) {
          if (e.target === el) {
            if (i === 0) {
              _this5.focusLastItem();
            } else {
              itemList[i - 1].focus();
            }
          }
        });
      }
    }, {
      key: 'focusFirstItem',
      value: function focusFirstItem() {
        var firstItem = this.listbox.querySelector('.dxDropdown__list-item-link:not(.dxDropdown__list-item-link--disabled)');
  
        firstItem.focus();
      }
    }, {
      key: 'focusLastItem',
      value: function focusLastItem() {
        var itemList = this.listbox.querySelectorAll('.dxDropdown__list-item-link:not(.dxDropdown__list-item-link--disabled)');
  
        if (itemList.length) {
          itemList[itemList.length - 1].focus();
        }
      }
    }, {
      key: 'addActiveDropdownItem',
      value: function addActiveDropdownItem(el) {
        var activeEl = this.element.querySelector('.dxDropdown__list-item-link--active:not(.dxDropdown__list-item-link--disabled)');
  
        if (activeEl !== null) {
          activeEl.classList.remove('dxDropdown__list-item-link--active');
        }
        el.classList.add('dxDropdown__list-item-link--active');
      }
    }, {
      key: 'fireEvent',
      value: function fireEvent(eventType) {
        var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  
        (0, _index.eventTrigger)(this.element, eventType, payload);
      }
    }, {
      key: 'getElement',
      value: function getElement() {
        return this.element;
      }
    }, {
      key: 'DxDropdown',
      value: function DxDropdown(method) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  
        var fn = this[method];
        return typeof fn === 'function' ? fn.bind(this, options)() : undefined;
      }
    }]);
    return DxDropdown;
  }();
  
  exports.default = DxDropdown;
  
  /***/ }),
  
  /***/ "./src/main/webapp/components/RulesEngineDropdown/js/CompatibilityChecker.js":
  /*!***********************************************************************************!*\
    !*** ./src/main/webapp/components/RulesEngineDropdown/js/CompatibilityChecker.js ***!
    \***********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = CompatibilityChecker;
  
  var _flatten2 = __webpack_require__(/*! lodash/flatten */ "./node_modules/lodash/flatten.js");
  
  var _flatten3 = _interopRequireDefault(_flatten2);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  /**
   * Build a list of items for a given dropdown.
   *
   * @param {string} featureName
   * @param {Array} currentUserValues - Currently selected user values.
   * @param {Array} features - List of features.
   * @return {Array} features
   */
  function CompatibilityChecker(featureName, currentUserValues, features) {
    var filteredFeatures = features.filter(function (feature) {
      var compatibility = feature.compatibility;
  
  
      if (!Array.isArray(compatibility)) {
        return true;
      }
  
      // Normalise Compatibility instructions
      var compatibilities = (0, _flatten3.default)(compatibility.map(function (_ref) {
        var refs = _ref.refs;
        return refs ? refs.split(' ') : [];
      }));
  
      var intersection = currentUserValues.filter(function (value) {
        return compatibilities.includes(value);
      });
  
      return intersection.length === currentUserValues.length;
    });
  
    if (featureName === 'specpack') {
      filteredFeatures = filteredFeatures.filter(function (feature) {
        return feature.availability !== 'excluded';
      });
    }
  
    return filteredFeatures;
  }
  
  /***/ }),
  
  /***/ "./src/main/webapp/components/RulesEngineDropdown/js/Queue.js":
  /*!********************************************************************!*\
    !*** ./src/main/webapp/components/RulesEngineDropdown/js/Queue.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");
  
  var _regenerator2 = _interopRequireDefault(_regenerator);
  
  var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");
  
  var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
  
  var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ "./node_modules/babel-runtime/helpers/toConsumableArray.js");
  
  var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
  
  exports.default = Queue;
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  /**
   * Callback to process an item in a Queue.
   *
   * @callback workCallback
   * @param {any} queuedItem - currently queued item in a provided items list.
   * @param {number} index - Index of Item.
   * @param {boolean} cancel - Queue cancellation status.
   */
  
  /**
   * Callback to fire when Queue is completed.
   *
   * @callback onCompleteCallback
   */
  
  /**
   * Vanilla Cancellable Queue implementation.
   *
   * @param {Object}              params
   * @param {Array.<any>}         params.items      The list of items to go through one by one.
   * @param {workCallback}        params.callback   The callback to process item.
   * @param {onCompleteCallback}  params.onComplete The callback to fire when Queue is finish process all items.
   */
  function Queue(_ref) {
    var _this = this;
  
    var items = _ref.items,
        callback = _ref.callback,
        onComplete = _ref.onComplete;
  
    var cancel = false;
  
    var queuedItems = [].concat((0, _toConsumableArray3.default)(items));
  
    var queueProcessor = function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var queuedItem;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!cancel) {
                  _context.next = 2;
                  break;
                }
  
                return _context.abrupt("return", false);
  
              case 2:
                if (!(queuedItems.length === 0)) {
                  _context.next = 5;
                  break;
                }
  
                if (onComplete) {
                  onComplete();
                }
  
                return _context.abrupt("return", true);
  
              case 5:
                queuedItem = queuedItems.shift();
  
                if (!callback) {
                  _context.next = 9;
                  break;
                }
  
                _context.next = 9;
                return callback(queuedItem, cancel);
  
              case 9:
                _context.next = 11;
                return queueProcessor();
  
              case 11:
                return _context.abrupt("return", true);
  
              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, _this);
      }));
  
      return function queueProcessor() {
        return _ref2.apply(this, arguments);
      };
    }();
  
    queueProcessor();
  
    return function () {
      cancel = true;
    };
  }
  
  /***/ }),
  
  /***/ "./src/main/webapp/components/RulesEngineDropdown/js/RulesEngineDropdown.js":
  /*!**********************************************************************************!*\
    !*** ./src/main/webapp/components/RulesEngineDropdown/js/RulesEngineDropdown.js ***!
    \**********************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ "./node_modules/babel-runtime/helpers/toConsumableArray.js");
  
  var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
  
  var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");
  
  var _regenerator2 = _interopRequireDefault(_regenerator);
  
  var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");
  
  var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
  
  var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
  
  var _promise2 = _interopRequireDefault(_promise);
  
  var _map = __webpack_require__(/*! babel-runtime/core-js/map */ "./node_modules/babel-runtime/core-js/map.js");
  
  var _map2 = _interopRequireDefault(_map);
  
  var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
  
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  
  var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
  
  var _createClass3 = _interopRequireDefault(_createClass2);
  
  var _rulesconnectjs = __webpack_require__(/*! @configureconnect/rulesconnectjs */ "./node_modules/@configureconnect/rulesconnectjs/es/index.js");
  
  var _get2 = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
  
  var _get3 = _interopRequireDefault(_get2);
  
  var _aria = __webpack_require__(/*! ../../../resources/dev/js/utils/aria */ "./src/main/webapp/resources/dev/js/utils/aria.js");
  
  var _DxDropdown = __webpack_require__(/*! ../../DxDropdown/js/DxDropdown */ "./src/main/webapp/components/DxDropdown/js/DxDropdown.js");
  
  var _DxDropdown2 = _interopRequireDefault(_DxDropdown);
  
  var _Queue = __webpack_require__(/*! ./Queue */ "./src/main/webapp/components/RulesEngineDropdown/js/Queue.js");
  
  var _Queue2 = _interopRequireDefault(_Queue);
  
  var _CompatibilityChecker = __webpack_require__(/*! ./CompatibilityChecker */ "./src/main/webapp/components/RulesEngineDropdown/js/CompatibilityChecker.js");
  
  var _CompatibilityChecker2 = _interopRequireDefault(_CompatibilityChecker);
  
  var _helpers = __webpack_require__(/*! ./helpers */ "./src/main/webapp/components/RulesEngineDropdown/js/helpers.js");
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var dxDropdownActiveClass = 'dxDropdown__list-item-link--active';
  
  var RulesEngineDropdown = function () {
    function RulesEngineDropdown(el) {
      var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  
      var _this = this;
  
      var lang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';
      var onFinish = arguments[3];
      (0, _classCallCheck3.default)(this, RulesEngineDropdown);
      this.iso2Lang = 'en';
      this.baseURL = '';
      this._supportedFeatureList = ['bodystyle', 'model', 'engine', 'specpack', 'product'];
      this._supportedFeatureElements = new _map2.default();
      this._suppressedViews = [];
      this._queue = null;
      this._rc = new _rulesconnectjs.RulesConnect();
  
      this.requestAndProcessDXDerivativesView = function (featureName) {
        var isCancelled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  
        return new _promise2.default(function () {
          var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(resolve, reject) {
            var data, activeFeatures, nextIndex, nextFeatureName, featuresList, featureGroup, dropdown, features, values, i, value;
            return _regenerator2.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!isCancelled) {
                      _context.next = 2;
                      break;
                    }
  
                    return _context.abrupt('return', resolve());
  
                  case 2:
                    _context.prev = 2;
                    _context.next = 5;
                    return _this._rc.loadJsonp(_this.buildRuleEngineUrl(featureName));
  
                  case 5:
                    data = _context.sent;
                    activeFeatures = _this.getActiveFeatures();
                    nextIndex = featureName ? activeFeatures.findIndex(function (f) {
                      return f === featureName;
                    }) + 1 : 0;
                    nextFeatureName = activeFeatures[nextIndex];
  
                    if (nextFeatureName) {
                      _context.next = 11;
                      break;
                    }
  
                    return _context.abrupt('return', resolve());
  
                  case 11:
                    featuresList = (0, _get3.default)(data, 'feature-dictionary.feature-list', []) || [];
                    featureGroup = featuresList.filter(function (feature) {
                      return feature.name.toLowerCase() === nextFeatureName;
                    }).shift();
  
                    if (!(!featureGroup || !Array.isArray(featureGroup.feature))) {
                      _context.next = 15;
                      break;
                    }
  
                    return _context.abrupt('return', resolve());
  
                  case 15:
                    dropdown = _this.getDropdown(nextFeatureName);
  
                    if (dropdown) {
                      _context.next = 18;
                      break;
                    }
  
                    return _context.abrupt('return', resolve());
  
                  case 18:
  
                    // Build Features for Dropdown
                    features = featureGroup.feature;
  
                    // Find users selection
  
                    values = [];
  
                    for (i = 0; i < nextIndex; i += 1) {
                      value = _this.getDropdownValue(activeFeatures[i]);
  
  
                      if (value) {
                        values.push(value);
                      }
                    }
  
                    // Filter By Compatibility
                    features = (0, _CompatibilityChecker2.default)(nextFeatureName, values, features);
  
                    features = features.map(function (feature) {
                      return {
                        id: feature.id,
                        description: feature.description[_this.iso2Lang] || feature.description.en || ''
                      };
                    });
  
                    _this.buildDropdown(nextFeatureName, dropdown, features);
                    _context.next = 29;
                    break;
  
                  case 26:
                    _context.prev = 26;
                    _context.t0 = _context['catch'](2);
                    return _context.abrupt('return', reject(_context.t0));
  
                  case 29:
                    return _context.abrupt('return', resolve());
  
                  case 30:
                  case 'end':
                    return _context.stop();
                }
              }
            }, _callee, _this, [[2, 26]]);
          }));
  
          return function (_x4, _x5) {
            return _ref.apply(this, arguments);
          };
        }());
      };
  
      this.onFinish = function () {
        var dropdownsContainer = _this.element.querySelector('.RulesEngineDropdown__dropdowns');
        dropdownsContainer.setAttribute('data-items', dropdownsContainer.children.length);
      };
  
      this.element = el;
  
      this.baseURL = baseUrl;
      this.iso2Lang = lang;
  
      this._setupFeaturesDOM();
  
      // Inform parent component that we are ready and all drop downs are filled.
      this.onChange(null, function () {
        _this.onFinish();
        onFinish();
      });
    }
  
    /** *
     * Fires when user select a new value from Rule Engine Dropdown and
     * chain the automatic selections to next dropdown by building the options from Rule Engine.
     *
     * @param {string} selectedFeature  Key/ID of feature dropdown
     * @param {Function} onComplete  Callback
     */
  
  
    // feature-dictionary.property.SuppressViews
    // Currently handled by Backend.
  
  
    (0, _createClass3.default)(RulesEngineDropdown, [{
      key: 'onChange',
      value: function onChange(selectedFeature, onComplete) {
        // Reset Existing Queue
        if (this._queue) {
          this._queue();
        }
  
        this._queue = (0, _Queue2.default)({
          items: this.getFeaturesToProcess(selectedFeature),
          callback: this.requestAndProcessDXDerivativesView,
          onComplete: onComplete
        });
      }
  
      /** *
       * Get dropdown by Feature Name.
       *
       * @param {string} featureName
       * @return {boolean|HTMLElement}
       */
  
    }, {
      key: 'getDropdown',
      value: function getDropdown(featureName) {
        if (!this._supportedFeatureElements.has(featureName)) {
          return false;
        }
  
        return this._supportedFeatureElements.get(featureName);
      }
  
      /** *
       * Get value of a dropdown by Feature Name.
       *
       * @param {string} featureName
       * @return {boolean|string}
       */
  
    }, {
      key: 'getDropdownValue',
      value: function getDropdownValue(featureName) {
        var dropdown = this.getDropdown(featureName);
  
        if (!dropdown) {
          return false;
        }
  
        return dropdown.getAttribute('data-id');
      }
  
      /**
       * Get all the available features for current nameplate.
       *
       * @param {string} selectedFeature
       */
  
    }, {
      key: 'getActiveFeatures',
      value: function getActiveFeatures(selectedFeature) {
        var _this2 = this;
  
        var searchIndex = this._supportedFeatureList.findIndex(function (f) {
          return f === selectedFeature;
        });
        var startingIndex = searchIndex === -1 ? 0 : searchIndex;
  
        var features = this._supportedFeatureList.slice(startingIndex);
  
        // ignore suppressed features
        features = features.filter(function (feature) {
          return !_this2._suppressedViews.includes(feature);
        });
  
        // ignore features which cannot be map to DOM
        features = features.filter(function (feature) {
          return _this2._supportedFeatureElements.has(feature);
        });
  
        return features;
      }
  
      /**
       * Get all features for Queue to process.
       *
       * It ensure to exclude last item from the Queue (e.g. Specpack), and also add first item for initial view.
       *
       * @param {string} selectedFeature
       */
  
    }, {
      key: 'getFeaturesToProcess',
      value: function getFeaturesToProcess(selectedFeature) {
        var features = this.getActiveFeatures(selectedFeature);
        features.pop();
  
        if (!selectedFeature) {
          return [null].concat((0, _toConsumableArray3.default)(features));
        }
  
        return features;
      }
  
      /**
       * Compose an absolute Rule Engine URL based on user selection for a given filter.
       *
       * @param {string} selectedFeature
       * @return {string}
       */
  
    }, {
      key: 'buildRuleEngineUrl',
      value: function buildRuleEngineUrl(selectedFeature) {
        var searchIndex = this._supportedFeatureList.findIndex(function (f) {
          return f === selectedFeature;
        });
        var values = [];
  
        for (var i = 0; i <= searchIndex; i += 1) {
          var value = this.getDropdownValue(this._supportedFeatureList[i]);
  
          if (value) {
            values.push(value);
          }
        }
  
        // TRIM slash at the end of the URL.
        if (this.baseURL.slice(-1) === '/') {
          this.baseURL = this.baseURL.replace(/\/+$/, '');
        }
  
        return this.baseURL + '/' + values.join('_') + '.jsonp?view=dx-derivatives';
      }
  
      /**
       * Compose a Rule Engine DX Derivatives View API call based on existing selections, build drop down and automatically
       * select first option.
       *
       * This method is part of Queue Service to ensure it can be discarded if user alter their linear journey.
       *
       * @param {string} featureName
       * @param {boolean} isCancelled - Queue cancellation status.
       * @return {Promise}
       */
  
    }, {
      key: 'buildDropdown',
  
  
      /**
       * Builds a DxDropdown based on Rule Engine Features.
       *
       * @param {string} featureName
       * @param {HTMLElement} dropdown
       * @param {Array} features - List of features.
       */
      value: function buildDropdown(featureName, dropdown, features) {
        var _this3 = this;
  
        // Setup List
        RulesEngineDropdown._setupDropdownList(dropdown, features);
  
        // Setup DxDropdown
        var dxDropdown = dropdown.querySelector('.dxDropdown');
        new _DxDropdown2.default(dxDropdown); // eslint-disable-line no-new
  
        // Setup Events
        var onUserChangeEvent = function onUserChangeEvent(evt) {
          var el = evt.target;
  
  
          if (el.classList.contains('dxDropdown__list-item-link')) {
            dropdown.setAttribute('data-id', el.getAttribute('data-id'));
            dropdown.setAttribute('data-title', el.innerHTML);
  
            _this3.onChange(featureName, null);
          }
        };
  
        dropdown.addEventListener('click', onUserChangeEvent);
  
        dropdown.addEventListener('keydown', function (evt) {
          var el = evt.target;
  
          var key = evt.which || evt.keyCode;
  
          // Prevent scrolling event on body
          if (el.tagName === 'BUTTON' && key !== _aria.KeyCode.TAB) {
            evt.preventDefault();
          }
  
          if (key === _aria.KeyCode.RETURN) {
            onUserChangeEvent(evt);
          }
        });
      }
  
      /** *
       * Cache Element by Feature names.
       *
       * @private
       */
  
    }, {
      key: '_setupFeaturesDOM',
      value: function _setupFeaturesDOM() {
        var _this4 = this;
  
        this._supportedFeatureElements = new _map2.default();
  
        this._supportedFeatureList.forEach(function (featureName) {
          var featureElem = document.querySelector('[data-feature="' + featureName + '"]');
  
          if (!featureElem || !(featureElem instanceof HTMLElement)) {
            return false;
          }
  
          _this4._supportedFeatureElements.set(featureName, featureElem);
  
          return true;
        });
      }
  
      /**
       * Build a list of items for a given dropdown.
       *
       * @param {HTMLElement} dropdown
       * @param {Array} features - List of features.
       * @private
       */
  
    }], [{
      key: '_setupDropdownList',
      value: function _setupDropdownList(dropdown, features) {
        var list = dropdown.querySelector('.RulesEngineDropdown__dropdown-list');
        var listItem = dropdown.querySelector('.RulesEngineDropdown__dropdown-item');
  
        list.innerHTML = '';
  
        features.forEach(function (item, index) {
          var id = item.id,
              description = item.description;
  
  
          var newItem = listItem.cloneNode(true);
          var itemLink = newItem.querySelector('.dxDropdown__list-item-link');
          itemLink.setAttribute('data-id', id);
          itemLink.innerHTML = (0, _helpers.buildEngineDropdownMarkup)(description);
  
          if (itemLink.classList.contains(dxDropdownActiveClass)) {
            itemLink.classList.remove(dxDropdownActiveClass);
          }
  
          list.appendChild(newItem);
  
          // Auto select first option
          if (index === 0) {
            dropdown.setAttribute('data-id', id);
            dropdown.setAttribute('data-title', description);
  
            var button = dropdown.querySelector('.RulesEngineDropdown__dropdown-button');
            button.innerHTML = (0, _helpers.buildEngineDropdownMarkup)(description);
          }
        });
      }
    }]);
    return RulesEngineDropdown;
  }();
  
  exports.default = RulesEngineDropdown;
  
  /***/ }),
  
  /***/ "./src/main/webapp/components/RulesEngineDropdown/js/helpers.js":
  /*!**********************************************************************!*\
    !*** ./src/main/webapp/components/RulesEngineDropdown/js/helpers.js ***!
    \**********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ "./node_modules/babel-runtime/helpers/slicedToArray.js");
  
  var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
  
  exports.buildEngineDropdownMarkup = buildEngineDropdownMarkup;
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var DELIMITER = '|';
  
  function buildEngineDropdownMarkup(text) {
    if (!text || text.indexOf(DELIMITER) === -1) {
      return text;
    }
  
    var _text$split = text.split(DELIMITER),
        _text$split2 = (0, _slicedToArray3.default)(_text$split, 2),
        engine = _text$split2[0],
        consumption = _text$split2[1];
  
    return '\n  <span class="RulesEngineDropdown__engine">\n    <span class="RulesEngineDropdown__engine-label">' + engine + '</span>\n    <span class="RulesEngineDropdown__engine-consumption">' + consumption + '</span>\n  </span>';
  }
  
  /***/ }),
  
  /***/ "./src/main/webapp/components/VehicleSpecsRulesEngine/js/VehicleSpecsRulesEngine.js":
  /*!******************************************************************************************!*\
    !*** ./src/main/webapp/components/VehicleSpecsRulesEngine/js/VehicleSpecsRulesEngine.js ***!
    \******************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VehicleSpecsRulesEngine = undefined;
  
  var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");
  
  var _regenerator2 = _interopRequireDefault(_regenerator);
  
  var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");
  
  var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
  
  var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
  
  var _promise2 = _interopRequireDefault(_promise);
  
  var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
  
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  
  var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
  
  var _createClass3 = _interopRequireDefault(_createClass2);
  
  var _get2 = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
  
  var _get3 = _interopRequireDefault(_get2);
  
  var _find3 = __webpack_require__(/*! lodash/find */ "./node_modules/lodash/find.js");
  
  var _find4 = _interopRequireDefault(_find3);
  
  var _RulesEngineDropdown = __webpack_require__(/*! ../../RulesEngineDropdown/js/RulesEngineDropdown */ "./src/main/webapp/components/RulesEngineDropdown/js/RulesEngineDropdown.js");
  
  var _RulesEngineDropdown2 = _interopRequireDefault(_RulesEngineDropdown);
  
  var _DxAccordion = __webpack_require__(/*! ../../DxAccordion/js/DxAccordion */ "./src/main/webapp/components/DxAccordion/js/DxAccordion.js");
  
  var _DxAccordion2 = _interopRequireDefault(_DxAccordion);
  
  var _techSpecs = __webpack_require__(/*! ../../../resources/dev/js/utils/techSpecs */ "./src/main/webapp/resources/dev/js/utils/techSpecs.js");
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var VehicleSpecsRulesEngine = exports.VehicleSpecsRulesEngine = function () {
    function VehicleSpecsRulesEngine(el) {
      (0, _classCallCheck3.default)(this, VehicleSpecsRulesEngine);
  
      this.element = el;
      this.dropdownSection = el.querySelector('.RulesEngineDropdown');
      this.specsSection = el.querySelector('.VehicleSpecsRulesEngine__specs');
      this.errorSection = el.querySelector('.VehicleSpecsRulesEngine__error');
      this.baseUrl = el.getAttribute('data-specs-url');
      this.lang = el.getAttribute('data-lang');
    }
  
    (0, _createClass3.default)(VehicleSpecsRulesEngine, [{
      key: 'init',
      value: function init() {
        var _this = this;
  
        return new _promise2.default(function (resolve) {
          var dropdownContainer = _this.dropdownSection.querySelector('.RulesEngineDropdown__dropdowns-container');
  
          if (dropdownContainer !== null) {
            var submitButton = _this.dropdownSection.querySelector('.RulesEngineDropdown__submit-button');
  
            // Wait for dropdown to finish before we can make a spec api call.
            _this.initDropdownSection().then(function () {
              var accordion = _this.specsSection.querySelector('.VehicleSpecsRulesEngine__specs-accordion');
              VehicleSpecsRulesEngine.initAccordion(accordion);
  
              _this.getData();
              submitButton.addEventListener('click', function () {
                return _this.getData();
              });
              VehicleSpecsRulesEngine.removeClass(_this.specsSection, 'VehicleSpecsRulesEngine__specs--hide');
  
              resolve();
            });
          } else {
            VehicleSpecsRulesEngine.removeClass(_this.errorSection, 'hidden');
            resolve();
          }
        });
      }
    }, {
      key: 'getData',
      value: function () {
        var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
          var bodystyleDropdown, modelDropdown, engineDropdown, specDropdown, bodystyle, model, engine, spec, url, cms, pricingUrl, productData, _find2, features, pricingData, specsData, specsFeature;
  
          return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  bodystyleDropdown = this.dropdownSection.querySelector('.RulesEngineDropdown__dropdown--bodystyle');
                  modelDropdown = this.dropdownSection.querySelector('.RulesEngineDropdown__dropdown--model');
                  engineDropdown = this.dropdownSection.querySelector('.RulesEngineDropdown__dropdown--engine');
                  specDropdown = this.dropdownSection.querySelector('.RulesEngineDropdown__dropdown--specpack');
  
  
                  this.setSpecsTitle(bodystyleDropdown, modelDropdown, engineDropdown, specDropdown);
  
                  bodystyle = bodystyleDropdown !== null ? bodystyleDropdown.getAttribute('data-id') + '_' : '';
                  model = modelDropdown !== null ? modelDropdown.getAttribute('data-id') + '_' : '';
                  engine = engineDropdown.getAttribute('data-id') + '_';
                  spec = specDropdown.getAttribute('data-id');
                  url = '' + this.baseUrl + bodystyle + model + engine + spec + '.jsonp?view=dx-specs';
                  cms = this.element.querySelector('#VehicleSpecsRulesEngineCms').innerHTML;
  
  
                  if (cms !== undefined && cms !== null && cms !== '') {
                    cms = JSON.parse(cms);
                  }
  
                  _context.prev = 12;
                  pricingUrl = '' + this.baseUrl + bodystyle + model + engine + spec + '.jsonp?view=dx-products';
                  _context.next = 16;
                  return (0, _techSpecs.apiCall)(pricingUrl);
  
                case 16:
                  productData = _context.sent;
                  _find2 = (0, _find4.default)((0, _get3.default)(productData, 'feature-dictionary.feature-list'), { name: 'PRODUCT' }), features = _find2.feature;
                  pricingData = features.filter(function (feature) {
                    return feature.availability === 'default' || feature.availability === 'selected';
                  });
                  _context.next = 21;
                  return (0, _techSpecs.apiCall)(url, cms);
  
                case 21:
                  specsData = _context.sent;
                  specsFeature = (0, _find4.default)((0, _get3.default)(specsData, 'feature-dictionary.feature-list'), { name: 'PRODUCT' });
  
                  specsFeature.feature = pricingData;
  
                  this.onSuccess(specsData, cms);
                  _context.next = 30;
                  break;
  
                case 27:
                  _context.prev = 27;
                  _context.t0 = _context['catch'](12);
  
                  this.onError();
  
                case 30:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this, [[12, 27]]);
        }));
  
        function getData() {
          return _ref.apply(this, arguments);
        }
  
        return getData;
      }()
    }, {
      key: 'onSuccess',
      value: function onSuccess(data, cms) {
        (0, _techSpecs.buildAccordion)(data, this.element, 'VehicleSpecsRulesEngine__specs-accordion', this.lang, cms, this.onPricingError.bind(this));
        VehicleSpecsRulesEngine.addClass(this.errorSection, 'hidden');
        this.showSpecs();
      }
    }, {
      key: 'onError',
      value: function onError() {
        VehicleSpecsRulesEngine.removeClass(this.errorSection, 'hidden');
        this.hideSpecs();
      }
    }, {
      key: 'onPricingError',
      value: function onPricingError(errMessage) {
        this.errorSection.setAttribute('data-error', errMessage);
      }
    }, {
      key: 'setSpecsTitle',
      value: function setSpecsTitle(bodystyle, model, engine, spec) {
        var bodystyleText = bodystyle !== null ? bodystyle.getAttribute('data-title') : '';
        var engineText = engine.getAttribute('data-title');
        var specText = spec.getAttribute('data-title');
  
        var specsTitleText = bodystyleText + ' | ' + specText;
        specsTitleText = VehicleSpecsRulesEngine.replaceAll(specsTitleText, '-', '&#8209;');
  
        var engineTitleText = VehicleSpecsRulesEngine.replaceAll(engineText, '-', '&#8209;');
  
        var specsTitle = this.element.querySelector('.VehicleSpecsRulesEngine__specs-title');
        specsTitle.innerHTML = this.hasMultipleBodyStyles() ? specsTitleText : specText;
  
        var engineTitle = this.element.querySelector('.VehicleSpecsRulesEngine__specs-engine');
        engineTitle.innerHTML = engineTitleText;
      }
    }, {
      key: 'hasMultipleBodyStyles',
      value: function hasMultipleBodyStyles() {
        var bodystyles = this.element.querySelector('.RulesEngineDropdown__dropdown--bodystyle');
  
        if (!bodystyles) {
          return false;
        }
  
        var items = bodystyles.querySelectorAll('.RulesEngineDropdown__dropdown-item');
  
        return items.length > 0;
      }
    }, {
      key: 'showSpecs',
      value: function showSpecs() {
        var els = this.specsSection.querySelectorAll('.hidden');
  
        if (els.length) {
          Array.prototype.forEach.call(els, function (el) {
            VehicleSpecsRulesEngine.removeClass(el, 'hidden');
          });
        }
      }
    }, {
      key: 'hideSpecs',
      value: function hideSpecs() {
        var elsToHide = this.specsSection.querySelectorAll('.VehicleSpecsRulesEngine__specs-heading, .VehicleSpecsRulesEngine__specs-accordion');
  
        Array.prototype.forEach.call(elsToHide, function (el) {
          VehicleSpecsRulesEngine.addClass(el, 'hidden');
        });
      }
    }, {
      key: 'initDropdownSection',
      value: function initDropdownSection() {
        var _this2 = this;
  
        return new _promise2.default(function (resolve) {
          return new _RulesEngineDropdown2.default(_this2.dropdownSection, _this2.baseUrl, _this2.lang, resolve);
        });
      }
    }], [{
      key: 'replaceAll',
      value: function replaceAll(string, search, replacement) {
        return string ? string.split(search).join(replacement) : '';
      }
    }, {
      key: 'initAccordion',
      value: function initAccordion(el) {
        return new _DxAccordion2.default(el);
      }
    }, {
      key: 'removeClass',
      value: function removeClass(el, className) {
        if (el.classList.contains(className)) {
          el.classList.remove(className);
        }
      }
    }, {
      key: 'addClass',
      value: function addClass(el, className) {
        if (!el.classList.contains(className)) {
          el.classList.add(className);
        }
      }
    }]);
    return VehicleSpecsRulesEngine;
  }();
  
  var VehicleSpecsRulesEngines = document.querySelectorAll('.cmp-vehicleSpecsRulesEngine');
  
  Array.prototype.forEach.call(VehicleSpecsRulesEngines, function (el) {
    var instance = new VehicleSpecsRulesEngine(el);
    instance.init();
  
    return instance;
  });
  
  /***/ }),
  
  /***/ "./src/main/webapp/resources/dev/js/utils/aria.js":
  /*!********************************************************!*\
    !*** ./src/main/webapp/resources/dev/js/utils/aria.js ***!
    \********************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var KeyCode = exports.KeyCode = {
    BACKSPACE: 8,
    DELETE: 46,
    DOWN: 40,
    END: 35,
    ESC: 27,
    HOME: 36,
    LEFT: 37,
    PAGE_DOWN: 34,
    PAGE_UP: 33,
    RETURN: 13,
    RIGHT: 39,
    SPACE: 32,
    TAB: 9,
    UP: 38
  };
  
  /***/ }),
  
  /***/ "./src/main/webapp/resources/dev/js/utils/browserDetection.js":
  /*!********************************************************************!*\
    !*** ./src/main/webapp/resources/dev/js/utils/browserDetection.js ***!
    \********************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports) {
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var breakpoints = exports.breakpoints = {
    small: 740,
    medium: 900,
    wider: 1000,
    current: null
  };
  
  var getDeviceOrientation = exports.getDeviceOrientation = function getDeviceOrientation() {
    var $window = $(window);
    return $window.width() > $window.height() ? 'landscape' : 'portrait';
  };
  
  var getLargerBreakpoint = function getLargerBreakpoint(width) {
    return width <= breakpoints.medium ? 'medium' : 'large';
  };
  
  var getBreakpointSize = exports.getBreakpointSize = function getBreakpointSize() {
    var oldCalc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  
    var width = oldCalc ? $(window).width() : window.innerWidth;
    return width <= breakpoints.small ? 'small' : getLargerBreakpoint(width);
  };
  
  var isBreakpointSmall = exports.isBreakpointSmall = function isBreakpointSmall() {
    var oldCalc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  
    return getBreakpointSize(oldCalc) === 'small';
  };
  
  var isBreakpointMedium = exports.isBreakpointMedium = function isBreakpointMedium() {
    var oldCalc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  
    return getBreakpointSize(oldCalc) === 'medium';
  };
  
  var isMobileDevice = exports.isMobileDevice = function isMobileDevice() {
    return 'ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch || navigator.msMaxTouchPoints; // eslint-disable-line
  };
  
  var isNotMobileDevice = exports.isNotMobileDevice = function isNotMobileDevice() {
    return !isMobileDevice();
  };
  
  var isTabletDevice = exports.isTabletDevice = function isTabletDevice() {
    return (/(ipad|tablet|(android(?!.*mobile))|(windows(?!.*phone)(.*touch))|kindle|playbook|silk|(puffin(?!.*(IP|AP|WP))))/.test(navigator.userAgent.toLowerCase())
    );
  };
  
  var isIOS = exports.isIOS = function isIOS() {
    return (/(ipad|iphone|ipod)/i.test(navigator.userAgent.toLowerCase())
    );
  };
  
  var isNotIOS = exports.isNotIOS = function isNotIOS() {
    return !isIOS();
  };
  
  var isWindowsPhone = exports.isWindowsPhone = function isWindowsPhone() {
    return navigator.userAgent.toLowerCase().indexOf('windows phone') !== -1;
  };
  
  var getAndroidVersion = exports.getAndroidVersion = function getAndroidVersion() {
    var ua = navigator.userAgent;
  
    if (ua.indexOf('Android') >= 0) {
      return parseFloat(ua.slice(ua.indexOf('Android') + 8));
    }
  
    return false;
  };
  
  var getBrowserUserAgent = exports.getBrowserUserAgent = function getBrowserUserAgent() {
    var _navigator = navigator,
        userAgent = _navigator.userAgent;
  
    return userAgent;
  };
  
  var detectBrowsers = exports.detectBrowsers = function detectBrowsers() {
    var userAgent = getBrowserUserAgent();
    var browsers = {
      isChrome: userAgent.indexOf('Chrome') > -1,
      isMsEdge: userAgent.indexOf('Edge') > -1,
      isExplorer: userAgent.indexOf('MSIE') > -1 || userAgent.indexOf('Trident') > -1, // MSIE = IE10 and below, Trident = IE11
      isFirefox: userAgent.indexOf('Firefox') > -1,
      isSafari: userAgent.indexOf('Safari') > -1,
      isOpera: userAgent.toLowerCase().indexOf('op') > -1
    };
  
    if (browsers.isChrome && browsers.isSafari) {
      browsers.isSafari = false;
    }
  
    if (browsers.isChrome && browsers.isOpera) {
      browsers.isChrome = false;
    }
  
    return browsers;
  };
  
  var isIe = exports.isIe = function isIe() {
    return document.querySelector('html').classList.contains('ie');
  };
  
  var isMsEdge = exports.isMsEdge = function isMsEdge() {
    return detectBrowsers().isMsEdge;
  };
  
  var isIe11 = exports.isIe11 = function isIe11() {
    return !window.ActiveXObject && 'ActiveXObject' in window;
  };
  
  var getViewportSize = exports.getViewportSize = function getViewportSize() {
    var test = document.createElement('div');
  
    test.style.cssText = 'position: fixed;top: 0;left: 0;bottom: 0;right: 0;';
    document.documentElement.insertBefore(test, document.documentElement.firstChild);
  
    var dims = { width: test.offsetWidth, height: test.offsetHeight };
    document.documentElement.removeChild(test);
  
    return dims;
  };
  
  var scrollToElement = exports.scrollToElement = function scrollToElement(element, options, callback) {
    var $element = element instanceof jQuery ? element : $(element);
  
    // Options are optional
    var opts = options || {};
  
    // Set defaults
    opts = $.extend({
      adjustment: 0,
      ease: 'easeOutSine',
      duration: 800,
      container: $('body, html')
    }, opts);
  
    // Has an element been supplied?
    if ($element.length === 0) {
      return false;
    }
  
    // Scroll to the target element allowing for the utility menu
    opts.container.stop().animate({
      scrollTop: $element.offset().top - opts.adjustment
    }, opts.duration, opts.ease, function () {
      if (callback) {
        callback();
      }
    });
  
    // For unit tests
    return opts;
  };
  
  /**
   * Detect Modern Browser by availability of BigInt feature.
   *
   * @return {boolean}
   */
  var hasBigIntSupport = exports.hasBigIntSupport = function hasBigIntSupport() {
    return typeof BigInt === 'function';
  };
  
  /***/ }),
  
  /***/ "./src/main/webapp/resources/dev/js/utils/formatPrice.js":
  /*!***************************************************************!*\
    !*** ./src/main/webapp/resources/dev/js/utils/formatPrice.js ***!
    \***************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  
  var _rulesconnectjs = __webpack_require__(/*! @configureconnect/rulesconnectjs */ "./node_modules/@configureconnect/rulesconnectjs/es/index.js");
  
  exports.default = function (price, format) {
    var data = {
      metadata: {
        meta: {}
      }
    };
  
    if (format) {
      format = format.replace(/'?&nbsp;'?/g, ' '); // eslint-disable-line
    }
  
    data.metadata.meta['currency-format'] = format;
  
    var rc = new _rulesconnectjs.RulesConnect();
    rc.readCurrencyFormats(data);
    return rc.getFormattedPrice(price, format);
  };
  
  /***/ }),
  
  /***/ "./src/main/webapp/resources/dev/js/utils/index.js":
  /*!*********************************************************!*\
    !*** ./src/main/webapp/resources/dev/js/utils/index.js ***!
    \*********************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.preventActionOnDeepLink = exports.generateCurrentDate = exports.equaliseHeights = exports.addScriptForBazaarVoice = exports.localStorageAvailable = exports.addDxElementLoadingSpinner = exports.removeDxLoadingSpinner = exports.addDxLoadingSpinner = exports.DxRequestNextAnimationFrame = exports.dxSetTimeout = exports.replaceAll = exports.isEmpty = exports.tablistNavigation = exports.checkDefined = exports.isElementVerticallyScrollable = exports.randomiseElements = exports.convertElementCollectionToArray = exports.eventTrigger = exports.balanceElementHeight = exports.lockTabbables = exports.getTabbable = exports.isLandRover = exports.scrollIfNotInViewport = exports.isInViewport = exports.template = exports.getTransitionEndEvent = exports.measureTextWidth = exports.throttle = exports.loadIgnoredResponsiveImages = exports.limitNumber = exports.enableScroll = exports.disableScroll = exports.getEasingValue = exports.getRandomString = exports.elementInViewport = exports.isPageInXPMFrame = exports.hasPlaceholderSupport = exports.canvasDrawBgCover = exports.getObjectKeys = exports.addParameterToURL = exports.getUrlParameter = exports.removeHTMLTags = exports.mobileAccordionsActivated = exports.insideTabbedContainer = exports.isPageInIframe = exports.checkDeepLink = exports.scrollTo = exports.getStickyNavHeightV2 = exports.getStickyNavHeight = exports.getHeight = exports.getCachedScript = exports.isRtl = exports.googleMapStyles = exports.stickyNavigationTransitionPoint = exports.stickyNavigationEnabled = undefined;
  
  var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ "./node_modules/babel-runtime/helpers/toConsumableArray.js");
  
  var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
  
  var _from = __webpack_require__(/*! babel-runtime/core-js/array/from */ "./node_modules/babel-runtime/core-js/array/from.js");
  
  var _from2 = _interopRequireDefault(_from);
  
  var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");
  
  var _typeof3 = _interopRequireDefault(_typeof2);
  
  var _arguments = arguments; /* global appReadyTimer */
  
  var _browserDetection = __webpack_require__(/*! ./browserDetection */ "./src/main/webapp/resources/dev/js/utils/browserDetection.js");
  
  var _aria = __webpack_require__(/*! ./aria */ "./src/main/webapp/resources/dev/js/utils/aria.js");
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var $navHeader = $('#header, .dxnav-header');
  var stickyNavigationEnabled = exports.stickyNavigationEnabled = $navHeader.attr('data-nav-type') === 'sticky';
  var stickyNavigationTransitionPoint = exports.stickyNavigationTransitionPoint = 200;
  var templateCache = {};
  
  var googleMapStyles = exports.googleMapStyles = [{
    featureType: 'administrative.locality',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#666666'
    }]
  }, {
    featureType: 'landscape.man_made',
    elementType: 'geometry.fill',
    stylers: [{
      color: '#f8f6f4'
    }]
  }, {
    featureType: 'poi',
    elementType: 'labels',
    stylers: [{
      visibility: 'off'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'geometry.fill',
    stylers: [{
      color: '#afaba4'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'geometry.stroke',
    stylers: [{
      color: '#e6e6e6'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'labels',
    stylers: [{
      saturation: -15
    }]
  }, {
    featureType: 'road.highway.controlled_access',
    elementType: 'geometry.fill',
    stylers: [{
      color: '#afaba4'
    }]
  }, {
    featureType: 'road.highway.controlled_access',
    elementType: 'labels.icon',
    stylers: [{
      saturation: -100
    }]
  }, {
    featureType: 'road.local',
    elementType: 'geometry.fill',
    stylers: [{
      color: '#ffffff'
    }]
  }, {
    featureType: 'road.local',
    elementType: 'labels.icon',
    stylers: [{
      saturation: '77'
    }]
  }, {
    featureType: 'transit',
    elementType: 'labels.icon',
    stylers: [{
      saturation: '-100'
    }]
  }, {
    featureType: 'water',
    elementType: 'geometry.fill',
    stylers: [{
      color: '#c5d7de'
    }, {
      lightness: -9
    }]
  }];
  
  var isRtl = exports.isRtl = function isRtl() {
    var html = document.getElementsByTagName('html')[0];
    return html.classList.contains('rtl');
  };
  
  var getCachedScript = exports.getCachedScript = function getCachedScript(url, options) {
    var newOptions = $.extend(options || {}, {
      dataType: 'script',
      cache: true,
      url: url
    });
  
    return $.ajax(newOptions);
  };
  
  var getHeight = exports.getHeight = function getHeight(elem) {
    return elem ? elem.clientHeight : 0;
  };
  
  // make sure to pass 'oldCalculation = false' to use the new refined calculation
  // or use getStickyNavHeightV2()
  var getStickyNavHeight = exports.getStickyNavHeight = function getStickyNavHeight(yPos) {
    var oldCalculation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  
    var yPosition = typeof yPos !== 'number' ? 0 : yPos;
    var sharedHeader = $('.dxnav-header');
    var $header = sharedHeader.length ? sharedHeader : $('#header');
    var $inPageNav = $('.InPageNavigation');
    var $inPageNavSticky = $('.InPageNavigation--sticky');
    var $inPageNavBar = $('.InPageNavigation__bar');
    var dxNavPrimary = document.querySelector('.dxnav__primary');
    var breakpoint = (0, _browserDetection.getBreakpointSize)();
    var checkStickyNav = $header.length > 0 ? $header.css('position') === 'fixed' : false;
    var inPageNavTop = $inPageNav.length > 0 ? $inPageNav.offset().top : null;
    var isStickyNav = sharedHeader.length ? true : checkStickyNav;
    var height = 0;
  
    if (!isStickyNav) {
      return height;
    }
  
    // hard coding values here to prevent having to repeatedly clone and measure the header
    var oldNavBreakpoint = 960;
  
    // added $inPageNav.css('display') check for LRA-10851
    if (inPageNavTop !== null && yPosition >= inPageNavTop && breakpoint === 'large' && $inPageNav.css('display') !== 'none') {
      return $inPageNav.outerHeight();
    }
  
    var windowWidth = window.innerWidth;
  
    // this is the old navigation, only shown when NaaS is down, hard coding values to prevent having to clone/measure the DOM elements for performance reasons
    var getNavigationHeight = function getNavigationHeight() {
      if (windowWidth >= oldNavBreakpoint && yPosition < 200) {
        return 106;
      }
      return 50;
    };
  
    var getNaaSHeight = function getNaaSHeight(old) {
      var primaryNavHeight = void 0;
  
      if (old) {
        primaryNavHeight = getHeight(dxNavPrimary);
      } else {
        primaryNavHeight = document.querySelector('.dxnav-scrollDown') === null && !$inPageNavSticky.length ? getHeight(dxNavPrimary) + parseInt(sharedHeader.css('top'), 10) : 0;
      }
  
      var breadcrumbNavHeight = getHeight(document.querySelector('.dxnav__breadcrumbs-container'));
      var notificationHeight = getHeight(document.querySelector('.notificationBarsWrapper'));
      var inPageNavigationHeight = 0;
      if ($inPageNav.length) {
        if ($inPageNavSticky.length) {
          breadcrumbNavHeight = 0;
          if (parseInt($inPageNavBar.css('top'), 10) === 0) {
            inPageNavigationHeight = $inPageNav.innerHeight();
          }
          if (parseInt($inPageNavBar.css('top'), 10) < 0) {
            inPageNavigationHeight = Math.max($inPageNav.outerHeight() + parseInt($inPageNavBar.css('top'), 10), 0);
          }
        }
      }
      return primaryNavHeight + breadcrumbNavHeight + notificationHeight + (old ? 0 : inPageNavigationHeight);
    };
  
    if (sharedHeader.length) {
      height = getNaaSHeight(oldCalculation);
    } else {
      height = getNavigationHeight();
    }
  
    return height;
  };
  
  // should be used until merged with getNavigationHeight
  var getStickyNavHeightV2 = exports.getStickyNavHeightV2 = function getStickyNavHeightV2(yPos) {
    return getStickyNavHeight(yPos, false);
  };
  
  var scrollTo = exports.scrollTo = function scrollTo(target, duration, callback, easing, ignoreStickyNav) {
    var yOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  
    var newDuration = typeof duration !== 'number' ? 800 : duration;
    var newCallback = typeof callback !== 'function' ? null : callback;
    var newEasing = typeof easing !== 'string' ? 'easeOutSine' : easing;
    var position = 0;
  
    if (typeof target === 'number') {
      // Px value
      position = target;
    } else {
      // Element
      var $targetEl = target || $('body');
      position = $targetEl.offset().top;
    }
  
    if (ignoreStickyNav !== true) {
      position -= getStickyNavHeight(position);
    }
  
    $('html, body').stop().animate({ scrollTop: position + yOffset }, newDuration, newEasing).promise().done(newCallback);
  };
  
  var checkDeepLink = exports.checkDeepLink = function checkDeepLink(href) {
    var deepLink = false;
    var speed = 2.5;
  
    var hashPos = href.indexOf('#');
    if (hashPos + 1 < href.length && hashPos !== -1) {
      var id = href.substring(hashPos, href.length);
      if ($(id).length === 1) {
        var location = $(id);
        var duration = location.offset().top / speed;
  
        // LRA-13794 | AccordionContainer | Open accordion first if deeplink is inside
        if ($('head [name="accordionOnMobile"]').length && (0, _browserDetection.isBreakpointSmall)()) {
          var accordionParent = location.closest('.accordion-group');
          var accordionTitle = accordionParent.find('.accordion-group-title');
  
          if (accordionParent.length && accordionTitle.length) {
            // Open accordion if closed
            if (!accordionParent.hasClass('open')) {
              accordionTitle.click();
            }
  
            // Take into account the height of the accordion title
            location = location.offset().top - accordionTitle.outerHeight();
  
            scrollTo(location, 800, null, 'easeOutSine');
            deepLink = true;
            return;
          }
        }
  
        if (location.parents('.TabbedContainer').length) {
          var $container = location.closest('.TabbedContainer');
          var $tabs = $container.find('.tab');
          var $tabLinks = $container.find('.tab-link');
          var tabIndex = 0;
  
          $tabs.each(function (i, el) {
            var $location = $(el).find(location);
            if ($location.length) {
              tabIndex = i;
            }
          });
  
          $tabLinks.each(function (i, el) {
            if (i === tabIndex) {
              $(el).click();
            }
          });
  
          location = $container.offset().top;
          duration = location / speed;
  
          scrollTo(location, 800, null, 'easeStartFastEndSlow');
          return true; // eslint-disable-line
        }
  
        // LRA-12701 | L462 Test | Open accordion first if deeplink is inside
        if ($('body').hasClass('vehiclesDiscovery')) {
          var _accordionParent = location.parents('.AccordionContainer');
          var element = $(location);
  
          if (_accordionParent.length) {
            var accordionHeader = _accordionParent.find('.header');
  
            if (!accordionHeader.hasClass('accordion-open')) {
              accordionHeader.click();
            }
  
            if (accordionHeader.is(':visible')) {
              if (!location.is(':visible')) {
                element.css('display', 'block');
                location = location.offset().top - accordionHeader.outerHeight();
                element.css('display', '');
              } else {
                location = location.offset().top - accordionHeader.outerHeight();
              }
            }
          }
        }
  
        scrollTo(location, duration, null, 'easeStartFastEndSlow');
        deepLink = true;
      } else {
        // eslint-disable-next-line no-console
        console.error('Could not find deep link element with id: ' + id);
      }
    }
    return deepLink; // eslint-disable-line
  };
  
  var isPageInIframe = exports.isPageInIframe = function isPageInIframe() {
    return window.self !== window.top;
  };
  
  var insideTabbedContainer = exports.insideTabbedContainer = function insideTabbedContainer(el) {
    var isInsideTabbedContainer = !!el.parents('.TabbedContainer').not('[data-total="1"]').length;
  
    if (isInsideTabbedContainer) {
      return el.parents('.TabbedContainer');
    }
  
    return false;
  };
  
  var mobileAccordionsActivated = exports.mobileAccordionsActivated = function mobileAccordionsActivated() {
    return $('head [name="accordionOnMobile"]').length;
  };
  
  var removeHTMLTags = exports.removeHTMLTags = function removeHTMLTags(s) {
    return s.toString().replace(/[<>=;]/g, '');
  };
  
  var getUrlParameter = exports.getUrlParameter = function getUrlParameter(sParam) {
    function decode(s) {
      return decodeURIComponent((s || '').replace(/\+/g, ' '));
    }
  
    var sPageURL = window.location.search.substring(1);
    var sURLVariables = sPageURL.split('&');
  
    for (var i = 0; i < sURLVariables.length; i += 1) {
      var sParameterSplit = sURLVariables[i].split('=');
      if (decode(sParameterSplit[0]) === sParam) {
        return decode(sParameterSplit[1]);
      }
    }
  
    return null;
  };
  
  var addParameterToURL = exports.addParameterToURL = function addParameterToURL(url, param) {
    var newUrl = url + (url.split('?')[1] ? '&' : '?') + param;
  
    return param !== '' ? newUrl : url;
  };
  
  var getObjectKeys = exports.getObjectKeys = function getObjectKeys(obj) {
    var keys = [];
    for (var i in obj) {
      //eslint-disable-line
      if (obj.hasOwnProperty(i)) {
        // eslint-disable-line
        keys.push(i);
      }
    }
    return keys;
  };
  
  /* eslint-disable */
  var canvasDrawBgCover = exports.canvasDrawBgCover = function canvasDrawBgCover(ctx, img, x, y, w, h, offsetX, offsetY) {
    if (_arguments.length === 2) {
      x = y = 0;
      w = ctx.canvas.width;
      h = ctx.canvas.height;
    }
  
    // default offset is center
    offsetX = typeof offsetX === 'number' ? offsetX : 0.5;
    offsetY = typeof offsetY === 'number' ? offsetY : 0.5;
  
    // keep bounds [0.0, 1.0]
    if (offsetX < 0) {
      offsetX = 0;
    }
    if (offsetY < 0) {
      offsetY = 0;
    }
    if (offsetX > 1) {
      offsetX = 1;
    }
    if (offsetY > 1) {
      offsetY = 1;
    }
  
    var iw = img.width,
        ih = img.height,
        r = Math.min(w / iw, h / ih),
        nw = iw * r,
        // new prop. width
    nh = ih * r,
        // new prop. height
    cx,
        cy,
        cw,
        ch,
        ar = 1;
  
    // decide which gap to fill
    if (nw < w) {
      ar = w / nw;
    }
    if (nh < h) {
      ar = h / nh;
    }
    nw *= ar;
    nh *= ar;
  
    // calc source rectangle
    cw = iw / (nw / w);
    ch = ih / (nh / h);
  
    cx = (iw - cw) * offsetX;
    cy = (ih - ch) * offsetY;
  
    // make sure source rectangle is valid
    if (cx < 0) {
      cx = 0;
    }
    if (cy < 0) {
      cy = 0;
    }
    if (cw > iw) {
      cw = iw;
    }
    if (ch > ih) {
      ch = ih;
    }
  
    // fill image in dest. rectangle
    ctx.drawImage(img, cx, cy, cw, ch, x, y, w, h);
  };
  /* eslint-enable */
  
  var hasPlaceholderSupport = exports.hasPlaceholderSupport = function hasPlaceholderSupport() {
    var el = document.createElement('input');
    return 'placeholder' in el;
  };
  
  var isPageInXPMFrame = exports.isPageInXPMFrame = function isPageInXPMFrame() {
    return typeof window.Tridion !== 'undefined' && typeof window.Tridion.Web.UI.SiteEdit !== 'undefined';
  };
  
  var elementInViewport = exports.elementInViewport = function elementInViewport(element, adjust, windowInnerHeight) {
    var $element = element instanceof jQuery ? element : $(element);
  
    if (!$element.length) {
      return false;
    }
  
    var $window = $(window);
    var scrollTop = $window.scrollTop();
    var windowHeight = $window.height();
    var adjustTop = void 0;
    var adjustBottom = void 0;
  
    // Element specifics
    var elOffset = $element.offset();
    var elTop = elOffset.top;
    var elBottom = elTop + $element.height();
  
    // Default value
    var defaultAdjust = (0, _browserDetection.getBreakpointSize)() === 'small' ? 20 : 50;
  
    // LRA-11494 Fix iOS issue with window height.
    // Temporarily add option to allow this so QA is not
    // required on StoryGallery + StoryArticleEnhancedImageBlock
    if (typeof windowInnerHeight !== 'undefined' && windowInnerHeight) {
      windowHeight = window.innerHeight ? window.innerHeight : windowHeight;
    }
  
    // Set viewportBottom
    var viewportBottom = scrollTop + windowHeight;
  
    // Allow adjust to be set different from top/bottom
    if ((typeof adjust === 'undefined' ? 'undefined' : (0, _typeof3.default)(adjust)) === 'object') {
      adjustTop = adjust.top;
      adjustBottom = adjust.bottom;
    } else {
      adjustTop = adjust || defaultAdjust;
      adjustBottom = adjust || defaultAdjust;
    }
  
    return !(viewportBottom < elTop + adjustTop || scrollTop > elBottom - adjustBottom);
  };
  
  var getRandomString = exports.getRandomString = function getRandomString(length) {
    var formattedLength = parseInt(length, 10) || 0;
    formattedLength = formattedLength < 0 ? 0 : formattedLength;
  
    var chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
    var chosen = [];
  
    for (var i = 0; i < formattedLength; i += 1) {
      chosen.push(chars.charAt(Math.floor(Math.random() * chars.length)));
    }
  
    return chosen.join('');
  };
  
  var getEasingValue = exports.getEasingValue = function getEasingValue(ratio) {
    var formattedRatio = ratio < 0 ? 0 : ratio;
    formattedRatio = formattedRatio > 1 ? 1 : formattedRatio;
  
    // Convert the ratio to a number of radians. 0 maps to -PI, 0.5 maps to
    // 0, 1 maps to PI
    var radians = formattedRatio * (2 * Math.PI) - Math.PI;
  
    // Convert this to a value using a cosine curve. Note that cosine gives
    // a value between -1 and 1, so we need to add 1 and divide by 2 to
    // keep it between 0 and 1
    return (Math.cos(radians) + 1) / 2;
  };
  
  var disableScroll = exports.disableScroll = function disableScroll() {
    var $window = $(window);
    var scrollTop = $window.scrollTop();
  
    $window.on('scroll.disableScroll mousewheel.disableScroll DOMMouseScroll.disableScroll touchmove.disableScroll', function (event) {
      event.preventDefault();
      $window.scrollTop(scrollTop);
    });
  };
  
  var enableScroll = exports.enableScroll = function enableScroll() {
    var $window = $(window);
  
    $window.off('scroll.disableScroll mousewheel.disableScroll DOMMouseScroll.disableScroll touchmove.disableScroll');
  };
  
  var limitNumber = exports.limitNumber = function limitNumber(value, min, max) {
    if (min > max) {
      var oldMin = min;
      min = max; // eslint-disable-line
      max = oldMin; // eslint-disable-line
    }
  
    return Math.max(min, Math.min(max, value));
  };
  
  var loadIgnoredResponsiveImages = exports.loadIgnoredResponsiveImages = function loadIgnoredResponsiveImages($images) {
    $images.removeAttr('data-picture-ignore');
    window.richsponsiveImage();
  };
  
  var throttle = exports.throttle = function throttle(fn, threshhold, scope) {
    var thresh = threshhold || 250;
    var last = void 0;
    var deferTimer = void 0;
  
    return function () {
      var context = scope || undefined;
  
      var now = +new Date();
      var args = _arguments;
      if (last && now < last + thresh) {
        // hold on to it
        clearTimeout(deferTimer);
        deferTimer = setTimeout(function () {
          last = now;
          fn.apply(context, args);
        }, thresh);
      } else {
        last = now;
        fn.apply(context, args);
      }
    };
  };
  
  /** *
   * Measure text width using Browser.
   *
   * @param text
   * @param parent
   * @return {number}
   * @deprecated Please use CMS Powered solution in future.
   */
  var measureTextWidth = exports.measureTextWidth = function measureTextWidth(text, parent) {
    if (!text) {
      return 0;
    }
  
    var par = parent || document.body;
    var container = document.createElement('div');
  
    container.style.position = 'absolute';
    container.style.visibility = 'hidden';
    container.style.height = 'auto';
    container.style.width = 'auto';
    container.style.padding = '0';
    container.style.whiteSpace = 'nowrap';
    container.innerHTML = text;
  
    par.appendChild(container);
    var width = container.clientWidth;
    par.removeChild(container);
  
    return width;
  };
  
  var getTransitionEndEvent = exports.getTransitionEndEvent = function getTransitionEndEvent() {
    var el = document.createElement('fakeelement');
    var transitions = {
      transition: 'transitionend',
      OTransition: ' oTransitionEnd',
      MozTransition: 'transitionend',
      WebkitTransition: 'webkitTransitionEnd'
    };
  
    for (var transition in transitions) {
      // eslint-disable-line
      if (el.style[transition] !== undefined) {
        return transitions[transition];
      }
    }
  
    return false;
  };
  
  /* eslint-disable */
  var template = exports.template = function template(str, data) {
    // Figure out if we're getting a template, or if we need to
    // load the template - and be sure to cache the result.
    var fn = !/\W/.test(str) ? templateCache[str] = templateCache[str] || template(document.getElementById(str).innerHTML) :
  
    // Generate a reusable function that will serve as a template
    // generator (and which will be cached).
    new Function("obj", "var p=[],print=function(){p.push.apply(p,arguments);};" +
  
    // Introduce the data as local variables using with(){}
    "with(obj){p.push('" +
  
    // Convert the template into pure JavaScript
    str.replace(/[\r\t\n]/g, " ").replace(/'(?=[^%]*%>)/g, "\t").split("'").join("\\'").split("\t").join("'").replace(/<%=(.+?)%>/g, "',$1,'").split("<%").join("');").split("%>").join("p.push('") + "');}return p.join('');");
  
    // Provide some basic currying to the user
    return data ? fn(data) : fn;
  };
  /* eslint-enable */
  
  var isInViewport = exports.isInViewport = function isInViewport(element) {
    var win = $(window);
  
    var viewport = {
      top: win.scrollTop() + getStickyNavHeight(),
      bottom: win.scrollTop() + win.height(),
      left: win.scrollLeft()
    };
    viewport.right = viewport.left + win.width();
  
    var bounds = element.offset();
    bounds.right = bounds.left + element.outerWidth();
    bounds.bottom = bounds.top + element.outerHeight();
  
    return !(viewport.right < bounds.left || viewport.left > bounds.right || viewport.bottom < bounds.top || viewport.top > bounds.bottom);
  };
  
  var scrollIfNotInViewport = exports.scrollIfNotInViewport = function scrollIfNotInViewport(element, displayToBottom) {
    if (!isInViewport(element)) {
      // Not in view
      var scrollToPos = displayToBottom ? element.offset().top - $(window).innerHeight() : element.offset().top - getStickyNavHeight();
      $('html,body').animate({ scrollTop: scrollToPos }, 800);
      return true;
    }
    return false;
  };
  
  var isLandRover = exports.isLandRover = function isLandRover() {
    return !!$('body#landrover').length;
  };
  
  var getTabbable = exports.getTabbable = function getTabbable(elem, customSelectors) {
    var defaultSelectors = ['input:not([disabled]):not([hidden])', 'select', 'a[href]', 'textarea', 'button', '[tabindex]:not([tabindex^="-"])'];
  
    var selectorTypes = customSelectors ? defaultSelectors.concat(customSelectors) : defaultSelectors;
    var selectors = elem.querySelectorAll(selectorTypes.join(','));
    selectors = (0, _from2.default)(selectors);
    selectors = selectors.filter(function (selector) {
      var tabbable = true;
      if (!selector.offsetParent || selector.offsetWidth === 0 || selector.offsetHeight === 0) {
        tabbable = false;
      }
  
      function isInvisible(el) {
        if (el.style.visibility === 'hidden' || el.style.display === 'none') {
          tabbable = false;
        } else if (el.parentNode && el.parentNode !== document.body) {
          isInvisible(el.parentNode);
        }
      }
      isInvisible(selector);
      if (tabbable) {
        return selector;
      }
      return false;
    });
    return selectors;
  };
  
  var lockTabbables = exports.lockTabbables = function lockTabbables(tabbables) {
    tabbables.forEach(function (el, i) {
      el.addEventListener('keydown', function (e) {
        if (e.keyCode !== _aria.KeyCode.TAB) {
          return;
        }
        e.preventDefault();
        if (i === 0) {
          if (tabbables.length === 1) {
            tabbables[0].focus();
          } else if (e.shiftKey) {
            tabbables[tabbables.length - 1].focus();
          } else {
            tabbables[i + 1].focus();
          }
        } else if (i === tabbables.length - 1 && !e.shiftKey) {
          tabbables[0].focus();
        } else if (e.shiftKey) {
          tabbables[i - 1].focus();
        } else {
          tabbables[i + 1].focus();
        }
      });
    });
  };
  
  var balanceElementHeight = exports.balanceElementHeight = function balanceElementHeight(elements) {
    var allowedOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  
    var columns = {};
    if (!elements) {
      return columns;
    }
    var elementsArray = [].slice.call(elements);
    var heightTotal = 0;
    var heightsArray = elementsArray.map(function (element) {
      var elementHeight = element.getBoundingClientRect().height;
      heightTotal += elementHeight;
      return elementHeight;
    });
    var getBalancedIndex = function getBalancedIndex(array, target) {
      var runningTotal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  
      var isRecursive = !!array[index] && runningTotal + array[index] <= target - allowedOffset;
      return isRecursive ? getBalancedIndex(array, target, runningTotal + array[index], index + 1) : index;
    };
    var splitIndex = getBalancedIndex(heightsArray, heightTotal / 2) + 1;
    columns.columns1 = elementsArray.slice(0, splitIndex);
    columns.columns2 = elementsArray.slice(splitIndex, elementsArray.length);
    columns.heightsArray = heightsArray;
    return columns;
  };
  
  var eventTrigger = exports.eventTrigger = function eventTrigger(elem, eventType) {
    var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var bubbles = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  
    var event = new CustomEvent(eventType, { detail: detail, bubbles: bubbles });
    elem.dispatchEvent(event);
  };
  
  var convertElementCollectionToArray = exports.convertElementCollectionToArray = function convertElementCollectionToArray(collection) {
    if (collection instanceof NodeList || collection instanceof jQuery) {
      return collection instanceof NodeList ? [].slice.call(collection) : collection.get();
    }
    return false;
  };
  
  var randomiseElements = exports.randomiseElements = function randomiseElements(elementsCollection) {
    var elements = convertElementCollectionToArray(elementsCollection);
    if (!elements || !elements.length) return;
    var clonedElements = elements.map(function (element) {
      return element.cloneNode(true);
    });
    clonedElements.sort(function () {
      return Math.random() - 0.5;
    });
    elements.forEach(function (element, inc) {
      return element.parentNode.replaceChild(clonedElements[inc], element);
    });
  };
  
  var isElementVerticallyScrollable = exports.isElementVerticallyScrollable = function isElementVerticallyScrollable(el) {
    return el && el.scrollHeight > el.offsetHeight;
  };
  
  var checkDefined = exports.checkDefined = function checkDefined(item) {
    return item !== undefined && item !== null;
  };
  
  var tablistNavigation = exports.tablistNavigation = function tablistNavigation(tablist) {
    var orientation = tablist.getAttribute('aria-orientation');
    var isVertical = orientation && orientation === 'vertical';
    var tabs = tablist.querySelectorAll('[role="tab"]');
    var keys = _aria.KeyCode;
  
    var focusFirstTab = function focusFirstTab() {
      return tabs[0].focus();
    };
    var focusLastTab = function focusLastTab() {
      return tabs[tabs.length - 1].focus();
    };
  
    var focusPreviousTab = function focusPreviousTab(currentTab) {
      var tabIndex = [].concat((0, _toConsumableArray3.default)(tabs)).findIndex(function (element) {
        return element === currentTab;
      });
      if (tabIndex === 0) {
        focusLastTab();
      } else {
        tabs[tabIndex - 1].focus();
      }
    };
  
    var focusNextTab = function focusNextTab(currentTab) {
      var tabIndex = [].concat((0, _toConsumableArray3.default)(tabs)).findIndex(function (element) {
        return element === currentTab;
      });
      var tabsLengthZeroIndex = tabs.length - 1;
      if (tabIndex === tabsLengthZeroIndex) {
        focusFirstTab();
      } else {
        tabs[tabIndex + 1].focus();
      }
    };
  
    var handleTablistKeydownEvents = function handleTablistKeydownEvents(event) {
      var key = event.keyCode;
      switch (key) {
        case keys.END:
          event.preventDefault();
          focusLastTab();
          break;
        case keys.HOME:
          event.preventDefault();
          focusFirstTab();
          break;
        case keys.LEFT:
        case keys.UP:
          if (isVertical) {
            event.preventDefault();
            focusPreviousTab(event.currentTarget);
          }
          break;
        case keys.RIGHT:
        case keys.DOWN:
          if (isVertical) {
            event.preventDefault();
            focusNextTab(event.currentTarget);
          }
          break;
        default:
          break;
      }
    };
  
    var handleTablistKeyupEvents = function handleTablistKeyupEvents(event) {
      var key = event.keyCode;
      switch (key) {
        case keys.LEFT:
          focusPreviousTab(event.currentTarget);
          break;
        case keys.RIGHT:
          focusNextTab(event.currentTarget);
          break;
        default:
          break;
      }
    };
  
    tabs.forEach(function (tab) {
      tab.addEventListener('keydown', handleTablistKeydownEvents, false);
      if (!isVertical) {
        tab.addEventListener('keyup', handleTablistKeyupEvents, false);
      }
    });
  };
  
  var isEmpty = exports.isEmpty = function isEmpty(obj) {
    for (var key in obj) {
      // eslint-disable-line
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return false;
      }
    }
    return true;
  };
  
  var replaceAll = exports.replaceAll = function replaceAll(string, search, replacement) {
    return string.split(search).join(replacement);
  };
  
  var dxSetTimeout = exports.dxSetTimeout = function dxSetTimeout(cb, time) {
    setTimeout(cb, time);
  
    if (window.appReadyEvent.initiated) {
      appReadyTimer.add(time);
    } else {
      window.appReadyEvent.timeout += time;
    }
  };
  
  var DxRequestNextAnimationFrame = exports.DxRequestNextAnimationFrame = function DxRequestNextAnimationFrame(cb) {
    requestAnimationFrame(function () {
      requestAnimationFrame(cb());
    });
  };
  
  var loadingSpinnerToggleButtonStateAndContent = function loadingSpinnerToggleButtonStateAndContent(target) {
    var targetElement = target;
  
    if (target.tagName === 'BUTTON') {
      targetElement.disabled = true;
    }
    targetElement.classList.add('loading');
  
    var children = targetElement.children;
  
    [].concat((0, _toConsumableArray3.default)(children)).forEach(function (child) {
      var element = child;
      element.style.opacity = 0;
    });
  };
  
  /**
   * addDxLoadingSpinner
   * @param {HTMLElement} target The button/link that the loading spinner should be inserted into
   */
  var addDxLoadingSpinner = exports.addDxLoadingSpinner = function addDxLoadingSpinner(target) {
    if (!target) {
      return;
    }
  
    var iconMarkup = '<div class="DxLoading" aria-hidden="true"><div class="DxLoading__icon" aria-expanded="true"></div></div>';
    var loadingIcon = document.createRange().createContextualFragment(iconMarkup);
  
    loadingSpinnerToggleButtonStateAndContent(target);
  
    target.appendChild(loadingIcon);
  };
  
  /**
   * removeDxLoadingSpinner
   * @param {HTMLElement} target The button/link that the loading spinner should be removed from
   * @param {string || HTMLElement} replace The string you would like to replace the loading spinner with (expected to be the text originally in the button)
   */
  var removeDxLoadingSpinner = exports.removeDxLoadingSpinner = function removeDxLoadingSpinner(target) {
    var targetElement = target;
  
    if (target.tagName === 'BUTTON') {
      targetElement.disabled = false;
    }
    targetElement.classList.remove('loading');
  
    var loadingIcon = targetElement.querySelector('.DxLoading');
    targetElement.removeChild(loadingIcon);
  
    var children = targetElement.children;
  
    [].concat((0, _toConsumableArray3.default)(children)).forEach(function (child) {
      var element = child;
      element.style.opacity = 1;
    });
  };
  
  var addDxElementLoadingSpinner = exports.addDxElementLoadingSpinner = function addDxElementLoadingSpinner(target) {
    if (!target) {
      return;
    }
  
    var iconMarkup = '<div class="DxLoading" aria-hidden="true">\n    <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 88 88" style="enable-background:new 0 0 88 88;" xml:space="preserve">\n    <path fill="#FFFFFF" style="opacity: .2;" d="M44,5c21.5,0,39,17.5,39,39S65.5,83,44,83S5,65.5,5,44S22.5,5,44,5 M44,0C19.7,0,0,19.7,0,44s19.7,44,44,44 s44-19.7,44-44S68.3,0,44,0L44,0z"/>\n    <path fill="#F0F0F0" d="M85.5,46.4c-1.4,0-2.5-1.1-2.5-2.5C83,22.5,65.5,5,44.1,5c-1.4,0-2.5-1.1-2.5-2.5S42.7,0,44.1,0 C68.3,0,88,19.7,88,43.9C88,45.3,86.9,46.4,85.5,46.4z">\n      <animateTransform attributeName="transform" type="rotate" from="0 44 44" to="360 44 44" dur="1.5s" repeatCount="indefinite"></animateTransform>\n    </path>\n    </svg>\n  </div>';
    var loadingIcon = document.createRange().createContextualFragment(iconMarkup);
  
    loadingSpinnerToggleButtonStateAndContent(target);
  
    target.appendChild(loadingIcon);
  };
  
  var localStorageAvailable = exports.localStorageAvailable = function localStorageAvailable() {
    try {
      if (typeof window.localStorage !== 'undefined') {
        try {
          window.localStorage.setItem('feature_test', 'yes');
          if (window.localStorage.getItem('feature_test') === 'yes') {
            window.localStorage.removeItem('feature_test');
            return true;
          }
          return false;
        } catch (e) {
          return false;
        }
      } else {
        return false;
      }
    } catch (e) {
      return false;
    }
  };
  
  var addScriptForBazaarVoice = exports.addScriptForBazaarVoice = function addScriptForBazaarVoice(scriptURL) {
    if (scriptURL.trim() !== '' && document.querySelectorAll('script[src=\'' + scriptURL + '\']').length === 0) {
      var bazaarVoiceScript = document.createElement('script');
      bazaarVoiceScript.setAttribute('src', scriptURL);
      document.head.appendChild(bazaarVoiceScript);
    }
  };
  
  var equaliseHeights = exports.equaliseHeights = function equaliseHeights(elements) {
    var maxHeight = 0;
    [].concat((0, _toConsumableArray3.default)(elements)).forEach(function (element) {
      // eslint-disable-next-line no-param-reassign
      element.style.height = 'auto';
    });
    [].concat((0, _toConsumableArray3.default)(elements)).forEach(function (element) {
      var height = element.offsetHeight;
      if (height > maxHeight) {
        maxHeight = height;
      }
    });
    [].concat((0, _toConsumableArray3.default)(elements)).forEach(function (element) {
      // eslint-disable-next-line no-param-reassign
      element.style.height = maxHeight + 'px';
    });
  };
  
  var generateCurrentDate = exports.generateCurrentDate = function generateCurrentDate() {
    var today = new Date();
    return Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate(), today.getUTCHours(), today.getUTCMinutes());
  };
  
  var preventActionOnDeepLink = exports.preventActionOnDeepLink = function preventActionOnDeepLink(event) {
    var linkLocation = event.currentTarget.getAttribute('href');
    if (checkDeepLink(linkLocation)) {
      event.preventDefault();
    }
  };
  
  /***/ }),
  
  /***/ "./src/main/webapp/resources/dev/js/utils/techSpecs.js":
  /*!*************************************************************!*\
    !*** ./src/main/webapp/resources/dev/js/utils/techSpecs.js ***!
    \*************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.apiCall = exports.buildAccordion = exports.tableTemplate = exports.suppressPricingIfZero = exports.addFallbackPrice = exports.hasNotFallbackPriceType = exports.hasFallbackPriceType = undefined;
  
  var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");
  
  var _assign2 = _interopRequireDefault(_assign);
  
  var _isNan = __webpack_require__(/*! babel-runtime/core-js/number/is-nan */ "./node_modules/babel-runtime/core-js/number/is-nan.js");
  
  var _isNan2 = _interopRequireDefault(_isNan);
  
  var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");
  
  var _keys2 = _interopRequireDefault(_keys);
  
  var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
  
  var _extends3 = _interopRequireDefault(_extends2);
  
  var _rulesconnectjs = __webpack_require__(/*! @configureconnect/rulesconnectjs */ "./node_modules/@configureconnect/rulesconnectjs/es/index.js");
  
  var _DxAccordion = __webpack_require__(/*! ../../../../components/DxAccordion/js/DxAccordion */ "./src/main/webapp/components/DxAccordion/js/DxAccordion.js");
  
  var _DxAccordion2 = _interopRequireDefault(_DxAccordion);
  
  var _index = __webpack_require__(/*! ./index */ "./src/main/webapp/resources/dev/js/utils/index.js");
  
  var _formatPrice = __webpack_require__(/*! ./formatPrice */ "./src/main/webapp/resources/dev/js/utils/formatPrice.js");
  
  var _formatPrice2 = _interopRequireDefault(_formatPrice);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  var hasFallbackPriceType = exports.hasFallbackPriceType = function hasFallbackPriceType() {
    var cmsSettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var currentPriceType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var defaultPricingTypeKey = cmsSettings.defaultPricingTypeKey,
        fallbackPricingTypeKey = cmsSettings.fallbackPricingTypeKey;
  
  
    if (!defaultPricingTypeKey || !fallbackPricingTypeKey) {
      return false;
    }
  
    return currentPriceType === defaultPricingTypeKey;
  };
  
  var hasNotFallbackPriceType = exports.hasNotFallbackPriceType = function hasNotFallbackPriceType(cmsSettings, currentPriceType) {
    return !hasFallbackPriceType(cmsSettings, currentPriceType);
  };
  
  /**
   * Add fallback price support fot Tech Specs Table
   *
   * If Author has specified fallback settings and default price type does not exists from response returned
   * from Rule Engine API, then copy the fallback price information into default and return them as a new object.
   *
   * @param {Object} cmsSettings
   * @return {Object}
   */
  var addFallbackPrice = exports.addFallbackPrice = function addFallbackPrice(cmsSettings) {
    var newSettings = (0, _extends3.default)({}, cmsSettings);
    var defaultPricingTypeKey = newSettings.defaultPricingTypeKey,
        fallbackPricingTypeKey = newSettings.fallbackPricingTypeKey,
        fallbackPricingTypeLabel = newSettings.fallbackPricingTypeLabel;
  
  
    if (!defaultPricingTypeKey || !fallbackPricingTypeKey) {
      return newSettings;
    }
  
    var price = newSettings['feature-list'][0].feature[0].price;
  
  
    if (price[defaultPricingTypeKey] && price[defaultPricingTypeKey].value > 0) {
      return newSettings;
    }
  
    newSettings['feature-list'][0].feature[0].price[defaultPricingTypeKey] = price[fallbackPricingTypeKey];
  
    // Find & Replace Price Label to fallback
    if (fallbackPricingTypeLabel && Array.isArray(newSettings.table)) {
      newSettings.table = newSettings.table.map(function (item) {
        var newItem = (0, _extends3.default)({}, item);
        if (newItem.key === defaultPricingTypeKey) {
          newItem.key = fallbackPricingTypeKey;
          newItem.text = fallbackPricingTypeLabel;
        }
  
        return newItem;
      });
    }
  
    return newSettings;
  };
  
  var suppressPricingIfZero = exports.suppressPricingIfZero = function suppressPricingIfZero(pricing) {
    if (!pricing) {
      return false;
    }
  
    if (!('feature-list' in pricing) || !Array.isArray(pricing['feature-list'])) {
      return false;
    }
  
    var featurePrices = pricing['feature-list'][0].feature[0].price;
  
    (0, _keys2.default)(featurePrices).forEach(function (priceType) {
      var value = parseFloat(featurePrices[priceType].value);
  
      if ((0, _isNan2.default)(value) || value <= 0) {
        if (hasNotFallbackPriceType(pricing, priceType)) {
          throw new Error('Nameplate contains a product with 0 price.');
        }
      }
    });
  
    return false;
  };
  
  var getText = function getText(obj, lang) {
    var keys = (0, _keys2.default)(obj);
    return keys.length === 1 ? obj[keys[0]] : obj[lang];
  };
  
  var tableTemplate = exports.tableTemplate = function tableTemplate(headings, data, lang) {
    var isPricing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var format = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
  
    var table = document.createElement('table');
    table.classList.add('TechSpecsTable');
  
    var caveatSection = document.createElement('div');
    caveatSection.classList.add('TechSpecsTable__caveats');
  
    Array.prototype.forEach.call(headings, function (heading, i) {
      var headingText = isPricing ? heading.text : getText(heading.description, lang);
      var priceCaveat = heading.caveat || '';
      var tdText = isPricing ? '' + (0, _formatPrice2.default)(data[heading.key].value, format) + priceCaveat : getText(data[i].description, lang);
  
      if ((0, _index.checkDefined)(headingText) && (0, _index.checkDefined)(tdText)) {
        var th = document.createElement('th');
        th.classList.add('TechSpecsTable__heading');
        th.setAttribute('scope', 'row');
        th.innerHTML = headingText;
  
        var td = document.createElement('td');
        td.classList.add('TechSpecsTable__cell');
        td.innerHTML = tdText;
  
        var row = document.createElement('tr');
        row.classList.add('TechSpecsTable__row');
        row.appendChild(th);
        row.appendChild(td);
  
        if (isPricing) {
          row.setAttribute('rule-engine-price-type', heading.key);
        }
  
        table.appendChild(row);
      } else if ((0, _index.checkDefined)(tdText)) {
        var caveatToAdd = document.createElement('p');
        caveatToAdd.classList.add('TechSpecsTable__caveat');
        caveatToAdd.innerHTML = tdText;
        caveatSection.appendChild(caveatToAdd);
      }
    });
  
    var dataSection = document.createElement('div');
    dataSection.classList.add('TechSpecsTable__container');
  
    dataSection.appendChild(table);
    dataSection.appendChild(caveatSection);
  
    return dataSection;
  };
  
  var accordionSectionTemplate = function accordionSectionTemplate(template, prefix, i) {
    var newSection = template.cloneNode(true);
    var button = newSection.querySelector('.dxAccordion__trigger');
    var panel = newSection.querySelector('.dxAccordion__panel');
    var panelId = prefix + '-panel--' + i;
    var buttonId = prefix + '-button--' + i;
  
    button.setAttribute('aria-controls', panelId);
    button.setAttribute('id', buttonId);
    panel.setAttribute('id', panelId);
    panel.setAttribute('aria-labelledby', buttonId);
  
    return newSection;
  };
  
  var accordionPricingSection = function accordionPricingSection(data, template, i, prefix, lang) {
    var newSection = accordionSectionTemplate(template, prefix, i);
    var accordionTitle = data.accordionTitle,
        table = data.table,
        format = data.format,
        caveat = data.caveat;
  
  
    var tableToAdd = tableTemplate(table, data['feature-list'][0].feature[0].price, lang, true, format, caveat);
  
    newSection.querySelector('.dxAccordion__title').innerHTML = accordionTitle;
    newSection.querySelector('.dxAccordion__panel').appendChild(tableToAdd);
  
    return newSection;
  };
  
  var buildAccordionSection = function buildAccordionSection(table, template, i, prefix, lang) {
    var section = accordionSectionTemplate(template, prefix, i);
    var datasets = table.datasets,
        labels = table.labels;
    var heading = labels.heading,
        label = labels.label;
  
    var tableToAdd = tableTemplate(label, datasets[0].data, lang);
  
    section.querySelector('.dxAccordion__title').innerHTML = getText(heading.description, lang);
    section.querySelector('.dxAccordion__panel').appendChild(tableToAdd);
  
    return section;
  };
  
  var buildAccordion = exports.buildAccordion = function buildAccordion(data, el, prefix, lang) {
    var cms = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    var onPricingError = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var specs = data.specs;
  
    var accordionContainer = el.querySelector('.dxAccordion');
    var accordionTemplate = accordionContainer.querySelector('.dxAccordion__section');
    var accordionPanel = accordionTemplate.querySelector('.dxAccordion__panel');
  
    while (accordionContainer.firstChild) {
      accordionContainer.removeChild(accordionContainer.firstChild);
    }
  
    while (accordionPanel.firstChild) {
      accordionPanel.removeChild(accordionPanel.firstChild);
    }
  
    var pricePanelPosition = parseInt(el.dataset.pricePanelPosition, 10);
    if ((0, _isNan2.default)(pricePanelPosition) || pricePanelPosition <= 1) {
      pricePanelPosition = 1;
    }
  
    var addPriceAccordionPanel = function addPriceAccordionPanel() {
      var featureDictionary = data['feature-dictionary'];
  
      if (!(0, _index.isEmpty)(featureDictionary) && !(0, _index.isEmpty)(cms)) {
        try {
          var pricing = (0, _assign2.default)(cms, data['feature-dictionary']);
  
          suppressPricingIfZero(pricing);
          accordionContainer.appendChild(accordionPricingSection(addFallbackPrice(pricing), accordionTemplate, 0, prefix, lang));
        } catch (err) {
          if (onPricingError) {
            if (err instanceof TypeError) {
              onPricingError('Component authored to show price BUT there is NO valid price for the derivatives chosen.');
            } else {
              onPricingError(err && err.message ? err.message : err.toString());
            }
          }
        }
      }
    };
  
    var count = 1;
    Array.prototype.forEach.call(specs, function (spec) {
      Array.prototype.forEach.call(spec.table, function (tab) {
        if (count === pricePanelPosition) {
          addPriceAccordionPanel();
        }
  
        accordionContainer.appendChild(buildAccordionSection(tab, accordionTemplate, count, prefix, lang));
  
        count += 1;
      });
    });
  
    return new _DxAccordion2.default(accordionContainer);
  };
  
  var rc = new _rulesconnectjs.RulesConnect();
  
  var apiCall = exports.apiCall = function apiCall(url) {
    return rc.loadJsonp(url);
  };
  
  /***/ })
  
  /******/ });
  //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bjb25maWd1cmVjb25uZWN0L3J1bGVzY29ubmVjdGpzL2VzL2RlY2ltYWxmb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bjb25maWd1cmVjb25uZWN0L3J1bGVzY29ubmVjdGpzL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AY29uZmlndXJlY29ubmVjdC9ydWxlc2Nvbm5lY3Rqcy9lcy9qc29ucC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNvbmZpZ3VyZWNvbm5lY3QvcnVsZXNjb25uZWN0anMvZXMvcG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNvbmZpZ3VyZWNvbm5lY3QvcnVsZXNjb25uZWN0anMvZXMvcmVzb3VyY2VidW5kbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bjb25maWd1cmVjb25uZWN0L3J1bGVzY29ubmVjdGpzL2VzL3J1bGVzY29ubmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL251bWJlci9pcy1uYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1uYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wZXJmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5tYXAuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm1hcC5vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlRmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEFycmF5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9GaW5pdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b0ludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluL3dlYmFwcC9jb21wb25lbnRzL0R4QWNjb3JkaW9uL2pzL0R4QWNjb3JkaW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluL3dlYmFwcC9jb21wb25lbnRzL0R4RHJvcGRvd24vanMvRHhEcm9wZG93bi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi93ZWJhcHAvY29tcG9uZW50cy9SdWxlc0VuZ2luZURyb3Bkb3duL2pzL0NvbXBhdGliaWxpdHlDaGVja2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluL3dlYmFwcC9jb21wb25lbnRzL1J1bGVzRW5naW5lRHJvcGRvd24vanMvUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vd2ViYXBwL2NvbXBvbmVudHMvUnVsZXNFbmdpbmVEcm9wZG93bi9qcy9SdWxlc0VuZ2luZURyb3Bkb3duLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluL3dlYmFwcC9jb21wb25lbnRzL1J1bGVzRW5naW5lRHJvcGRvd24vanMvaGVscGVycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi93ZWJhcHAvY29tcG9uZW50cy9WZWhpY2xlU3BlY3NSdWxlc0VuZ2luZS9qcy9WZWhpY2xlU3BlY3NSdWxlc0VuZ2luZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi93ZWJhcHAvcmVzb3VyY2VzL2Rldi9qcy91dGlscy9hcmlhLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluL3dlYmFwcC9yZXNvdXJjZXMvZGV2L2pzL3V0aWxzL2Jyb3dzZXJEZXRlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vd2ViYXBwL3Jlc291cmNlcy9kZXYvanMvdXRpbHMvZm9ybWF0UHJpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vd2ViYXBwL3Jlc291cmNlcy9kZXYvanMvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vd2ViYXBwL3Jlc291cmNlcy9kZXYvanMvdXRpbHMvdGVjaFNwZWNzLmpzIl0sIm5hbWVzIjpbIkR4QWNjb3JkaW9uIiwiZWwiLCJlbGVtZW50IiwiYWxsb3dNdWx0aXBsZSIsImhhc0F0dHJpYnV0ZSIsInNlY3Rpb25zIiwicXVlcnlTZWxlY3RvckFsbCIsIm9wZW5BY2NvcmRpb24iLCJBcnJheSIsInByb3RvdHlwZSIsImZvckVhY2giLCJjYWxsIiwic2VjdGlvbiIsImkiLCJidXR0b24iLCJxdWVyeVNlbGVjdG9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsImhhbmRsZUNsaWNrIiwiZSIsImluZGV4IiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJjbG9zZUFjY29yZGlvbiIsInBhbmVsIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiYWRkIiwic2VjdCIsInJlbW92ZSIsIkR4RHJvcGRvd24iLCJwcmV2ZW50RGVmYXVsdCIsIm9wZW4iLCJsaXN0Ym94IiwicmViaW5kTGlzdEJveCIsImNsaWNrRXZlbnRMaXN0ZW5lcnMiLCJjaGVja1Nob3ciLCJ0ZXN0Qmx1ciIsImtleURvd25FdmVudHMiLCJmaXJzdEl0ZW0iLCJhZGRBY3RpdmVEcm9wZG93bkl0ZW0iLCJ3aW5kb3ciLCJoYW5kbGVXaW5kb3dDbGljayIsInJlbGF0ZWRUYXJnZXQiLCJjbG9zZURyb3Bkb3duIiwibm9kZXMiLCJ0YXJnZXQiLCJpc0Ryb3Bkb3duRWwiLCJwYXJlbnROb2RlIiwidW5zaGlmdCIsIm5vZGUiLCJ0b2dnbGVEcm9wZG93biIsInVwZGF0ZUJ1dHRvblRleHQiLCJjaGlsZExpbmsiLCJrZXkiLCJ3aGljaCIsImtleUNvZGUiLCJET1dOIiwiS2V5Q29kZSIsIlVQIiwiRVNDIiwiUkVUVVJOIiwiVEFCIiwibmV4dEl0ZW0iLCJzaGlmdEtleSIsInByZXZpb3VzSXRlbSIsIm9wZW5Ecm9wZG93biIsImZvY3VzRmlyc3RJdGVtIiwic2V0Rm9jdXMiLCJmb2N1cyIsInRhcmdldEVsZW1lbnQiLCJpbm5lckhUTUwiLCJmaXJlRXZlbnQiLCJ2YWx1ZSIsIml0ZW1MaXN0IiwibGVuZ3RoIiwiZm9jdXNMYXN0SXRlbSIsImFjdGl2ZUVsIiwiZXZlbnRUeXBlIiwicGF5bG9hZCIsIm1ldGhvZCIsIm9wdGlvbnMiLCJ1bmRlZmluZWQiLCJmbiIsImJpbmQiLCJDb21wYXRpYmlsaXR5Q2hlY2tlciIsImZlYXR1cmVOYW1lIiwiY3VycmVudFVzZXJWYWx1ZXMiLCJmZWF0dXJlcyIsImZpbHRlcmVkRmVhdHVyZXMiLCJmaWx0ZXIiLCJmZWF0dXJlIiwiY29tcGF0aWJpbGl0eSIsImlzQXJyYXkiLCJjb21wYXRpYmlsaXRpZXMiLCJtYXAiLCJyZWZzIiwic3BsaXQiLCJpbnRlcnNlY3Rpb24iLCJpbmNsdWRlcyIsImF2YWlsYWJpbGl0eSIsIlF1ZXVlIiwiaXRlbXMiLCJjYWxsYmFjayIsIm9uQ29tcGxldGUiLCJjYW5jZWwiLCJxdWV1ZWRJdGVtcyIsInF1ZXVlUHJvY2Vzc29yIiwicXVldWVkSXRlbSIsInNoaWZ0IiwiZHhEcm9wZG93bkFjdGl2ZUNsYXNzIiwiUnVsZXNFbmdpbmVEcm9wZG93biIsImJhc2VVcmwiLCJsYW5nIiwib25GaW5pc2giLCJpc28yTGFuZyIsImJhc2VVUkwiLCJfc3VwcG9ydGVkRmVhdHVyZUxpc3QiLCJfc3VwcG9ydGVkRmVhdHVyZUVsZW1lbnRzIiwiX3N1cHByZXNzZWRWaWV3cyIsIl9xdWV1ZSIsIl9yYyIsIlJ1bGVzQ29ubmVjdCIsInJlcXVlc3RBbmRQcm9jZXNzRFhEZXJpdmF0aXZlc1ZpZXciLCJpc0NhbmNlbGxlZCIsInJlc29sdmUiLCJyZWplY3QiLCJsb2FkSnNvbnAiLCJidWlsZFJ1bGVFbmdpbmVVcmwiLCJkYXRhIiwiYWN0aXZlRmVhdHVyZXMiLCJnZXRBY3RpdmVGZWF0dXJlcyIsIm5leHRJbmRleCIsImZpbmRJbmRleCIsImYiLCJuZXh0RmVhdHVyZU5hbWUiLCJmZWF0dXJlc0xpc3QiLCJmZWF0dXJlR3JvdXAiLCJuYW1lIiwidG9Mb3dlckNhc2UiLCJkcm9wZG93biIsImdldERyb3Bkb3duIiwidmFsdWVzIiwiZ2V0RHJvcGRvd25WYWx1ZSIsInB1c2giLCJpZCIsImRlc2NyaXB0aW9uIiwiZW4iLCJidWlsZERyb3Bkb3duIiwiZHJvcGRvd25zQ29udGFpbmVyIiwiY2hpbGRyZW4iLCJfc2V0dXBGZWF0dXJlc0RPTSIsIm9uQ2hhbmdlIiwic2VsZWN0ZWRGZWF0dXJlIiwiZ2V0RmVhdHVyZXNUb1Byb2Nlc3MiLCJoYXMiLCJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJzZWFyY2hJbmRleCIsInN0YXJ0aW5nSW5kZXgiLCJzbGljZSIsInBvcCIsInJlcGxhY2UiLCJqb2luIiwiX3NldHVwRHJvcGRvd25MaXN0IiwiZHhEcm9wZG93biIsIm9uVXNlckNoYW5nZUV2ZW50IiwiZXZ0IiwidGFnTmFtZSIsImZlYXR1cmVFbGVtIiwiZG9jdW1lbnQiLCJIVE1MRWxlbWVudCIsInNldCIsImxpc3QiLCJsaXN0SXRlbSIsIml0ZW0iLCJuZXdJdGVtIiwiY2xvbmVOb2RlIiwiaXRlbUxpbmsiLCJhcHBlbmRDaGlsZCIsImJ1aWxkRW5naW5lRHJvcGRvd25NYXJrdXAiLCJERUxJTUlURVIiLCJ0ZXh0IiwiaW5kZXhPZiIsImVuZ2luZSIsImNvbnN1bXB0aW9uIiwiVmVoaWNsZVNwZWNzUnVsZXNFbmdpbmUiLCJkcm9wZG93blNlY3Rpb24iLCJzcGVjc1NlY3Rpb24iLCJlcnJvclNlY3Rpb24iLCJkcm9wZG93bkNvbnRhaW5lciIsInN1Ym1pdEJ1dHRvbiIsImluaXREcm9wZG93blNlY3Rpb24iLCJ0aGVuIiwiYWNjb3JkaW9uIiwiaW5pdEFjY29yZGlvbiIsImdldERhdGEiLCJyZW1vdmVDbGFzcyIsImJvZHlzdHlsZURyb3Bkb3duIiwibW9kZWxEcm9wZG93biIsImVuZ2luZURyb3Bkb3duIiwic3BlY0Ryb3Bkb3duIiwic2V0U3BlY3NUaXRsZSIsImJvZHlzdHlsZSIsIm1vZGVsIiwic3BlYyIsInVybCIsImNtcyIsIkpTT04iLCJwYXJzZSIsInByaWNpbmdVcmwiLCJwcm9kdWN0RGF0YSIsInByaWNpbmdEYXRhIiwic3BlY3NEYXRhIiwic3BlY3NGZWF0dXJlIiwib25TdWNjZXNzIiwib25FcnJvciIsIm9uUHJpY2luZ0Vycm9yIiwiYWRkQ2xhc3MiLCJzaG93U3BlY3MiLCJoaWRlU3BlY3MiLCJlcnJNZXNzYWdlIiwiYm9keXN0eWxlVGV4dCIsImVuZ2luZVRleHQiLCJzcGVjVGV4dCIsInNwZWNzVGl0bGVUZXh0IiwicmVwbGFjZUFsbCIsImVuZ2luZVRpdGxlVGV4dCIsInNwZWNzVGl0bGUiLCJoYXNNdWx0aXBsZUJvZHlTdHlsZXMiLCJlbmdpbmVUaXRsZSIsImJvZHlzdHlsZXMiLCJlbHMiLCJlbHNUb0hpZGUiLCJzdHJpbmciLCJzZWFyY2giLCJyZXBsYWNlbWVudCIsImNsYXNzTmFtZSIsIlZlaGljbGVTcGVjc1J1bGVzRW5naW5lcyIsImluc3RhbmNlIiwiaW5pdCIsIkJBQ0tTUEFDRSIsIkRFTEVURSIsIkVORCIsIkhPTUUiLCJMRUZUIiwiUEFHRV9ET1dOIiwiUEFHRV9VUCIsIlJJR0hUIiwiU1BBQ0UiLCJicmVha3BvaW50cyIsInNtYWxsIiwibWVkaXVtIiwid2lkZXIiLCJjdXJyZW50IiwiZ2V0RGV2aWNlT3JpZW50YXRpb24iLCIkd2luZG93IiwiJCIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0TGFyZ2VyQnJlYWtwb2ludCIsImdldEJyZWFrcG9pbnRTaXplIiwib2xkQ2FsYyIsImlubmVyV2lkdGgiLCJpc0JyZWFrcG9pbnRTbWFsbCIsImlzQnJlYWtwb2ludE1lZGl1bSIsImlzTW9iaWxlRGV2aWNlIiwiRG9jdW1lbnRUb3VjaCIsIm5hdmlnYXRvciIsIm1zTWF4VG91Y2hQb2ludHMiLCJpc05vdE1vYmlsZURldmljZSIsImlzVGFibGV0RGV2aWNlIiwidGVzdCIsInVzZXJBZ2VudCIsImlzSU9TIiwiaXNOb3RJT1MiLCJpc1dpbmRvd3NQaG9uZSIsImdldEFuZHJvaWRWZXJzaW9uIiwidWEiLCJwYXJzZUZsb2F0IiwiZ2V0QnJvd3NlclVzZXJBZ2VudCIsImRldGVjdEJyb3dzZXJzIiwiYnJvd3NlcnMiLCJpc0Nocm9tZSIsImlzTXNFZGdlIiwiaXNFeHBsb3JlciIsImlzRmlyZWZveCIsImlzU2FmYXJpIiwiaXNPcGVyYSIsImlzSWUiLCJpc0llMTEiLCJBY3RpdmVYT2JqZWN0IiwiZ2V0Vmlld3BvcnRTaXplIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiY3NzVGV4dCIsImRvY3VtZW50RWxlbWVudCIsImluc2VydEJlZm9yZSIsImZpcnN0Q2hpbGQiLCJkaW1zIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJyZW1vdmVDaGlsZCIsInNjcm9sbFRvRWxlbWVudCIsIiRlbGVtZW50IiwialF1ZXJ5Iiwib3B0cyIsImV4dGVuZCIsImFkanVzdG1lbnQiLCJlYXNlIiwiZHVyYXRpb24iLCJjb250YWluZXIiLCJzdG9wIiwiYW5pbWF0ZSIsInNjcm9sbFRvcCIsIm9mZnNldCIsInRvcCIsImhhc0JpZ0ludFN1cHBvcnQiLCJCaWdJbnQiLCJwcmljZSIsImZvcm1hdCIsIm1ldGFkYXRhIiwibWV0YSIsInJjIiwicmVhZEN1cnJlbmN5Rm9ybWF0cyIsImdldEZvcm1hdHRlZFByaWNlIiwiJG5hdkhlYWRlciIsInN0aWNreU5hdmlnYXRpb25FbmFibGVkIiwiYXR0ciIsInN0aWNreU5hdmlnYXRpb25UcmFuc2l0aW9uUG9pbnQiLCJ0ZW1wbGF0ZUNhY2hlIiwiZ29vZ2xlTWFwU3R5bGVzIiwiZmVhdHVyZVR5cGUiLCJlbGVtZW50VHlwZSIsInN0eWxlcnMiLCJjb2xvciIsInZpc2liaWxpdHkiLCJzYXR1cmF0aW9uIiwibGlnaHRuZXNzIiwiaXNSdGwiLCJodG1sIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRDYWNoZWRTY3JpcHQiLCJuZXdPcHRpb25zIiwiZGF0YVR5cGUiLCJjYWNoZSIsImFqYXgiLCJnZXRIZWlnaHQiLCJlbGVtIiwiY2xpZW50SGVpZ2h0IiwiZ2V0U3RpY2t5TmF2SGVpZ2h0IiwieVBvcyIsIm9sZENhbGN1bGF0aW9uIiwieVBvc2l0aW9uIiwic2hhcmVkSGVhZGVyIiwiJGhlYWRlciIsIiRpblBhZ2VOYXYiLCIkaW5QYWdlTmF2U3RpY2t5IiwiJGluUGFnZU5hdkJhciIsImR4TmF2UHJpbWFyeSIsImJyZWFrcG9pbnQiLCJjaGVja1N0aWNreU5hdiIsImNzcyIsImluUGFnZU5hdlRvcCIsImlzU3RpY2t5TmF2Iiwib2xkTmF2QnJlYWtwb2ludCIsIm91dGVySGVpZ2h0Iiwid2luZG93V2lkdGgiLCJnZXROYXZpZ2F0aW9uSGVpZ2h0IiwiZ2V0TmFhU0hlaWdodCIsIm9sZCIsInByaW1hcnlOYXZIZWlnaHQiLCJwYXJzZUludCIsImJyZWFkY3J1bWJOYXZIZWlnaHQiLCJub3RpZmljYXRpb25IZWlnaHQiLCJpblBhZ2VOYXZpZ2F0aW9uSGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJNYXRoIiwibWF4IiwiZ2V0U3RpY2t5TmF2SGVpZ2h0VjIiLCJzY3JvbGxUbyIsImVhc2luZyIsImlnbm9yZVN0aWNreU5hdiIsInlPZmZzZXQiLCJuZXdEdXJhdGlvbiIsIm5ld0NhbGxiYWNrIiwibmV3RWFzaW5nIiwicG9zaXRpb24iLCIkdGFyZ2V0RWwiLCJwcm9taXNlIiwiZG9uZSIsImNoZWNrRGVlcExpbmsiLCJocmVmIiwiZGVlcExpbmsiLCJzcGVlZCIsImhhc2hQb3MiLCJzdWJzdHJpbmciLCJsb2NhdGlvbiIsImFjY29yZGlvblBhcmVudCIsImNsb3Nlc3QiLCJhY2NvcmRpb25UaXRsZSIsImZpbmQiLCJoYXNDbGFzcyIsImNsaWNrIiwicGFyZW50cyIsIiRjb250YWluZXIiLCIkdGFicyIsIiR0YWJMaW5rcyIsInRhYkluZGV4IiwiZWFjaCIsIiRsb2NhdGlvbiIsImFjY29yZGlvbkhlYWRlciIsImlzIiwiY29uc29sZSIsImVycm9yIiwiaXNQYWdlSW5JZnJhbWUiLCJzZWxmIiwiaW5zaWRlVGFiYmVkQ29udGFpbmVyIiwiaXNJbnNpZGVUYWJiZWRDb250YWluZXIiLCJub3QiLCJtb2JpbGVBY2NvcmRpb25zQWN0aXZhdGVkIiwicmVtb3ZlSFRNTFRhZ3MiLCJzIiwidG9TdHJpbmciLCJnZXRVcmxQYXJhbWV0ZXIiLCJzUGFyYW0iLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzUGFnZVVSTCIsInNVUkxWYXJpYWJsZXMiLCJzUGFyYW1ldGVyU3BsaXQiLCJhZGRQYXJhbWV0ZXJUb1VSTCIsInBhcmFtIiwibmV3VXJsIiwiZ2V0T2JqZWN0S2V5cyIsIm9iaiIsImtleXMiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbnZhc0RyYXdCZ0NvdmVyIiwiY3R4IiwiaW1nIiwieCIsInkiLCJ3IiwiaCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiYXJndW1lbnRzIiwiY2FudmFzIiwiaXciLCJpaCIsInIiLCJtaW4iLCJudyIsIm5oIiwiY3giLCJjeSIsImN3IiwiY2giLCJhciIsImRyYXdJbWFnZSIsImhhc1BsYWNlaG9sZGVyU3VwcG9ydCIsImlzUGFnZUluWFBNRnJhbWUiLCJUcmlkaW9uIiwiV2ViIiwiVUkiLCJTaXRlRWRpdCIsImVsZW1lbnRJblZpZXdwb3J0IiwiYWRqdXN0Iiwid2luZG93SW5uZXJIZWlnaHQiLCJ3aW5kb3dIZWlnaHQiLCJhZGp1c3RUb3AiLCJhZGp1c3RCb3R0b20iLCJlbE9mZnNldCIsImVsVG9wIiwiZWxCb3R0b20iLCJkZWZhdWx0QWRqdXN0Iiwidmlld3BvcnRCb3R0b20iLCJib3R0b20iLCJnZXRSYW5kb21TdHJpbmciLCJmb3JtYXR0ZWRMZW5ndGgiLCJjaGFycyIsImNob3NlbiIsImNoYXJBdCIsImZsb29yIiwicmFuZG9tIiwiZ2V0RWFzaW5nVmFsdWUiLCJyYXRpbyIsImZvcm1hdHRlZFJhdGlvIiwicmFkaWFucyIsIlBJIiwiY29zIiwiZGlzYWJsZVNjcm9sbCIsIm9uIiwiZXZlbnQiLCJlbmFibGVTY3JvbGwiLCJvZmYiLCJsaW1pdE51bWJlciIsIm9sZE1pbiIsImxvYWRJZ25vcmVkUmVzcG9uc2l2ZUltYWdlcyIsIiRpbWFnZXMiLCJyZW1vdmVBdHRyIiwicmljaHNwb25zaXZlSW1hZ2UiLCJ0aHJvdHRsZSIsInRocmVzaGhvbGQiLCJzY29wZSIsInRocmVzaCIsImxhc3QiLCJkZWZlclRpbWVyIiwiY29udGV4dCIsIm5vdyIsIkRhdGUiLCJhcmdzIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImFwcGx5IiwibWVhc3VyZVRleHRXaWR0aCIsInBhcmVudCIsInBhciIsImJvZHkiLCJwYWRkaW5nIiwid2hpdGVTcGFjZSIsImNsaWVudFdpZHRoIiwiZ2V0VHJhbnNpdGlvbkVuZEV2ZW50IiwidHJhbnNpdGlvbnMiLCJ0cmFuc2l0aW9uIiwiT1RyYW5zaXRpb24iLCJNb3pUcmFuc2l0aW9uIiwiV2Via2l0VHJhbnNpdGlvbiIsInRlbXBsYXRlIiwic3RyIiwiZ2V0RWxlbWVudEJ5SWQiLCJGdW5jdGlvbiIsImlzSW5WaWV3cG9ydCIsIndpbiIsInZpZXdwb3J0IiwibGVmdCIsInNjcm9sbExlZnQiLCJyaWdodCIsImJvdW5kcyIsIm91dGVyV2lkdGgiLCJzY3JvbGxJZk5vdEluVmlld3BvcnQiLCJkaXNwbGF5VG9Cb3R0b20iLCJzY3JvbGxUb1BvcyIsImlzTGFuZFJvdmVyIiwiZ2V0VGFiYmFibGUiLCJjdXN0b21TZWxlY3RvcnMiLCJkZWZhdWx0U2VsZWN0b3JzIiwic2VsZWN0b3JUeXBlcyIsImNvbmNhdCIsInNlbGVjdG9ycyIsInNlbGVjdG9yIiwidGFiYmFibGUiLCJvZmZzZXRQYXJlbnQiLCJpc0ludmlzaWJsZSIsImRpc3BsYXkiLCJsb2NrVGFiYmFibGVzIiwidGFiYmFibGVzIiwiYmFsYW5jZUVsZW1lbnRIZWlnaHQiLCJlbGVtZW50cyIsImFsbG93ZWRPZmZzZXQiLCJjb2x1bW5zIiwiZWxlbWVudHNBcnJheSIsImhlaWdodFRvdGFsIiwiaGVpZ2h0c0FycmF5IiwiZWxlbWVudEhlaWdodCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImdldEJhbGFuY2VkSW5kZXgiLCJhcnJheSIsInJ1bm5pbmdUb3RhbCIsImlzUmVjdXJzaXZlIiwic3BsaXRJbmRleCIsImNvbHVtbnMxIiwiY29sdW1uczIiLCJldmVudFRyaWdnZXIiLCJkZXRhaWwiLCJidWJibGVzIiwiQ3VzdG9tRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiY29udmVydEVsZW1lbnRDb2xsZWN0aW9uVG9BcnJheSIsImNvbGxlY3Rpb24iLCJOb2RlTGlzdCIsInJhbmRvbWlzZUVsZW1lbnRzIiwiZWxlbWVudHNDb2xsZWN0aW9uIiwiY2xvbmVkRWxlbWVudHMiLCJzb3J0IiwiaW5jIiwicmVwbGFjZUNoaWxkIiwiaXNFbGVtZW50VmVydGljYWxseVNjcm9sbGFibGUiLCJzY3JvbGxIZWlnaHQiLCJjaGVja0RlZmluZWQiLCJ0YWJsaXN0TmF2aWdhdGlvbiIsInRhYmxpc3QiLCJvcmllbnRhdGlvbiIsImlzVmVydGljYWwiLCJ0YWJzIiwiZm9jdXNGaXJzdFRhYiIsImZvY3VzTGFzdFRhYiIsImZvY3VzUHJldmlvdXNUYWIiLCJjdXJyZW50VGFiIiwiZm9jdXNOZXh0VGFiIiwidGFic0xlbmd0aFplcm9JbmRleCIsImhhbmRsZVRhYmxpc3RLZXlkb3duRXZlbnRzIiwiY3VycmVudFRhcmdldCIsImhhbmRsZVRhYmxpc3RLZXl1cEV2ZW50cyIsInRhYiIsImlzRW1wdHkiLCJPYmplY3QiLCJkeFNldFRpbWVvdXQiLCJjYiIsInRpbWUiLCJhcHBSZWFkeUV2ZW50IiwiaW5pdGlhdGVkIiwiYXBwUmVhZHlUaW1lciIsInRpbWVvdXQiLCJEeFJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJsb2FkaW5nU3Bpbm5lclRvZ2dsZUJ1dHRvblN0YXRlQW5kQ29udGVudCIsImRpc2FibGVkIiwiY2hpbGQiLCJvcGFjaXR5IiwiYWRkRHhMb2FkaW5nU3Bpbm5lciIsImljb25NYXJrdXAiLCJsb2FkaW5nSWNvbiIsImNyZWF0ZVJhbmdlIiwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IiwicmVtb3ZlRHhMb2FkaW5nU3Bpbm5lciIsImFkZER4RWxlbWVudExvYWRpbmdTcGlubmVyIiwibG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImdldEl0ZW0iLCJyZW1vdmVJdGVtIiwiYWRkU2NyaXB0Rm9yQmF6YWFyVm9pY2UiLCJzY3JpcHRVUkwiLCJ0cmltIiwiYmF6YWFyVm9pY2VTY3JpcHQiLCJoZWFkIiwiZXF1YWxpc2VIZWlnaHRzIiwibWF4SGVpZ2h0IiwiZ2VuZXJhdGVDdXJyZW50RGF0ZSIsInRvZGF5IiwiVVRDIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJwcmV2ZW50QWN0aW9uT25EZWVwTGluayIsImxpbmtMb2NhdGlvbiIsImhhc0ZhbGxiYWNrUHJpY2VUeXBlIiwiY21zU2V0dGluZ3MiLCJjdXJyZW50UHJpY2VUeXBlIiwiZGVmYXVsdFByaWNpbmdUeXBlS2V5IiwiZmFsbGJhY2tQcmljaW5nVHlwZUtleSIsImhhc05vdEZhbGxiYWNrUHJpY2VUeXBlIiwiYWRkRmFsbGJhY2tQcmljZSIsIm5ld1NldHRpbmdzIiwiZmFsbGJhY2tQcmljaW5nVHlwZUxhYmVsIiwidGFibGUiLCJzdXBwcmVzc1ByaWNpbmdJZlplcm8iLCJwcmljaW5nIiwiZmVhdHVyZVByaWNlcyIsInByaWNlVHlwZSIsIkVycm9yIiwiZ2V0VGV4dCIsInRhYmxlVGVtcGxhdGUiLCJoZWFkaW5ncyIsImlzUHJpY2luZyIsImNhdmVhdFNlY3Rpb24iLCJoZWFkaW5nIiwiaGVhZGluZ1RleHQiLCJwcmljZUNhdmVhdCIsImNhdmVhdCIsInRkVGV4dCIsInRoIiwidGQiLCJyb3ciLCJjYXZlYXRUb0FkZCIsImRhdGFTZWN0aW9uIiwiYWNjb3JkaW9uU2VjdGlvblRlbXBsYXRlIiwicHJlZml4IiwibmV3U2VjdGlvbiIsInBhbmVsSWQiLCJidXR0b25JZCIsImFjY29yZGlvblByaWNpbmdTZWN0aW9uIiwidGFibGVUb0FkZCIsImJ1aWxkQWNjb3JkaW9uU2VjdGlvbiIsImRhdGFzZXRzIiwibGFiZWxzIiwibGFiZWwiLCJidWlsZEFjY29yZGlvbiIsInNwZWNzIiwiYWNjb3JkaW9uQ29udGFpbmVyIiwiYWNjb3JkaW9uVGVtcGxhdGUiLCJhY2NvcmRpb25QYW5lbCIsInByaWNlUGFuZWxQb3NpdGlvbiIsImRhdGFzZXQiLCJhZGRQcmljZUFjY29yZGlvblBhbmVsIiwiZmVhdHVyZURpY3Rpb25hcnkiLCJlcnIiLCJUeXBlRXJyb3IiLCJtZXNzYWdlIiwiY291bnQiLCJhcGlDYWxsIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUEsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7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QkFBZCxFQUFrQztBQUNoQ0U7QUFDRDs7QUFFREwseUJBQW1CbGdCLFdBQW5CLENBQStCNGYsc0JBQXNCbEYsR0FBdEIsRUFBMkJ5RixpQkFBM0IsRUFBOENTLEtBQTlDLEVBQXFEdEIsTUFBckQsRUFBNkR4akIsSUFBN0QsQ0FBL0I7O0FBRUE4a0IsZUFBUyxDQUFUO0FBQ0QsS0FSRDtBQVNELEdBVkQ7O0FBWUEsU0FBTyxJQUFJOXJCLHFCQUFKLENBQWdCb3JCLGtCQUFoQixDQUFQO0FBQ0QsQ0F0RE07O0FBd0RQLElBQU1sWCxLQUFLLElBQUl6TSw0QkFBSixFQUFYOztBQUVPLElBQU1za0IsNEJBQVUsU0FBVkEsT0FBVSxDQUFDbGYsR0FBRCxFQUFTO0FBQzlCLFNBQU9xSCxHQUFHcE0sU0FBSCxDQUFhK0UsR0FBYixDQUFQO0FBQ0QsQ0FGTSxDIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9WZWhpY2xlU3BlY3NSdWxlc0VuZ2luZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL21haW4vd2ViYXBwL2NvbXBvbmVudHMvVmVoaWNsZVNwZWNzUnVsZXNFbmdpbmUvanMvVmVoaWNsZVNwZWNzUnVsZXNFbmdpbmUuanNcIik7XG4iLCJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKlxuQmFzZWQgb24gSmF2YSBEZWNpbWFsRm9ybWF0IGFuZCBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9vc2thbnNhdmxpLzgyMjM4MlxuKi9cbnZhciBEZWNpbWFsRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEZWNpbWFsRm9ybWF0KGZvcm1hdFN0cikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZWNpbWFsRm9ybWF0KTtcblxuICAgIHRoaXMuX3ByZWZpeCA9IERlY2ltYWxGb3JtYXQuX2dldFByZWZpeChmb3JtYXRTdHIpO1xuXG4gICAgdmFyIG5vUHJlZml4ID0gZm9ybWF0U3RyLnN1YnN0cmluZyh0aGlzLl9wcmVmaXgubGVuZ3RoKTtcbiAgICB0aGlzLl9zdWZmaXggPSBEZWNpbWFsRm9ybWF0Ll9nZXRTdWZmaXgobm9QcmVmaXgpO1xuXG4gICAgdmFyIG51bWJlclN0ciA9IG5vUHJlZml4LnN1YnN0cigwLCBub1ByZWZpeC5sZW5ndGggLSB0aGlzLl9zdWZmaXgubGVuZ3RoKTtcblxuICAgIHRoaXMuX3N1ZmZpeCA9IHRoaXMuX3N1ZmZpeC5yZXBsYWNlKC9bJ10vZywgJycpO1xuICAgIHRoaXMuX2dyb3VwU2l6ZSA9IDA7XG4gICAgdGhpcy5fbWluSW50ID0gMTtcbiAgICB0aGlzLl9taW5GcmFjID0gMDtcbiAgICB0aGlzLl9tYXhGcmFjID0gMDtcblxuICAgIHRoaXMuX2dyb3VwaW5nU2VwYXJhdG9yID0gJywnO1xuICAgIHRoaXMuX291dHB1dERlY2ltYWxTZXBhcmF0b3IgPSAnLic7XG5cbiAgICBpZiAobnVtYmVyU3RyLmluZGV4T2YoXCIjLiNcIikgIT09IC0xKSB7XG4gICAgICB0aGlzLl9ncm91cGluZ1NlcGFyYXRvciA9ICcuJztcbiAgICAgIHRoaXMuX291dHB1dERlY2ltYWxTZXBhcmF0b3IgPSAnLCc7XG4gICAgfSBlbHNlIGlmIChudW1iZXJTdHIuaW5kZXhPZihcIiMgI1wiKSAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2dyb3VwaW5nU2VwYXJhdG9yID0gJyAnO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyU3RyLmluZGV4T2YoXCIjXFx4YTAjXCIpICE9PSAtMSkge1xuICAgICAgdGhpcy5fZ3JvdXBpbmdTZXBhcmF0b3IgPSAnXFx4YTAnO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyU3RyLmluZGV4T2YoXCIjJyNcIikgIT09IC0xKSB7XG4gICAgICB0aGlzLl9ncm91cGluZ1NlcGFyYXRvciA9ICdcXCcnO1xuICAgIH1cblxuICAgIHZhciBpbnRTdHIgPSAnJztcbiAgICB2YXIgZnJhY1N0ciA9ICcnO1xuICAgIHZhciBwb2ludCA9IG51bWJlclN0ci5pbmRleE9mKHRoaXMuX291dHB1dERlY2ltYWxTZXBhcmF0b3IpO1xuICAgIGlmIChwb2ludCAhPSAtMSkge1xuICAgICAgaW50U3RyID0gbnVtYmVyU3RyLnN1YnN0cmluZygwLCBwb2ludCk7XG4gICAgICBmcmFjU3RyID0gbnVtYmVyU3RyLnN1YnN0cmluZyhwb2ludCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRTdHIgPSBudW1iZXJTdHI7XG4gICAgfVxuXG4gICAgdmFyIGNvbW1hUG9zID0gaW50U3RyLmxhc3RJbmRleE9mKHRoaXMuX2dyb3VwaW5nU2VwYXJhdG9yKTtcbiAgICBpZiAoY29tbWFQb3MgIT0gLTEpIHtcbiAgICAgIHRoaXMuX2dyb3VwU2l6ZSA9IGludFN0ci5sZW5ndGggLSAxIC0gY29tbWFQb3M7XG4gICAgfVxuXG4gICAgaW50U3RyID0gaW50U3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIltcXFxcXCIgKyB0aGlzLl9ncm91cGluZ1NlcGFyYXRvciArIFwiXVwiLCBcImdcIiksICcnKTsgLy8gcmVtb3ZlIGNvbW1hc1xuICAgIGZyYWNTdHIgPSBmcmFjU3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIltcXFxcXCIgKyB0aGlzLl9ncm91cGluZ1NlcGFyYXRvciArIFwiXXxbXFxcXFwiICsgdGhpcy5fb3V0cHV0RGVjaW1hbFNlcGFyYXRvciArIFwiXStcIiwgXCJnXCIpLCAnJyk7XG5cbiAgICB0aGlzLl9tYXhGcmFjID0gZnJhY1N0ci5sZW5ndGg7XG5cbiAgICB2YXIgdG1wID0gaW50U3RyLnJlcGxhY2UoL1teMF0vZywgJycpOyAvLyByZW1vdmUgYWxsIGV4Y2VwdCB6ZXJvXG4gICAgaWYgKHRtcC5sZW5ndGggPiB0aGlzLl9taW5JbnQpIHRoaXMuX21pbkludCA9IHRtcC5sZW5ndGg7XG4gICAgdG1wID0gZnJhY1N0ci5yZXBsYWNlKC9bXjBdL2csICcnKTtcbiAgICB0aGlzLl9taW5GcmFjID0gdG1wLmxlbmd0aDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEZWNpbWFsRm9ybWF0LCBbe1xuICAgIGtleTogJ2dldElucHV0RGVjaW1hbFNlcGFyYXRvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElucHV0RGVjaW1hbFNlcGFyYXRvcihpbnB1dCkge1xuICAgICAgcmV0dXJuIFwiLlwiOyAvLyBBbHdheXMgYXNzdW1lIHRoYXQgdGhlIGlucHV0IGlzIGEgYG51bWJlcmAgdGhlcmVmb3JlIGlzIGFsd2F5cyBhIHBvaW50LlxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChudW1TdHIpIHtcbiAgICAgIC8vIDEyMjMuMDYgLS0+ICQxLDIyMy4wNlxuICAgICAgLy8gcmVtb3ZlIHByZWZpeCwgc3VmZml4IGFuZCBjb21tYXNcbiAgICAgIHZhciBudW1iZXJTdHIgPSB0aGlzLnBhcnNlRGVjaW1hbChudW1TdHIpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIC8vIGRvIG5vdCBmb3JtYXQgaWYgbm90IGEgbnVtYmVyXG4gICAgICBpZiAoaXNOYU4obnVtYmVyU3RyKSB8fCBudW1iZXJTdHIubGVuZ3RoID09IDApIHJldHVybiBudW1TdHI7XG5cbiAgICAgIHZhciBuZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgLy8gcmVtb3ZlIHNpZ25cbiAgICAgIGlmIChudW1iZXJTdHIuY2hhckF0KDApID09ICctJykge1xuICAgICAgICBuZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgIG51bWJlclN0ciA9IG51bWJlclN0ci5zdWJzdHJpbmcoMSk7XG4gICAgICB9IGVsc2UgaWYgKG51bWJlclN0ci5jaGFyQXQoMCkgPT0gJysnKSB7XG4gICAgICAgIG51bWJlclN0ciA9IG51bWJlclN0ci5zdWJzdHJpbmcoMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnB1dERlY2ltYXBTZXBhcmF0b3IgPSB0aGlzLmdldElucHV0RGVjaW1hbFNlcGFyYXRvcihudW1TdHIpO1xuICAgICAgdmFyIHBvaW50ID0gbnVtYmVyU3RyLmluZGV4T2YoaW5wdXREZWNpbWFwU2VwYXJhdG9yKTsgLy8gcG9zaXRpb24gb2YgcG9pbnQgY2hhcmFjdGVyXG4gICAgICB2YXIgaW50U3RyID0gJyc7XG4gICAgICB2YXIgZnJhY1N0ciA9ICcnO1xuICAgICAgaWYgKHBvaW50ICE9IC0xKSB7XG4gICAgICAgIGludFN0ciA9IG51bWJlclN0ci5zdWJzdHJpbmcoMCwgcG9pbnQpO1xuICAgICAgICBmcmFjU3RyID0gbnVtYmVyU3RyLnN1YnN0cmluZyhwb2ludCArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50U3RyID0gbnVtYmVyU3RyO1xuICAgICAgfVxuICAgICAgZnJhY1N0ciA9IGZyYWNTdHIucmVwbGFjZShuZXcgUmVnRXhwKFwiW1xcXFxcIiArIHRoaXMuX291dHB1dERlY2ltYWxTZXBhcmF0b3IgKyBcIl1cIiksICcnKTsgLy8gcmVtb3ZlIG90aGVyIHBvaW50IGNoYXJhY3RlcnNcblxuICAgICAgaWYgKGZyYWNTdHIubGVuZ3RoID4gdGhpcy5fbWF4RnJhYykge1xuICAgICAgICAvLyByb3VuZFxuICAgICAgICAvL2Nhc2UgNjE0M1xuICAgICAgICB2YXIgbnVtID0gbmV3IE51bWJlcignMC4nICsgZnJhY1N0cik7XG4gICAgICAgIG51bSA9IHRoaXMuX21heEZyYWMgPT0gMCA/IE1hdGgucm91bmQobnVtKSA6IG51bS50b0ZpeGVkKHRoaXMuX21heEZyYWMpO1xuICAgICAgICAvLyB0b0ZpeGVkIG1ldGhvZCBoYXMgYnVncyBvbiBJRSAoMC43IC0tPiAwKVxuICAgICAgICBmcmFjU3RyID0gbnVtLnRvU3RyaW5nKDEwKS5zdWJzdHIoMik7XG4gICAgICAgIHZhciBjID0gbnVtID49IDEgPyAxIDogMDsgLy9jYXJyeVxuICAgICAgICB2YXIgeCxcbiAgICAgICAgICAgIGkgPSBpbnRTdHIubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGMpIHtcbiAgICAgICAgICAvL2luY3JlbWVudCBpbnRTdHJcbiAgICAgICAgICBpZiAoaSA9PSAtMSkge1xuICAgICAgICAgICAgaW50U3RyID0gJzEnICsgaW50U3RyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSBpbnRTdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKHggPT0gOSkge1xuICAgICAgICAgICAgICB4ID0gJzAnO2MgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeCA9ICsreCArICcnO2MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50U3RyID0gaW50U3RyLnN1YnN0cmluZygwLCBpKSArIHggKyBpbnRTdHIuc3Vic3RyaW5nKGkgKyAxLCBpbnRTdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSBmcmFjU3RyLmxlbmd0aDsgaSA8IHRoaXMuX21pbkZyYWM7IGkrKykge1xuICAgICAgICAvLyBpZiBtaW5GcmFjPTQgdGhlbiAxLjEyIC0tPiAxLjEyMDBcbiAgICAgICAgZnJhY1N0ciA9IGZyYWNTdHIgKyAnMCc7XG4gICAgICB9XG4gICAgICB3aGlsZSAoZnJhY1N0ci5sZW5ndGggPiB0aGlzLl9taW5GcmFjICYmIGZyYWNTdHIuY2hhckF0KGZyYWNTdHIubGVuZ3RoIC0gMSkgPT0gJzAnKSB7XG4gICAgICAgIC8vIGlmIG1pbkludD00IHRoZW4gMDAwMzQgLS0+IDAwMzQpXG4gICAgICAgIGZyYWNTdHIgPSBmcmFjU3RyLnN1YnN0cmluZygwLCBmcmFjU3RyLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gaW50U3RyLmxlbmd0aDsgaSA8IHRoaXMuX21pbkludDsgaSsrKSB7XG4gICAgICAgIC8vIGlmIG1pbkludD00IHRoZW4gMDM0IC0tPiAwMDM0XG4gICAgICAgIGludFN0ciA9ICcwJyArIGludFN0cjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpbnRTdHIubGVuZ3RoID4gdGhpcy5fbWluSW50ICYmIGludFN0ci5jaGFyQXQoMCkgPT0gJzAnKSB7XG4gICAgICAgIC8vIGlmIG1pbkludD00IHRoZW4gMDAwMzQgLS0+IDAwMzQpXG4gICAgICAgIGludFN0ciA9IGludFN0ci5zdWJzdHJpbmcoMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBqID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSBpbnRTdHIubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIC8vIGFkZCBjb21tYXNcbiAgICAgICAgaWYgKGogIT0gMCAmJiBqICUgdGhpcy5fZ3JvdXBTaXplID09IDApIHtcbiAgICAgICAgICBpbnRTdHIgPSBpbnRTdHIuc3Vic3RyaW5nKDAsIGkpICsgdGhpcy5fZ3JvdXBpbmdTZXBhcmF0b3IgKyBpbnRTdHIuc3Vic3RyaW5nKGkpO1xuICAgICAgICAgIGogPSAwO1xuICAgICAgICB9XG4gICAgICAgIGorKztcbiAgICAgIH1cblxuICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlO1xuICAgICAgaWYgKGZyYWNTdHIubGVuZ3RoID4gMCkgZm9ybWF0dGVkVmFsdWUgPSB0aGlzLl9wcmVmaXggKyBpbnRTdHIgKyB0aGlzLl9vdXRwdXREZWNpbWFsU2VwYXJhdG9yICsgZnJhY1N0ciArIHRoaXMuX3N1ZmZpeDtlbHNlIGZvcm1hdHRlZFZhbHVlID0gdGhpcy5fcHJlZml4ICsgaW50U3RyICsgdGhpcy5fc3VmZml4O1xuXG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSAnLScgKyBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvcm1hdHRlZFZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BhcnNlRGVjaW1hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlRGVjaW1hbChmTnVtU3RyKSB7XG4gICAgICAvLyAkMSwyMjMuMDYgLS0+IDEyMjMuMDZcbiAgICAgIGlmICh0eXBlb2YgZk51bVN0ciA9PT0gXCJ1bmRlZmluZWRcIiB8fCBmTnVtU3RyID09PSBudWxsKSByZXR1cm4gJyc7IC8vZG8gbm90IHJldHVybiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgZk51bVN0ciArPSAnJzsgLy9lbnN1cmUgaXQgaXMgc3RyaW5nXG4gICAgICBpZiAoIWlzTmFOKGZOdW1TdHIpKSByZXR1cm4gdGhpcy5nZXROdW1lcmljU3RyaW5nKGZOdW1TdHIpO1xuXG4gICAgICB2YXIgZk51bWJlclN0ciA9IGZOdW1TdHI7XG4gICAgICB2YXIgbmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgIGlmIChmTnVtU3RyLmNoYXJBdCgwKSA9PSAnLScpIHtcbiAgICAgICAgZk51bWJlclN0ciA9IGZOdW1iZXJTdHIuc3Vic3RyKDEpO1xuICAgICAgICBuZWdhdGl2ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwSW5kZXggPSBmTnVtYmVyU3RyLmluZGV4T2YodGhpcy5fcHJlZml4KTtcbiAgICAgIHZhciBzSW5kZXggPSB0aGlzLl9zdWZmaXggPT0gJycgPyBmTnVtYmVyU3RyLmxlbmd0aCA6IGZOdW1iZXJTdHIuaW5kZXhPZih0aGlzLl9zdWZmaXgsIHRoaXMuX3ByZWZpeC5sZW5ndGggKyAxKTtcblxuICAgICAgaWYgKHBJbmRleCA9PSAwICYmIHNJbmRleCA+IDApIHtcbiAgICAgICAgLy8gcmVtb3ZlIHN1ZmZpeFxuICAgICAgICBmTnVtYmVyU3RyID0gZk51bWJlclN0ci5zdWJzdHIoMCwgc0luZGV4KTtcbiAgICAgICAgLy8gcmVtb3ZlIHByZWZpeFxuICAgICAgICBmTnVtYmVyU3RyID0gZk51bWJlclN0ci5zdWJzdHIodGhpcy5fcHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIC8vIHJlbW92ZSBncm91cGluZyBzZXBhcmF0b3JzXG4gICAgICAgIGZOdW1iZXJTdHIgPSBmTnVtYmVyU3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxcIiArIHRoaXMuX2dyb3VwaW5nU2VwYXJhdG9yLCBcImdcIiksICcnKTtcbiAgICAgICAgLy8gY29udmVydCBkZWNpbWFsIHNlcGFyYXRvciB0byB0cmFkaXRpb25hbCBwZXJpb2RcbiAgICAgICAgZk51bWJlclN0ciA9IGZOdW1iZXJTdHIucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXFwiICsgdGhpcy5fb3V0cHV0RGVjaW1hbFNlcGFyYXRvciwgXCJnXCIpLCAnLicpO1xuXG4gICAgICAgIGlmIChuZWdhdGl2ZSkgZk51bWJlclN0ciA9ICctJyArIGZOdW1iZXJTdHI7XG4gICAgICAgIGlmICghaXNOYU4oZk51bWJlclN0cikpIHJldHVybiB0aGlzLmdldE51bWVyaWNTdHJpbmcoZk51bWJlclN0cik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmTnVtU3RyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBXZSBzaG91bGRuJ3QgcmV0dXJuIHN0cmluZ3MgbGlrZSAxLjAwMCBpbiBwYXJzZURlY2ltYWwgbWV0aG9kLlxuICAgICAqIEhvd2V2ZXIsIHVzaW5nIG9ubHkgTnVtYmVyKHN0cikgaXMgbm90IGVub3VnaCwgYmVjYXVzZSBpdCBvbWl0cyAuIGluIGJpZyBudW1iZXJzXG4gICAgICogbGlrZSAyMzQyMzQyMzQyMzM0MjIzNC4zNCA9PiAyMzQyMzQyMzQyMzM0MjIzNiAuIFRoZXJlJ3MgYSBjb25mbGljdCBpbiBjYXNlc1xuICAgICAqIDYxNDMgYW5kIDY1NDEuXG4gICAgICogQG1ldGhvZE9mIERlY2ltYWxGb3JtYXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIE51bWJlcmljIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQ29ycmVjdGVkIG51bWVyaWMgc3RyaW5nXG4gICAgICogQGF1dGhvciBTZXJkYXIgQmljZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0TnVtZXJpY1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE51bWVyaWNTdHJpbmcoc3RyKSB7XG4gICAgICAvL2ZpcnN0IGNvbnZlcnQgdG8gbnVtYmVyXG4gICAgICB2YXIgbnVtID0gbmV3IE51bWJlcihzdHIpO1xuICAgICAgLy9jaGVjayBpZiB0aGVyZSBpcyBhIG1pc3NpbmcgZG90XG4gICAgICB2YXIgbnVtU3RyID0gbnVtICsgJyc7XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJy4nKSA+IC0xICYmIG51bVN0ci5pbmRleE9mKCcuJykgPCAwKSB7XG4gICAgICAgIC8vY2hlY2sgaWYgb3JpZ2luYWwgc3RyaW5nIGhhcyBhbGwgemVyb3MgYWZ0ZXIgZG90IG9yIG5vdFxuICAgICAgICBmb3IgKHZhciBpID0gc3RyLmluZGV4T2YoJy4nKSArIDE7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvL2lmIG5vdCwgdGhpcyBtZWFucyB3ZSBsb3N0IHByZWNpc2lvblxuICAgICAgICAgIGlmIChzdHIuY2hhckF0KGkpICE9PSAnMCcpIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bVN0cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdfZ2V0UHJlZml4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFByZWZpeChmb3JtYXRTdHIpIHtcbiAgICAgIHZhciBwcmVmaXggPSAnJztcblxuICAgICAgdmFyIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybWF0U3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmb3JtYXRTdHIuY2hhckF0KGkpID09ICdcXCcnKSB7XG4gICAgICAgICAgaW5RdW90ZSA9ICFpblF1b3RlO1xuICAgICAgICB9IGVsc2UgaWYgKCFpblF1b3RlICYmIChmb3JtYXRTdHIuY2hhckF0KGkpID09ICcjJyB8fCBmb3JtYXRTdHIuY2hhckF0KGkpID09ICcwJykpIHtcbiAgICAgICAgICBwcmVmaXggPSBmb3JtYXRTdHIuc3Vic3RyaW5nKDAsIGkpLnJlcGxhY2UoL1snXS9nLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2dldFN1ZmZpeCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdWZmaXgoZm9ybWF0U3RyKSB7XG4gICAgICB2YXIgc3VmZml4ID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gZm9ybWF0U3RyLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGZvcm1hdFN0ci5jaGFyQXQoaSkgPT0gJyMnIHx8IGZvcm1hdFN0ci5jaGFyQXQoaSkgPT0gJzAnKSB7XG4gICAgICAgICAgc3VmZml4ID0gZm9ybWF0U3RyLnN1YnN0cmluZyhpICsgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWZmaXg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERlY2ltYWxGb3JtYXQ7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IERlY2ltYWxGb3JtYXQ7IiwiaW1wb3J0IFJ1bGVzQ29ubmVjdCBmcm9tICcuL3J1bGVzY29ubmVjdCc7XG5pbXBvcnQgSlNPTlAgZnJvbSAnLi9qc29ucCc7XG5leHBvcnQgeyBSdWxlc0Nvbm5lY3QsIEpTT05QIH07IiwidmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLypcbiAgQSBzaW1wbGUgSlNPTlAgbG9hZGVyIHdoaWNoIHdpbGwgbWF4aW1pc2UgdGhlIHVzZSBvZiBjYWNoZWQgZGF0YS5cbiAgVXNlcyBFUzIwMTUgUHJvbWlzZXMuXG5cbiAgZS5nLlxuXG4gIG5ldyBKU09OUCgpLmdldChcImh0dHA6Ly9leGFtcGxlLmNvbS9qc29ucFwiKS50aGVuKChkYXRhKT0+eyAuLi4gfSk7XG4qL1xuaW1wb3J0IFBvb2wgZnJvbSAnLi9wb29sJztcblxudmFyIEpTT05QID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBKU09OUChjYWxsYmFja05hbWUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTlApO1xuXG4gICAgdGhpcy5fY2FsbGJhY2tOYW1lID0gY2FsbGJhY2tOYW1lIHx8ICdyY2pzb24nO1xuICAgIHRoaXMuX3Bvb2wgPSBuZXcgUG9vbCgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEpTT05QLCBbe1xuICAgIGtleTogJ2NyZWF0ZVNjcmlwdEVsZW1lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTY3JpcHRFbGVtZW50KHVybCwgZXJyb3JIYW5kbGVyKSB7XG4gICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXG4gICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZXJyb3JIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGV4KSB7XG4gICAgICAgICAgZXJyb3JIYW5kbGVyKHsgdXJsOiB1cmwsIGV2ZW50OiBleCB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZG9uZSAmJiAoIXRoaXMucmVhZHlTdGF0ZSB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFwibG9hZGVkXCIgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgIGlmIChzY3JpcHQgJiYgc2NyaXB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgICAgdGhpcy5faGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICB9XG4gICAgICB0aGlzLl9oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cbiAgICAgIHJldHVybiBzY3JpcHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KHVybCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHF1ZXJ5ID0gKHVybCB8fCAnJykuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJztcbiAgICAgIHZhciB0b2tlbiA9IHRoaXMuX3Bvb2wuZ2V0VG9rZW4oKTtcbiAgICAgIHZhciB1bmlxdWVOYW1lID0gdGhpcy5fY2FsbGJhY2tOYW1lICsgdG9rZW47XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgIHdpbmRvd1t1bmlxdWVOYW1lXSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVsZXRlIHdpbmRvd1t1bmlxdWVOYW1lXTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgIHdpbmRvd1t1bmlxdWVOYW1lXSA9IG51bGw7XG4gICAgICAgICAgdG9rZW4gPSBfdGhpcy5fcG9vbC5yZWxlYXNlVG9rZW4odG9rZW4pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbiBlcnJvckhhbmRsZXIob2JqKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3dbdW5pcXVlTmFtZV07XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICB3aW5kb3dbdW5pcXVlTmFtZV0gPSBudWxsO1xuICAgICAgICAgIHRva2VuID0gX3RoaXMuX3Bvb2wucmVsZWFzZVRva2VuKHRva2VuKTtcbiAgICAgICAgICByZWplY3Qob2JqKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5jcmVhdGVTY3JpcHRFbGVtZW50KHVybCArIHF1ZXJ5ICsgJ2NhbGxiYWNrPScgKyB1bmlxdWVOYW1lLCBlcnJvckhhbmRsZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIHByb21pc2UudW5pcXVlTmFtZSA9IHVuaXF1ZU5hbWU7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGxiYWNrTmFtZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tOYW1lO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKU09OUDtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgSlNPTlA7IiwidmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLypcbiAgUmVwcmVzZW50cyBhIHBvb2wgb2YgdG9rZW5zLiAgVGhlIGRlZmF1bHQgdG9rZW4gaXMgdGhlIGVtcHR5IHN0cmluZyBcIlwiLlxuICBBbGwgb3RoZXIgdG9rZW5zIGFyZSBkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbnMsIHNlcXVlbnRpYWxcbiAgZS5nLiBcIjFcIiwgXCIyXCIsIFwiM1wiIGV0Yy5cbiAgVGhlIHBvb2wgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGZyZWUgdG9rZW4uXG4qL1xuXG52YXIgUG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9vbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9vbCk7XG5cbiAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgdGhpcy5fdG9rZW5zID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUG9vbCwgW3tcbiAgICBrZXk6IFwiZ2V0VG9rZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9rZW4oKSB7XG4gICAgICB2YXIgRlJFRSA9IHRydWU7XG5cbiAgICAgIHZhciBmcmVlSW5kZXggPSAtMTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl90b2tlbnNbaV0gPT0gRlJFRSkge1xuICAgICAgICAgIHRoaXMuX3Rva2Vuc1tpXSA9ICFGUkVFO1xuICAgICAgICAgIGZyZWVJbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZyZWVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5fdG9rZW5zLnB1c2goIUZSRUUpO1xuICAgICAgICBmcmVlSW5kZXggPSB0aGlzLl90b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyZWVJbmRleCA9PT0gMCkgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gXCJcIiArIGZyZWVJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVsZWFzZVRva2VuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbGVhc2VUb2tlbih0b2tlbikge1xuICAgICAgdmFyIEZSRUUgPSB0cnVlO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIGlmICh0b2tlbiA9PT0gXCJcIikge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IHBhcnNlSW50KHRva2VuLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaW5kZXgpICYmIGluZGV4ID49IDApIHtcbiAgICAgICAgdGhpcy5fdG9rZW5zW2luZGV4XSA9IEZSRUU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIm5vdG9rZW5cIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9vbDtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgUG9vbDsiLCJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogUmVzb3VyY2VCdW5kbGUgZm9yIFJ1bGVzQ29ubmVjdFxuICpcbiAqIFRoZSBSZXNvdXJjZUJ1bmRsZSBjbGFzcyBwYXJzZXMgdGhlIEpTT04gb2JqZWN0IHJlY2VpdmVkIGZyb20gdGhlXG4gKiBSdWxlc0Nvbm5lY3QgQVBJIGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgSmF2YVNjcmlwdCBmcmllbmRseSBvYmplY3QuXG4gKlxuICogS2V5cyBpbiB0aGUgcmVzb3VyZSBidW5kbGUgd2hpY2ggY29udGFpbiBkb3Qgbm90YXRpb24gYXJlIGNvbnZlcnRlZFxuICogaW50byBuZXN0ZWQgb2JqZWN0cyB3aGljaCBjYW4gYmUgYWNjZXNzZWQgaW4gdGhlIHVzdWFsIEphdmFTY3JpcHQvSlNPTlxuICogbm90YXRpb24uXG4gKlxuICogS2V5cyB3aGljaCBjb250YWluIGludGVnZXJzIGluIHRoZSBkb3Qgbm90YXRpb24gKGl0ZW0uMS5rZXkpIHdpbGwgYmUgdHJlYXRlZFxuICogYXMgYXJyYXlzIGUuZy4gaXRlbVsxXS5rZXlcbiAqXG4gKiBGb3IgZXhhbXBsZSxcbiAqXG4gKiAgICAgXCJiYW5uZXIuc2hhcmUuMC50aXRsZVwiOiBcIkZBQ0VCT09LXCIsXG4gKiAgICAgXCJiYW5uZXIuc2hhcmUuMC51cmxcIjogXCJodHRwOi8vd3d3LmZhY2Vib29rLmNvbS9KYWd1YXJcIixcbiAqICAgICBcImJhbm5lci5zaGFyZS4xLnRpdGxlXCI6IFwiRkxJQ0tSXCIsXG4gKiAgICAgXCJiYW5uZXIuc2hhcmUuMS51cmxcIjogXCJodHRwOi8vd3d3LmZsaWNrci5jb20vcGhvdG9zL2phZ3Vhcl9jYXJzL1wiLFxuICpcbiAqIEJlY29tZXMsXG4gKiAgICAgYmFubmVyOiB7XG4gKiAgICAgICBzaGFyZTogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgIHRpdGxlOiBcIkZBQ0VCT09LXCIsXG4gKiAgICAgICAgICAgIHVybDogXCJodHRwOi8vd3d3LmZhY2Vib29rLmNvbS9KYWd1YXJcIlxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgIHRpdGxlOiBcIkZMSUNLUlwiLFxuICogICAgICAgICAgICB1cmw6IFwiaHR0cDovL3d3dy5mbGlja3IuY29tL3Bob3Rvcy9qYWd1YXJfY2Fycy9cIlxuICogICAgICAgICB9XG4gKiAgICAgICBdXG4gKiAgICB9XG4gKlxuICogVGhpcyBtZWFucyB5b3UgY2FuIGFjY2VzcyB0aGUgdmFsdWVzIHdpdGgsXG4gKiAgICAgYmFubmVyLnNoYXJlWzBdLnRpdGxlXG4gKlxuICogRWFjaCBvYmplY3QgaW4gdGhlIHRyZWUgaXMgYSBSZXNvdXJjZUJ1bmRsZS4gIFRoaXMgbWVhbnMgaXQgc3VwcG9ydHMgdGhlXG4gKiBtZXNzYWdlKGtleSwgLi4uYXJncykgZnVuY3Rpb24gZm9yIHRva2VuIHJlcGxhY2VtZW50LiAgVG9rZW5zIGNhbiB0YWtlIHRoZVxuICogZm9ybSBvZiB7MH0gb3IgaW4gUnVsZXNDb25uZWN0LCBtb3JlIGNvbW1vbmx5ICQkMCQkLlxuICpcbiAqICAgIHZhciBidW5kbGUgPSBSZXNvdXJjZUJ1bmNsZSh7XCJzaGFyZS5rZXlcIjogXCJNeSBuYW1lIGlzIHswfSAkJDEkJFwifSk7XG4gKiAgICBidW5kbGUubWVzc2FnZSgnc2hhcmUua2V5JywgJ1RvbnknLCAnVGlnZXInKSA6IFwiTXkgbmFtZSBpcyBUb255IFRpZ2VyXCJcbiAqXG4gKiBBbHRob3VnaCBub3QgcmVjb21tZW5kZWQsIGlmIGEga2V5IGhhcyBhIHZhbHVlIEFORCBpcyBhbHNvIGFuIGFycmF5LFxuICogdGhpcyBpcyBoYW5kbGVkLlxuICpcbiAqIGUuZy5cbiAqXG4gKiAgICBcImJ1bmRsZS5rZXlcIjpcInZhbHVlXCIsXG4gKiAgICBcImJ1bmRsZS5rZXkuMFwiOlwib25lXCJcbiAqXG4gKiBiZWNvbWVzLFxuICpcbiAqICAgIHsgYnVuZGxlLmtleTogW1wib25lXCJdIH1cbiAqICAgIC4uLiBidXQgW1wib25lXCJdLl9fZGVmYXVsdCA9PSBcInZhbHVlXCJcbiAqXG4gKiAxKSB0b1N0cmluZyBvZiB0aGUgYXJyYXkgd2lsbCByZXR1cm4gdGhlIGFzc2lnbmVkICd2YWx1ZScuXG4gKiAyKSBBIF9fZGVmYXVsdCBwcm9wZXJ0eSBvZiB0aGUgYXJyYXkgY29udGFpbnMgdGhlIGFzc2lnbmVkICd2YWx1ZScuXG4gKiAzKSBUaGUgb2JqZWN0IHdpbGwgYmUgYW4gYXJyYXkuXG4gKlxuICovXG5cbmZ1bmN0aW9uIF9pc0xhc3QoaSwgYXJyKSB7XG4gIHJldHVybiBpID09PSBhcnIubGVuZ3RoIC0gMTtcbn1cblxuZnVuY3Rpb24gX2lzSW50ZWdlcihzdHIpIHtcbiAgcmV0dXJuICgvXlxcZCskLy50ZXN0KHN0cilcbiAgKTtcbn1cblxuZnVuY3Rpb24gX3RvU3RyaW5nKG9iaikge1xuICBpZiAodHlwZW9mIG9iai5fX2RlZmF1bHQgPT09ICdzdHJpbmcnKSByZXR1cm4gb2JqLl9fZGVmYXVsdDtlbHNlIHJldHVybiAnUmVzb3VyY2VCdW5kbGUgJyArIEpTT04uc3RyaW5naWZ5KG9iaik7XG59XG5cbmZ1bmN0aW9uIF9tZXNzYWdlKG9iaiwga2V5KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIHZhbHVlID0ga2V5LnNwbGl0KCcuJykucmVkdWNlKGZ1bmN0aW9uIChidW5kbGUsIGtleSkge1xuICAgIHJldHVybiBidW5kbGUgPyBidW5kbGVba2V5XSA6IGJ1bmRsZTtcbiAgfSwgb2JqKTtcbiAgaWYgKCh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdfX2RlZmF1bHQnKSkge1xuICAgIHZhbHVlID0gdmFsdWUuX19kZWZhdWx0O1xuICB9XG4gIHZhciByZXN1bHQgPSAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0JyA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuXG4gIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxce1wiICsgaSArIFwiXFxcXH1cIiwgXCJnXCIpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2ldO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXCRcXFxcJFwiICsgaSArIFwiXFxcXCRcXFxcJFwiLCBcImdcIiksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbaV07XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBfbG9vcChpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlQXJyYXkoX19kZWZhdWx0KSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgYXJyLm1lc3NhZ2UgPSBmdW5jdGlvbiAobmV4dGtleSkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9tZXNzYWdlKGFyciwgbmV4dGtleSwgYXJncyk7XG4gIH07XG4gIGFyci50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nKGFycik7XG4gIH07XG4gIGlmICh0eXBlb2YgX19kZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGFyci5fX2RlZmF1bHQgPSBfX2RlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZU9iamVjdE9yQXJyYXkoa2V5cywgaSwgX19kZWZhdWx0KSB7XG4gIGlmIChfaXNJbnRlZ2VyKGtleXNbaSArIDFdKSkge1xuICAgIHJldHVybiBfY3JlYXRlQXJyYXkoX19kZWZhdWx0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFJlc291cmNlQnVuZGxlKHR5cGVvZiBfX2RlZmF1bHQgPT09ICd1bmRlZmluZWQnID8ge30gOiB7IF9fZGVmYXVsdDogX19kZWZhdWx0IH0pO1xuICB9XG59XG5cbnZhciBSZXNvdXJjZUJ1bmRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVzb3VyY2VCdW5kbGUoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc291cmNlQnVuZGxlKTtcblxuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBfdHlwZW9mKG9ialtrZXldKSAhPT0gJ29iamVjdCcgPyBvYmpba2V5XSA6IG5ldyBSZXNvdXJjZUJ1bmRsZShvYmpba2V5XSk7XG5cbiAgICAgIGtleS5zcGxpdCgnLicpLnJlZHVjZShmdW5jdGlvbiAoYnVuZGxlLCBrZXksIGksIGtleXMpIHtcbiAgICAgICAgaWYgKF9pc0xhc3QoaSwga2V5cykpIHtcbiAgICAgICAgICBpZiAoX3R5cGVvZihidW5kbGVba2V5XSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBidW5kbGVba2V5XS5fX2RlZmF1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVuZGxlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJ1bmRsZVtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGJ1bmRsZVtrZXldID0gX2NyZWF0ZU9iamVjdE9yQXJyYXkoa2V5cywgaSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihidW5kbGVba2V5XSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGJ1bmRsZVtrZXldO1xuICAgICAgICAgIGJ1bmRsZVtrZXldID0gX2NyZWF0ZU9iamVjdE9yQXJyYXkoa2V5cywgaSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidW5kbGVba2V5XTtcbiAgICAgIH0sIF90aGlzKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXNvdXJjZUJ1bmRsZSwgW3tcbiAgICBrZXk6ICdtZXNzYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVzc2FnZShrZXkpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9tZXNzYWdlLmFwcGx5KHVuZGVmaW5lZCwgW3RoaXMsIGtleV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIF90b1N0cmluZyh0aGlzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVzb3VyY2VCdW5kbGU7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IFJlc291cmNlQnVuZGxlOyIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBSdWxlc0Nvbm5lY3QgSlNPTlAgSGFuZGxpbmcgdjIuMC4wXG4gKlxuICogVW5saWtlIHYxLCB0aGlzIHZlcnNpb24gdXNlcyBFUzIwMTU7IGRvZXMgbm90IHVzZSAkLmFqYXguXG4gKlxuICogRG9lcyBub3QgcmVxdWlyZSBhbnkgZXh0ZXJuYWwgbGlicmFyeSB0byBmdW5jdGlvbi5cbiAqXG4gKiBUbyBsb2FkIHNvbWUgUnVsZXNDb25uZWN0IEpTT05QIHNpbXBseSBjYWxsLFxuICpcbiAqICAgICByYy5sb2FkSnNvbnAoXCJodHRwOi8vcnVsZXMuY29uZmlndXJlY29ubmVjdC5jb20vcmMvamFnL2diL3Jlc291cmNlcy5qc29ucFwiKVxuICogICAgICAgLnRoZW4oKGRhdGEpPT57XG4gKiAgICAgICAgIGFsZXJ0KGRhdGEubWV0YWRhdGEubWV0YVtcInVybFwiXSk7XG4gKiAgICAgICB9KS5jYXRjaCgoKT0+e1xuICogICAgICAgICBhbGVydChcIm9oIG5vIGFuIGVycm9yIG9jY3VycmVkXCIpO1xuICogICAgICAgfSk7XG4gKlxuICogVG8gbG9hZCB0cmFuc2xhdGlvbnMvcmVzb3VyY2UgYnVuZGxlLCB1c2VcbiAqXG4gKiAgICAgcmMubG9hZFJlc291cmNlcyhcImphZ1wiLFwiZW5fZ2JcIiwgXCJodHRwOi8vcnVsZXMuY29uZmlnLmphZ3Vhci5jb21cIik7XG4gKlxuICogT3IsXG4gKlxuICogICAgIHJjLmxvYWRSZXNvdXJjZXMoXCJodHRwOi8vcnVsZXMuY29uZmlnLmphZ3Vhci5jb20vcmMvamFnL2VuX2diL3Jlc291cmNlcy5qc29ucFwiKTtcbiAqXG4gKiBUbyBmaW5kIG91dCBpZiB0aGVyZSBhcmUgYW55IHJlc291cmNlcyBsb2FkZWQsIHVzZSxcbiAqXG4gKiAgICAgcmMuaGFzUmVzb3VyY2VzKCk7XG4gKlxuICogVG8gb2J0YWluIHJlc291cmNlcywgcHJvcGVydGllcyBhbmQgbWV0YWRhdGEgZnJvbSB0aGUgUmVzb3VyY2UgQnVuZGxlIHVzZSxcbiAqICAgICByYy5nZXRSZXNvdXJjZShrZXkpO1xuICogICAgIHJjLmdldFByb3BlcnR5KGtleSk7XG4gKiAgICAgcmMuZ2V0TWV0YURhdGEoa2V5KTtcbiAqXG4gKiBUbyByZXBsYWNlIG5vdW5zIGluIHRoZSByZXNvdXJjZSBidW5kbGUgLS0gaWRlbnRpZmllZCBieSB7MH0gb3IgJCQxJCQgc3R5bGUgdG9rZW5zLFxuICogICAgIHJjLmdldFJlc291cmNlKGtleSwgXCJhcmcwXCIsIFwiYXJnMVwiKTtcbiAqXG4gKiBUbyByZWdpc3RlciBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSByZXNvdXJjZS9pMThuIGRhdGEgaGFzIGxvYWRlZCwgdXNlLFxuICogICAgIHJjLm9uUmVzb3VyY2VSZWFkeSgpLnRoZW4oKCk9PiB7ICAuLi4gIH0pO1xuICpcbiAqKi9cblxuaW1wb3J0IEpTT05QIGZyb20gJy4vanNvbnAnO1xuaW1wb3J0IERlY2ltYWxGb3JtYXQgZnJvbSAnLi9kZWNpbWFsZm9ybWF0JztcbmltcG9ydCBSZXNvdXJjZUJ1bmRsZSBmcm9tICcuL3Jlc291cmNlYnVuZGxlJztcblxudmFyIFJ1bGVzQ29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUnVsZXNDb25uZWN0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUnVsZXNDb25uZWN0KTtcblxuICAgIHRoaXMuX2pzb25wID0gbmV3IEpTT05QKCdyY2pzb24nKTtcbiAgICB0aGlzLl9yZXNvdXJjZXMgPSBudWxsO1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBudWxsO1xuICAgIHRoaXMuX21ldGFEYXRhID0gbnVsbDtcbiAgICB0aGlzLl9sYW5ndWFnZSA9IG51bGw7XG4gICAgdGhpcy5faTE4blByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBfdGhpcy5faTE4blJlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIHRoaXMuX2N1cnJlbmN5Rm9ybWF0cyA9IHt9O1xuICAgIHRoaXMuX2RlZmF1bHRDdXJyZW5jeSA9IFwiZGVmYXVsdFwiO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJ1bGVzQ29ubmVjdCwgW3tcbiAgICBrZXk6ICdzZXRSZXNvdXJjZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSZXNvdXJjZXMoaTE4bikge1xuICAgICAgdGhpcy5fcmVzb3VyY2VzID0gbmV3IFJlc291cmNlQnVuZGxlKChpMThuW1wicmVzb3VyY2UtYnVuZGxlXCJdIHx8IHt9KVtcImNsaWVudC1yZXNvdXJjZXNcIl0pO1xuICAgICAgdGhpcy5fcHJvcGVydGllcyA9IG5ldyBSZXNvdXJjZUJ1bmRsZSgoaTE4bltcInJlc291cmNlLWJ1bmRsZVwiXSB8fCB7fSlbXCJjbGllbnQtcHJvcGVydGllc1wiXSk7XG4gICAgICB0aGlzLl9tZXRhRGF0YSA9IG5ldyBSZXNvdXJjZUJ1bmRsZSgoaTE4bltcIm1ldGFkYXRhXCJdIHx8IHt9KVtcIm1ldGFcIl0pO1xuICAgICAgdGhpcy5fbGFuZ3VhZ2UgPSAoaTE4bltcInJlc291cmNlLWJ1bmRsZVwiXSB8fCB7fSkubGFuZ3VhZ2U7XG4gICAgICB0aGlzLl9pMThuUmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRSZXNvdXJjZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkUmVzb3VyY2VzKGFwcCwgbG9jYWxlLCBiYXNlVXJsKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHVybDtcbiAgICAgIGlmICh0eXBlb2YgYmFzZVVybCA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbG9jYWxlID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhcHAgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJsID0gYXBwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiYXNlVXJsICE9PSBcInN0cmluZ1wiKSBiYXNlVXJsID0gXCJcIjtcbiAgICAgICAgdXJsID0gYmFzZVVybCArIFwiL3JjL1wiICsgYXBwICsgXCIvXCIgKyBsb2NhbGUgKyBcIi9yZXNvdXJjZXMuanNvbnBcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9yZ1Byb21pc2UgPSB0aGlzLmxvYWRKc29ucCh1cmwpO1xuICAgICAgdmFyIGNoYWluUHJvbWlzZSA9IG9yZ1Byb21pc2UudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBfdGhpczIuc2V0UmVzb3VyY2VzKGRhdGEpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0pO1xuXG4gICAgICBjaGFpblByb21pc2UudW5pcXVlTmFtZSA9IG9yZ1Byb21pc2UudW5pcXVlTmFtZTtcbiAgICAgIHJldHVybiBjaGFpblByb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFzUmVzb3VyY2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUmVzb3VyY2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc291cmNlcyAhPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRKc29ucCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRKc29ucCh1cmwpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgb3JnUHJvbWlzZSA9IHRoaXMuX2pzb25wLmdldCh1cmwpO1xuICAgICAgdmFyIGNoYWluUHJvbWlzZSA9IG9yZ1Byb21pc2UudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBfdGhpczMucmVhZEN1cnJlbmN5Rm9ybWF0cyhkYXRhKTtcbiAgICAgICAgX3RoaXMzLmRldGVjdERlZmF1bHRDdXJyZW5jeShkYXRhKTtcbiAgICAgICAgX3RoaXMzLm92ZXJsYXlSZXNvdXJjZXNXaXRoUmVzcG9uc2UoZGF0YSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSk7XG5cbiAgICAgIGNoYWluUHJvbWlzZS51bmlxdWVOYW1lID0gb3JnUHJvbWlzZS51bmlxdWVOYW1lO1xuICAgICAgcmV0dXJuIGNoYWluUHJvbWlzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvdmVybGF5UmVzb3VyY2VzV2l0aFJlc3BvbnNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcmxheVJlc291cmNlc1dpdGhSZXNwb25zZShhcGlSZXNwb25zZSkge1xuICAgICAgaWYgKHRoaXMuX3Jlc291cmNlcykge1xuICAgICAgICB2YXIgdmVoaWNsZVByb3BlcnRpZXMgPSAoKGFwaVJlc3BvbnNlWydmZWF0dXJlLWRpY3Rpb25hcnknXSB8fCB7fSkudmVoaWNsZSB8fCB7fSkucHJvcGVydHkgfHwge307XG4gICAgICAgIHZhciBuZXdSZXNvdXJjZXMgPSBuZXcgUmVzb3VyY2VCdW5kbGUodmVoaWNsZVByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLnRyYXZlcnNlUmVzb3VyY2VUcmVlKG5ld1Jlc291cmNlcywgdGhpcy5fcmVzb3VyY2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsZWZ0ID0gbmV3IGRhdGEgbW9kZWwgb3ZlcnJpZGVzXG4gICAgLy8gcmlnaHQgPSBvbGQgcmVzb3VyY2UgYnVuZGxlXG5cbiAgfSwge1xuICAgIGtleTogJ3RyYXZlcnNlUmVzb3VyY2VUcmVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhdmVyc2VSZXNvdXJjZVRyZWUobGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBPYmplY3Qua2V5cyhsZWZ0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiByaWdodCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGVmdFtrZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmlnaHRba2V5XSA9IGxlZnRba2V5XTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByaWdodFtrZXldID09PSAnc3RyaW5nJyAmJiBfdHlwZW9mKGxlZnRba2V5XSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByaWdodFtrZXldID0gbGVmdFtrZXldW190aGlzNC5sYW5ndWFnZV07XG4gICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGxlZnRba2V5XSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBfdGhpczQudHJhdmVyc2VSZXNvdXJjZVRyZWUobGVmdFtrZXldLCByaWdodFtrZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZWZ0W2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByaWdodFtrZXldID0gbGVmdFtrZXldO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihsZWZ0W2tleV0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gRGV0ZWN0IGl0J3MgYW4gb2JqZWN0IGJlY2F1c2UgaXQncyBhIG11bHRpIGxhbmd1YWdlIHByb3BlcnR5IG9yIGlmIGl0J3MganVzdCBkb3Qgc2VwYXJhdGVkLlxuICAgICAgICAgICAgaWYgKGxlZnRba2V5XVtfdGhpczQubGFuZ3VhZ2VdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmlnaHRba2V5XSA9IGxlZnRba2V5XVtfdGhpczQubGFuZ3VhZ2VdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmlnaHRba2V5XSA9IHt9O1xuICAgICAgICAgICAgICBfdGhpczQudHJhdmVyc2VSZXNvdXJjZVRyZWUobGVmdFtrZXldLCByaWdodFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlYWRDdXJyZW5jeUZvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkQ3VycmVuY3lGb3JtYXRzKGRhdGEpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9jdXJyZW5jeUZvcm1hdHMpLmxlbmd0aCA9PSAwICYmIHR5cGVvZiBkYXRhICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBmb3JtYXRTdHIgPSAoKGRhdGFbXCJtZXRhZGF0YVwiXSB8fCB7fSlbXCJtZXRhXCJdIHx8IHt9KVtcImN1cnJlbmN5LWZvcm1hdFwiXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXRTdHIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YXIgZm9ybWF0QXJyID0gZm9ybWF0U3RyLnRyaW0oKS5zcGxpdChcIn5cIik7XG4gICAgICAgICAgdmFyIGZvcm1hdE1hcCA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybWF0QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IGZvcm1hdEFycltpXS5zcGxpdChcIj1cIiwgMik7XG4gICAgICAgICAgICBpZiAocGFpci5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICBmb3JtYXRNYXBbXCJkZWZhdWx0XCJdID0gbmV3IERlY2ltYWxGb3JtYXQocGFpclswXS50cmltKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhaXIubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgdmFyIGRmID0gbmV3IERlY2ltYWxGb3JtYXQocGFpclsxXS50cmltKCkpO1xuICAgICAgICAgICAgICBmb3JtYXRNYXBbcGFpclswXS50b1VwcGVyQ2FzZSgpXSA9IGRmO1xuICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0TWFwW1wiZGVmYXVsdFwiXSA9IGRmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbmN5Rm9ybWF0cyA9IGZvcm1hdE1hcDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXRlY3REZWZhdWx0Q3VycmVuY3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlY3REZWZhdWx0Q3VycmVuY3koZGF0YSkge1xuICAgICAgdmFyIHVybFN0ciA9IChkYXRhW1wibWV0YWRhdGFcIl0gfHwge30pW1widXJsXCJdO1xuICAgICAgaWYgKHR5cGVvZiB1cmxTdHIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gdXJsU3RyLnNwbGl0KFwiL1wiLCA1KTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgdmFyIGxvY2FsZVN0ciA9IHBhcnRzWzNdO1xuICAgICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVTdHIuc3BsaXQoXCJfXCIsIDMpO1xuICAgICAgICAgIGlmIChsb2NhbGUubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW5jeSA9IGxvY2FsZVsyXTtcbiAgICAgICAgICAgIHZhciBpbmRleE9mRG90ID0gY3VycmVuY3kuaW5kZXhPZihcIi5cIik7XG4gICAgICAgICAgICBpZiAoaW5kZXhPZkRvdCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgY3VycmVuY3kgPSBjdXJyZW5jeS5zdWJzdHIoMCwgaW5kZXhPZkRvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0Q3VycmVuY3kgPSBjdXJyZW5jeS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZGVmYXVsdEN1cnJlbmN5ID0gXCJkZWZhdWx0XCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Rm9ybWF0dGVkUHJpY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRQcmljZShwcmljZSwgY3VycmVuY3kpIHtcbiAgICAgIGN1cnJlbmN5ID0gY3VycmVuY3kgfHwgdGhpcy5fZGVmYXVsdEN1cnJlbmN5O1xuICAgICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuX2N1cnJlbmN5Rm9ybWF0c1tjdXJyZW5jeV0gfHwgdGhpcy5fY3VycmVuY3lGb3JtYXRzW1wiZGVmYXVsdFwiXTtcblxuICAgICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChwcmljZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIlwiICsgcHJpY2U7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBhZGQgZGF0ZSBmb3JtYXR0aW5nIGhlcmVcblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Rm9ybWF0dGVkRGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvcm1hdHRlZERhdGUoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIGRhdGVPYmoudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25SZXNvdXJjZVJlYWR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25SZXNvdXJjZVJlYWR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2kxOG5Qcm9taXNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc291cmNlcycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2VzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xhbmd1YWdlJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYW5ndWFnZTtcbiAgICB9XG5cbiAgICAvLyBnZXRSZXNvdXJjZShrZXksIC4uLmFyZ3MpIHtcbiAgICAvLyAgIHZhciByZXN1bHQ9bnVsbDtcbiAgICAvLyAgIGlmKHRoaXMuX3Jlc291cmNlcyE9bnVsbCkge1xuICAgIC8vICAgICByZXN1bHQgPSB0aGlzLl9yZXNvdXJjZXNba2V5XTtcbiAgICAvL1xuICAgIC8vICAgICBpZih0eXBlb2YgcmVzdWx0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gICAgICAgZm9yKGxldCBpPTA7IGk8YXJncy5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFx7XCIraStcIlxcXFx9XCIsIFwiZ1wiKSwgYXJnc1tpXSk7XG4gICAgLy8gICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXCRcXFxcJFwiK2krXCJcXFxcJFxcXFwkXCIsIFwiZ1wiKSwgYXJnc1tpXSk7XG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICB9XG4gICAgLy9cbiAgICAvL1xuICAgIC8vICAgcmV0dXJuIHJlc3VsdDtcbiAgICAvLyB9XG5cbiAgfSwge1xuICAgIGtleTogJ3Byb3BlcnRpZXMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWV0YURhdGEnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21ldGFEYXRhO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSdWxlc0Nvbm5lY3Q7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IFJ1bGVzQ29ubmVjdDsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbWFwXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1uYW5cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9wcm9taXNlXCIpO1xuXG52YXIgX3Byb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvbWlzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBuZXcgX3Byb21pc2UyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gc3RlcChrZXksIGFyZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc3RlcChcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGVwKFwibmV4dFwiKTtcbiAgICB9KTtcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9hc3NpZ25cIik7XG5cbnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9hc3NpZ24yLmRlZmF1bHQgfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sXCIpO1xuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkFycmF5LmZyb207XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yJyk7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUnKTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5tYXAub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5NYXA7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5OdW1iZXIuaXNOYU47XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Qua2V5cztcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnByb21pc2UudHJ5Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5Qcm9taXNlO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlciwgSVRFUkFUT1IpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JPZihpdGVyLCBmYWxzZSwgcmVzdWx0LnB1c2gsIHJlc3VsdCwgSVRFUkFUT1IpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcbiIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgZWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKSB7XG4gIHZhciBCYXNlID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgQyA9IEJhc2U7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBwcm90byA9IEMgJiYgQy5wcm90b3R5cGU7XG4gIHZhciBPID0ge307XG4gIGlmICghREVTQ1JJUFRPUlMgfHwgdHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSwgJ19jJyk7XG4gICAgICB0YXJnZXQuX2MgPSBuZXcgQmFzZSgpO1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGFyZ2V0W0FEREVSXSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBlYWNoKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04nLnNwbGl0KCcsJyksIGZ1bmN0aW9uIChLRVkpIHtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG4gICAgICBpZiAoS0VZIGluIHByb3RvICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gJ2NsZWFyJykpIGhpZGUoQy5wcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBDLCBLRVkpO1xuICAgICAgICBpZiAoIUlTX0FEREVSICYmIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpKSByZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIElTX1dFQUsgfHwgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYsIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMycgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBrZXkgaW4gZXhwb3J0cykgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAoIUJVR0dZICYmICRuYXRpdmUpIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG4iLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyBTYWZhcmkgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIgJiYgIShnbG9iYWwubmF2aWdhdG9yICYmIGdsb2JhbC5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpIHtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZiAoIWhlYWQpIHtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxuZnVuY3Rpb24gUHJvbWlzZUNhcGFiaWxpdHkoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcbiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAoc2FmZSAmJiB0YXJnZXRba2V5XSkgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICBlbHNlIGhpZGUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfSByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBmcm9tOiBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcEZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG1hcEZuID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwaW5nLCBBLCBuLCBjYjtcbiAgICBhRnVuY3Rpb24odGhpcyk7XG4gICAgbWFwcGluZyA9IG1hcEZuICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1hcHBpbmcpIGFGdW5jdGlvbihtYXBGbik7XG4gICAgaWYgKHNvdXJjZSA9PSB1bmRlZmluZWQpIHJldHVybiBuZXcgdGhpcygpO1xuICAgIEEgPSBbXTtcbiAgICBpZiAobWFwcGluZykge1xuICAgICAgbiA9IDA7XG4gICAgICBjYiA9IGN0eChtYXBGbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIGZ1bmN0aW9uIChuZXh0SXRlbSkge1xuICAgICAgICBBLnB1c2goY2IobmV4dEl0ZW0sIG4rKykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIEEucHVzaCwgQSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgQSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkgQVtsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSB0eXBlb2YgY29yZVtLRVldID09ICdmdW5jdGlvbicgPyBjb3JlW0tFWV0gOiBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG4iLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUWVBFKSB7XG4gIGlmICghaXNPYmplY3QoaXQpIHx8IGl0Ll90ICE9PSBUWVBFKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldCA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5pc0l0ZXJhYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1JdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICB8fCBJdGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY2xhc3NvZihPKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikgeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBNQVAgPSAnTWFwJztcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoTUFQLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgTUFQKSwga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuIiwiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcbiIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mIH0pO1xuIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIHByb21pc2UuX2ggIT09IDEgJiYgKHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYykubGVuZ3RoID09PSAwO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbic7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnTWFwJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHsgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnTWFwJykgfSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLWZpbmFsbHlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdQcm9taXNlJywgeyAnZmluYWxseSc6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKTtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2Ygb25GaW5hbGx5ID09ICdmdW5jdGlvbic7XG4gIHJldHVybiB0aGlzLnRoZW4oXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSk7XG4gICAgfSA6IG9uRmluYWxseSxcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IGU7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHlcbiAgKTtcbn0gfSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLXRyeVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1Byb21pc2UnLCB7ICd0cnknOiBmdW5jdGlvbiAoY2FsbGJhY2tmbikge1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gcGVyZm9ybShjYWxsYmFja2ZuKTtcbiAgKHJlc3VsdC5lID8gcHJvbWlzZUNhcGFiaWxpdHkucmVqZWN0IDogcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZSkocmVzdWx0LnYpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn0gfSk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxudmFyIERPTUl0ZXJhYmxlcyA9ICgnQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCwnICtcbiAgJ0RPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsJyArXG4gICdNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LCcgK1xuICAnU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsJyArXG4gICdUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCcpLnNwbGl0KCcsJyk7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgRE9NSXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gRE9NSXRlcmFibGVzW2ldO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTb21lO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBiYXNlSXNNYXRjaCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hdGNoJyksXG4gICAgZ2V0TWF0Y2hEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWF0Y2hEYXRhJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlcztcbiIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyksXG4gICAgZ2V0ID0gcmVxdWlyZSgnLi9nZXQnKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVIYXM7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRmluZDtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9fYXJyYXlTb21lJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQXJyYXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwidmFyIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBjcmVhdGVGaW5kID0gcmVxdWlyZSgnLi9fY3JlYXRlRmluZCcpLFxuICAgIGZpbmRJbmRleCA9IHJlcXVpcmUoJy4vZmluZEluZGV4Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICovXG52YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRmluaXRlO1xuIiwidmFyIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvSW50ZWdlcjtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsIGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaCAoZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIER4QWNjb3JkaW9uIHtcbiAgY29uc3RydWN0b3IoZWwpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbDtcbiAgICB0aGlzLmFsbG93TXVsdGlwbGUgPSBlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtYWxsb3ctbXVsdGlwbGUnKTtcbiAgICB0aGlzLnNlY3Rpb25zID0gZWwucXVlcnlTZWxlY3RvckFsbCgnLmR4QWNjb3JkaW9uX19zZWN0aW9uJyk7XG5cbiAgICB0aGlzLm9wZW5BY2NvcmRpb24odGhpcy5zZWN0aW9uc1swXSwgMCk7XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRoaXMuc2VjdGlvbnMsIChzZWN0aW9uLCBpKSA9PiB7XG4gICAgICBjb25zdCBidXR0b24gPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5keEFjY29yZGlvbl9fdHJpZ2dlcicpO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB0aGlzLmhhbmRsZUNsaWNrKGUsIHNlY3Rpb24sIGkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKGUsIHNlY3Rpb24sIGluZGV4KSB7XG4gICAgaWYgKHNlY3Rpb24uY2xhc3NMaXN0LmNvbnRhaW5zKCdkeEFjY29yZGlvbl9fc2VjdGlvbi0tYWN0aXZlJykpIHtcbiAgICAgIER4QWNjb3JkaW9uLmNsb3NlQWNjb3JkaW9uKHNlY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW5BY2NvcmRpb24oc2VjdGlvbiwgaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIG9wZW5BY2NvcmRpb24oc2VjdGlvbiwgaW5kZXgpIHtcbiAgICBjb25zdCBidXR0b24gPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5keEFjY29yZGlvbl9fdHJpZ2dlcicpO1xuICAgIGNvbnN0IHBhbmVsID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcuZHhBY2NvcmRpb25fX3BhbmVsJyk7XG5cbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICBwYW5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2hpZGRlbicpO1xuICAgIHNlY3Rpb24uY2xhc3NMaXN0LmFkZCgnZHhBY2NvcmRpb25fX3NlY3Rpb24tLWFjdGl2ZScpO1xuXG4gICAgaWYgKCF0aGlzLmFsbG93TXVsdGlwbGUpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGhpcy5zZWN0aW9ucywgKHNlY3QsIGkpID0+IHtcbiAgICAgICAgaWYgKGkgIT09IGluZGV4ICYmIHNlY3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdkeEFjY29yZGlvbl9fc2VjdGlvbi0tYWN0aXZlJykpIHtcbiAgICAgICAgICBEeEFjY29yZGlvbi5jbG9zZUFjY29yZGlvbihzZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGNsb3NlQWNjb3JkaW9uKHNlY3Rpb24pIHtcbiAgICBjb25zdCBidXR0b24gPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5keEFjY29yZGlvbl9fdHJpZ2dlcicpO1xuICAgIGNvbnN0IHBhbmVsID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcuZHhBY2NvcmRpb25fX3BhbmVsJyk7XG5cbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgcGFuZWwuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAnJyk7XG4gICAgc2VjdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdkeEFjY29yZGlvbl9fc2VjdGlvbi0tYWN0aXZlJyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEtleUNvZGUgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZXMvZGV2L2pzL3V0aWxzL2FyaWEnO1xuaW1wb3J0IHsgZXZlbnRUcmlnZ2VyIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2VzL2Rldi9qcy91dGlscy9pbmRleCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER4RHJvcGRvd24ge1xuICBjb25zdHJ1Y3RvcihlbCwgcHJldmVudERlZmF1bHQgPSB0cnVlKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWw7XG4gICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gICAgdGhpcy5idXR0b24gPSBlbC5xdWVyeVNlbGVjdG9yKCcuZHhEcm9wZG93bl9fYnV0dG9uJyk7XG4gICAgdGhpcy5saXN0Ym94ID0gZWwucXVlcnlTZWxlY3RvcignLmR4RHJvcGRvd25fX2xpc3QnKTtcblxuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkeERyb3Bkb3duOlJlYmluZCcsICgpID0+IHRoaXMucmViaW5kTGlzdEJveCgpKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHRoaXMuY2xpY2tFdmVudExpc3RlbmVycyhlLCBwcmV2ZW50RGVmYXVsdCkpO1xuICAgIHRoaXMuYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZSA9PiB0aGlzLmNoZWNrU2hvdyhlKSk7XG4gICAgdGhpcy5saXN0Ym94LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBlID0+IHRoaXMudGVzdEJsdXIoZSkpO1xuICAgIHRoaXMubGlzdGJveC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZSA9PiB0aGlzLmtleURvd25FdmVudHMoZSkpO1xuXG4gICAgY29uc3QgZmlyc3RJdGVtID0gZWwucXVlcnlTZWxlY3RvcignLmR4RHJvcGRvd25fX2xpc3QtaXRlbS1saW5rOm5vdCguZHhEcm9wZG93bl9fbGlzdC1pdGVtLWxpbmstLWRpc2FibGVkJyk7XG4gICAgdGhpcy5hZGRBY3RpdmVEcm9wZG93bkl0ZW0oZmlyc3RJdGVtKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4gdGhpcy5oYW5kbGVXaW5kb3dDbGljayhlKSk7XG4gIH1cblxuICB0ZXN0Qmx1cihlKSB7XG4gICAgaWYgKFxuICAgICAgIWUucmVsYXRlZFRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2R4RHJvcGRvd25fX2xpc3QtaXRlbScpXG4gICAgICAmJiAhZS5yZWxhdGVkVGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZHhEcm9wZG93bl9fbGlzdC1pdGVtLWxpbmsnKVxuICAgICkge1xuICAgICAgdGhpcy5jbG9zZURyb3Bkb3duKCk7XG4gICAgfVxuICB9XG5cbiAgcmViaW5kTGlzdEJveCgpIHtcbiAgICB0aGlzLmxpc3Rib3ggPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcignLmR4RHJvcGRvd25fX2xpc3QnKTtcbiAgICB0aGlzLmxpc3Rib3guYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGUgPT4gdGhpcy50ZXN0Qmx1cihlKSk7XG4gICAgdGhpcy5saXN0Ym94LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlID0+IHRoaXMua2V5RG93bkV2ZW50cyhlKSk7XG4gIH1cblxuICBoYW5kbGVXaW5kb3dDbGljayhlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBsZXQgZWwgPSBlLnRhcmdldDtcbiAgICBsZXQgaXNEcm9wZG93bkVsID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZXMudW5zaGlmdChlbC5wYXJlbnROb2RlKTtcbiAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBpZiAobm9kZS5jbGFzc0xpc3QgJiYgbm9kZSA9PT0gdGhpcy5lbGVtZW50KSB7XG4gICAgICAgIGlzRHJvcGRvd25FbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWlzRHJvcGRvd25FbCkge1xuICAgICAgdGhpcy5jbG9zZURyb3Bkb3duKGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBjbGlja0V2ZW50TGlzdGVuZXJzKGUsIHByZXZlbnREZWZhdWx0KSB7XG4gICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gZS50YXJnZXQ7XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnZHhEcm9wZG93bl9fYnV0dG9uJykpIHtcbiAgICAgIHRoaXMudG9nZ2xlRHJvcGRvd24oKTtcbiAgICB9IGVsc2UgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnZHhEcm9wZG93bl9fbGlzdC1pdGVtLWxpbmsnKSAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdkeERyb3Bkb3duX19saXN0LWl0ZW0tbGluay0tZGlzYWJsZWQnKSkge1xuICAgICAgdGhpcy51cGRhdGVCdXR0b25UZXh0KGUpO1xuICAgICAgdGhpcy5jbG9zZURyb3Bkb3duKCk7XG4gICAgfSBlbHNlIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2R4RHJvcGRvd25fX2xpc3QtaXRlbScpICYmICFlbC5xdWVyeVNlbGVjdG9yKCcuZHhEcm9wZG93bl9fbGlzdC1pdGVtLWxpbmsnKS5jbGFzc0xpc3QuY29udGFpbnMoJ2R4RHJvcGRvd25fX2xpc3QtaXRlbS1saW5rLS1kaXNhYmxlZCcpKSB7XG4gICAgICBjb25zdCBjaGlsZExpbmsgPSBlbC5xdWVyeVNlbGVjdG9yKCcuZHhEcm9wZG93bl9fbGlzdC1pdGVtLWxpbmsnKTtcbiAgICAgIHRoaXMudXBkYXRlQnV0dG9uVGV4dChjaGlsZExpbmspO1xuICAgICAgdGhpcy5jbG9zZURyb3Bkb3duKCk7XG4gICAgfVxuICB9XG5cbiAga2V5RG93bkV2ZW50cyhlKSB7XG4gICAgY29uc3Qga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAgY29uc3Qge1xuICAgICAgRE9XTixcbiAgICAgIFVQLFxuICAgICAgRVNDLFxuICAgICAgUkVUVVJOLFxuICAgICAgVEFCXG4gICAgfSA9IEtleUNvZGU7XG5cbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBET1dOOlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubmV4dEl0ZW0oZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUI6XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICB0aGlzLnByZXZpb3VzSXRlbShlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5leHRJdGVtKGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBVUDpcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnByZXZpb3VzSXRlbShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVTQzpcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmNsb3NlRHJvcGRvd24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJFVFVSTjpcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJ1dHRvblRleHQoZSk7XG4gICAgICAgIHRoaXMuY2xvc2VEcm9wZG93bigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrU2hvdyhlKSB7XG4gICAgY29uc3Qga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAgY29uc3QgeyBVUCwgRE9XTiB9ID0gS2V5Q29kZTtcblxuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIFVQOlxuICAgICAgY2FzZSBET1dOOlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMub3BlbkRyb3Bkb3duKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdG9nZ2xlRHJvcGRvd24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMuY2xvc2VEcm9wZG93bigpIDogdGhpcy5vcGVuRHJvcGRvd24oKTtcbiAgfVxuXG4gIG9wZW5Ecm9wZG93bigpIHtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZHhEcm9wZG93bi0tYWN0aXZlJyk7XG4gICAgdGhpcy5idXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcblxuICAgIHRoaXMuZm9jdXNGaXJzdEl0ZW0oKTtcbiAgICB0aGlzLm9wZW4gPSB0cnVlO1xuICB9XG5cbiAgY2xvc2VEcm9wZG93bihzZXRGb2N1cyA9IHRydWUpIHtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZHhEcm9wZG93bi0tYWN0aXZlJyk7XG4gICAgdGhpcy5idXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgdGhpcy5vcGVuID0gZmFsc2U7XG5cbiAgICBpZiAoc2V0Rm9jdXMpIHtcbiAgICAgIHRoaXMuYnV0dG9uLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQnV0dG9uVGV4dCh0YXJnZXRFbGVtZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gKHRhcmdldEVsZW1lbnQudGFyZ2V0KSA/IHRhcmdldEVsZW1lbnQudGFyZ2V0IDogdGFyZ2V0RWxlbWVudDtcbiAgICB0aGlzLmJ1dHRvbi5pbm5lckhUTUwgPSB0YXJnZXQuaW5uZXJIVE1MO1xuICAgIHRoaXMuZmlyZUV2ZW50KCdEeERyb3Bkb3duOnVwZGF0ZScsIHtcbiAgICAgIHRhcmdldCxcbiAgICAgIHZhbHVlOiB0aGlzLmJ1dHRvbi5pbm5lckhUTUxcbiAgICB9KTtcbiAgICB0aGlzLmFkZEFjdGl2ZURyb3Bkb3duSXRlbSh0YXJnZXQpO1xuICB9XG5cbiAgbmV4dEl0ZW0oZSkge1xuICAgIGNvbnN0IGl0ZW1MaXN0ID0gdGhpcy5saXN0Ym94LnF1ZXJ5U2VsZWN0b3JBbGwoJy5keERyb3Bkb3duX19saXN0LWl0ZW0tbGluazpub3QoLmR4RHJvcGRvd25fX2xpc3QtaXRlbS1saW5rLS1kaXNhYmxlZCknKTtcblxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoaXRlbUxpc3QsIChlbCwgaSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgICBpZiAoaSA9PT0gaXRlbUxpc3QubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHRoaXMuZm9jdXNGaXJzdEl0ZW0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtTGlzdFtpICsgMV0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJldmlvdXNJdGVtKGUpIHtcbiAgICBjb25zdCBpdGVtTGlzdCA9IHRoaXMubGlzdGJveC5xdWVyeVNlbGVjdG9yQWxsKCcuZHhEcm9wZG93bl9fbGlzdC1pdGVtLWxpbms6bm90KC5keERyb3Bkb3duX19saXN0LWl0ZW0tbGluay0tZGlzYWJsZWQpJyk7XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGl0ZW1MaXN0LCAoZWwsIGkpID0+IHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmZvY3VzTGFzdEl0ZW0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtTGlzdFtpIC0gMV0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZm9jdXNGaXJzdEl0ZW0oKSB7XG4gICAgY29uc3QgZmlyc3RJdGVtID0gdGhpcy5saXN0Ym94LnF1ZXJ5U2VsZWN0b3IoJy5keERyb3Bkb3duX19saXN0LWl0ZW0tbGluazpub3QoLmR4RHJvcGRvd25fX2xpc3QtaXRlbS1saW5rLS1kaXNhYmxlZCknKTtcblxuICAgIGZpcnN0SXRlbS5mb2N1cygpO1xuICB9XG5cbiAgZm9jdXNMYXN0SXRlbSgpIHtcbiAgICBjb25zdCBpdGVtTGlzdCA9IHRoaXMubGlzdGJveC5xdWVyeVNlbGVjdG9yQWxsKCcuZHhEcm9wZG93bl9fbGlzdC1pdGVtLWxpbms6bm90KC5keERyb3Bkb3duX19saXN0LWl0ZW0tbGluay0tZGlzYWJsZWQpJyk7XG5cbiAgICBpZiAoaXRlbUxpc3QubGVuZ3RoKSB7XG4gICAgICBpdGVtTGlzdFtpdGVtTGlzdC5sZW5ndGggLSAxXS5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIGFkZEFjdGl2ZURyb3Bkb3duSXRlbShlbCkge1xuICAgIGNvbnN0IGFjdGl2ZUVsID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5keERyb3Bkb3duX19saXN0LWl0ZW0tbGluay0tYWN0aXZlOm5vdCguZHhEcm9wZG93bl9fbGlzdC1pdGVtLWxpbmstLWRpc2FibGVkKScpO1xuXG4gICAgaWYgKGFjdGl2ZUVsICE9PSBudWxsKSB7XG4gICAgICBhY3RpdmVFbC5jbGFzc0xpc3QucmVtb3ZlKCdkeERyb3Bkb3duX19saXN0LWl0ZW0tbGluay0tYWN0aXZlJyk7XG4gICAgfVxuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2R4RHJvcGRvd25fX2xpc3QtaXRlbS1saW5rLS1hY3RpdmUnKTtcbiAgfVxuXG4gIGZpcmVFdmVudChldmVudFR5cGUsIHBheWxvYWQgPSB7fSkge1xuICAgIGV2ZW50VHJpZ2dlcih0aGlzLmVsZW1lbnQsIGV2ZW50VHlwZSwgcGF5bG9hZCk7XG4gIH1cblxuXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgfVxuXG4gIER4RHJvcGRvd24obWV0aG9kLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZm4gPSB0aGlzW21ldGhvZF07XG4gICAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuLmJpbmQodGhpcywgb3B0aW9ucykoKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuIiwiaW1wb3J0IF9mbGF0dGVuIGZyb20gJ2xvZGFzaC9mbGF0dGVuJztcblxuLyoqXG4gKiBCdWlsZCBhIGxpc3Qgb2YgaXRlbXMgZm9yIGEgZ2l2ZW4gZHJvcGRvd24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmVOYW1lXG4gKiBAcGFyYW0ge0FycmF5fSBjdXJyZW50VXNlclZhbHVlcyAtIEN1cnJlbnRseSBzZWxlY3RlZCB1c2VyIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IGZlYXR1cmVzIC0gTGlzdCBvZiBmZWF0dXJlcy5cbiAqIEByZXR1cm4ge0FycmF5fSBmZWF0dXJlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb21wYXRpYmlsaXR5Q2hlY2tlcihmZWF0dXJlTmFtZSwgY3VycmVudFVzZXJWYWx1ZXMsIGZlYXR1cmVzKSB7XG4gIGxldCBmaWx0ZXJlZEZlYXR1cmVzID0gZmVhdHVyZXMuZmlsdGVyKChmZWF0dXJlKSA9PiB7XG4gICAgY29uc3QgeyBjb21wYXRpYmlsaXR5IH0gPSBmZWF0dXJlO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbXBhdGliaWxpdHkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpc2UgQ29tcGF0aWJpbGl0eSBpbnN0cnVjdGlvbnNcbiAgICBjb25zdCBjb21wYXRpYmlsaXRpZXMgPSBfZmxhdHRlbihjb21wYXRpYmlsaXR5Lm1hcCgoeyByZWZzIH0pID0+IChyZWZzID8gcmVmcy5zcGxpdCgnICcpIDogW10pKSk7XG5cbiAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBjdXJyZW50VXNlclZhbHVlcy5maWx0ZXIodmFsdWUgPT4gY29tcGF0aWJpbGl0aWVzLmluY2x1ZGVzKHZhbHVlKSk7XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9uLmxlbmd0aCA9PT0gY3VycmVudFVzZXJWYWx1ZXMubGVuZ3RoO1xuICB9KTtcblxuICBpZiAoZmVhdHVyZU5hbWUgPT09ICdzcGVjcGFjaycpIHtcbiAgICBmaWx0ZXJlZEZlYXR1cmVzID0gZmlsdGVyZWRGZWF0dXJlcy5maWx0ZXIoZmVhdHVyZSA9PiBmZWF0dXJlLmF2YWlsYWJpbGl0eSAhPT0gJ2V4Y2x1ZGVkJyk7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyZWRGZWF0dXJlcztcbn1cbiIsIi8qKlxuICogQ2FsbGJhY2sgdG8gcHJvY2VzcyBhbiBpdGVtIGluIGEgUXVldWUuXG4gKlxuICogQGNhbGxiYWNrIHdvcmtDYWxsYmFja1xuICogQHBhcmFtIHthbnl9IHF1ZXVlZEl0ZW0gLSBjdXJyZW50bHkgcXVldWVkIGl0ZW0gaW4gYSBwcm92aWRlZCBpdGVtcyBsaXN0LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gSW5kZXggb2YgSXRlbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuY2VsIC0gUXVldWUgY2FuY2VsbGF0aW9uIHN0YXR1cy5cbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIHRvIGZpcmUgd2hlbiBRdWV1ZSBpcyBjb21wbGV0ZWQuXG4gKlxuICogQGNhbGxiYWNrIG9uQ29tcGxldGVDYWxsYmFja1xuICovXG5cblxuLyoqXG4gKiBWYW5pbGxhIENhbmNlbGxhYmxlIFF1ZXVlIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgcGFyYW1zXG4gKiBAcGFyYW0ge0FycmF5Ljxhbnk+fSAgICAgICAgIHBhcmFtcy5pdGVtcyAgICAgIFRoZSBsaXN0IG9mIGl0ZW1zIHRvIGdvIHRocm91Z2ggb25lIGJ5IG9uZS5cbiAqIEBwYXJhbSB7d29ya0NhbGxiYWNrfSAgICAgICAgcGFyYW1zLmNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIHRvIHByb2Nlc3MgaXRlbS5cbiAqIEBwYXJhbSB7b25Db21wbGV0ZUNhbGxiYWNrfSAgcGFyYW1zLm9uQ29tcGxldGUgVGhlIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiBRdWV1ZSBpcyBmaW5pc2ggcHJvY2VzcyBhbGwgaXRlbXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFF1ZXVlKHsgaXRlbXMsIGNhbGxiYWNrLCBvbkNvbXBsZXRlIH0pIHtcbiAgbGV0IGNhbmNlbCA9IGZhbHNlO1xuXG4gIGNvbnN0IHF1ZXVlZEl0ZW1zID0gWy4uLml0ZW1zXTtcblxuICBjb25zdCBxdWV1ZVByb2Nlc3NvciA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoY2FuY2VsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHF1ZXVlZEl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWV1ZWRJdGVtID0gcXVldWVkSXRlbXMuc2hpZnQoKTtcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgYXdhaXQgY2FsbGJhY2socXVldWVkSXRlbSwgY2FuY2VsKTtcbiAgICB9XG5cbiAgICBhd2FpdCBxdWV1ZVByb2Nlc3NvcigpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcXVldWVQcm9jZXNzb3IoKTtcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGNhbmNlbCA9IHRydWU7XG4gIH07XG59XG4iLCJpbXBvcnQgeyBSdWxlc0Nvbm5lY3QgfSBmcm9tICdAY29uZmlndXJlY29ubmVjdC9ydWxlc2Nvbm5lY3Rqcyc7XG5pbXBvcnQgX2dldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCB7IEtleUNvZGUgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZXMvZGV2L2pzL3V0aWxzL2FyaWEnO1xuaW1wb3J0IER4RHJvcGRvd24gZnJvbSAnLi4vLi4vRHhEcm9wZG93bi9qcy9EeERyb3Bkb3duJztcbmltcG9ydCBRdWV1ZSBmcm9tICcuL1F1ZXVlJztcbmltcG9ydCBDb21wYXRpYmlsaXR5Q2hlY2tlciBmcm9tICcuL0NvbXBhdGliaWxpdHlDaGVja2VyJztcbmltcG9ydCB7IGJ1aWxkRW5naW5lRHJvcGRvd25NYXJrdXAgfSBmcm9tICcuL2hlbHBlcnMnO1xuXG5jb25zdCBkeERyb3Bkb3duQWN0aXZlQ2xhc3MgPSAnZHhEcm9wZG93bl9fbGlzdC1pdGVtLWxpbmstLWFjdGl2ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bGVzRW5naW5lRHJvcGRvd24ge1xuICBpc28yTGFuZyA9ICdlbic7XG4gIGJhc2VVUkwgPSAnJztcblxuICBfc3VwcG9ydGVkRmVhdHVyZUxpc3QgPSBbXG4gICAgJ2JvZHlzdHlsZScsXG4gICAgJ21vZGVsJyxcbiAgICAnZW5naW5lJyxcbiAgICAnc3BlY3BhY2snLFxuICAgICdwcm9kdWN0J1xuICBdO1xuXG4gIF9zdXBwb3J0ZWRGZWF0dXJlRWxlbWVudHMgPSBuZXcgTWFwKCk7XG5cbiAgLy8gZmVhdHVyZS1kaWN0aW9uYXJ5LnByb3BlcnR5LlN1cHByZXNzVmlld3NcbiAgLy8gQ3VycmVudGx5IGhhbmRsZWQgYnkgQmFja2VuZC5cbiAgX3N1cHByZXNzZWRWaWV3cyA9IFtdO1xuXG4gIF9xdWV1ZSA9IG51bGw7XG5cbiAgX3JjID0gbmV3IFJ1bGVzQ29ubmVjdCgpO1xuXG4gIGNvbnN0cnVjdG9yKGVsLCBiYXNlVXJsID0gJycsIGxhbmcgPSAnZW4nLCBvbkZpbmlzaCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsO1xuXG4gICAgdGhpcy5iYXNlVVJMID0gYmFzZVVybDtcbiAgICB0aGlzLmlzbzJMYW5nID0gbGFuZztcblxuICAgIHRoaXMuX3NldHVwRmVhdHVyZXNET00oKTtcblxuICAgIC8vIEluZm9ybSBwYXJlbnQgY29tcG9uZW50IHRoYXQgd2UgYXJlIHJlYWR5IGFuZCBhbGwgZHJvcCBkb3ducyBhcmUgZmlsbGVkLlxuICAgIHRoaXMub25DaGFuZ2UobnVsbCwgKCkgPT4ge1xuICAgICAgdGhpcy5vbkZpbmlzaCgpO1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiAqXG4gICAqIEZpcmVzIHdoZW4gdXNlciBzZWxlY3QgYSBuZXcgdmFsdWUgZnJvbSBSdWxlIEVuZ2luZSBEcm9wZG93biBhbmRcbiAgICogY2hhaW4gdGhlIGF1dG9tYXRpYyBzZWxlY3Rpb25zIHRvIG5leHQgZHJvcGRvd24gYnkgYnVpbGRpbmcgdGhlIG9wdGlvbnMgZnJvbSBSdWxlIEVuZ2luZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdGVkRmVhdHVyZSAgS2V5L0lEIG9mIGZlYXR1cmUgZHJvcGRvd25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZSAgQ2FsbGJhY2tcbiAgICovXG4gIG9uQ2hhbmdlKHNlbGVjdGVkRmVhdHVyZSwgb25Db21wbGV0ZSkge1xuICAgIC8vIFJlc2V0IEV4aXN0aW5nIFF1ZXVlXG4gICAgaWYgKHRoaXMuX3F1ZXVlKSB7XG4gICAgICB0aGlzLl9xdWV1ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3F1ZXVlID0gUXVldWUoe1xuICAgICAgaXRlbXM6IHRoaXMuZ2V0RmVhdHVyZXNUb1Byb2Nlc3Moc2VsZWN0ZWRGZWF0dXJlKSxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLnJlcXVlc3RBbmRQcm9jZXNzRFhEZXJpdmF0aXZlc1ZpZXcsXG4gICAgICBvbkNvbXBsZXRlXG4gICAgfSk7XG4gIH1cblxuICAvKiogKlxuICAgKiBHZXQgZHJvcGRvd24gYnkgRmVhdHVyZSBOYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZU5hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbnxIVE1MRWxlbWVudH1cbiAgICovXG4gIGdldERyb3Bkb3duKGZlYXR1cmVOYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9zdXBwb3J0ZWRGZWF0dXJlRWxlbWVudHMuaGFzKGZlYXR1cmVOYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdXBwb3J0ZWRGZWF0dXJlRWxlbWVudHNcbiAgICAgIC5nZXQoZmVhdHVyZU5hbWUpO1xuICB9XG5cbiAgLyoqICpcbiAgICogR2V0IHZhbHVlIG9mIGEgZHJvcGRvd24gYnkgRmVhdHVyZSBOYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZU5hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbnxzdHJpbmd9XG4gICAqL1xuICBnZXREcm9wZG93blZhbHVlKGZlYXR1cmVOYW1lKSB7XG4gICAgY29uc3QgZHJvcGRvd24gPSB0aGlzLmdldERyb3Bkb3duKGZlYXR1cmVOYW1lKTtcblxuICAgIGlmICghZHJvcGRvd24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZHJvcGRvd24uZ2V0QXR0cmlidXRlKCdkYXRhLWlkJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgYXZhaWxhYmxlIGZlYXR1cmVzIGZvciBjdXJyZW50IG5hbWVwbGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdGVkRmVhdHVyZVxuICAgKi9cbiAgZ2V0QWN0aXZlRmVhdHVyZXMoc2VsZWN0ZWRGZWF0dXJlKSB7XG4gICAgY29uc3Qgc2VhcmNoSW5kZXggPSB0aGlzLl9zdXBwb3J0ZWRGZWF0dXJlTGlzdC5maW5kSW5kZXgoZiA9PiBmID09PSBzZWxlY3RlZEZlYXR1cmUpO1xuICAgIGNvbnN0IHN0YXJ0aW5nSW5kZXggPSBzZWFyY2hJbmRleCA9PT0gLTEgPyAwIDogc2VhcmNoSW5kZXg7XG5cbiAgICBsZXQgZmVhdHVyZXMgPSB0aGlzLl9zdXBwb3J0ZWRGZWF0dXJlTGlzdC5zbGljZShzdGFydGluZ0luZGV4KTtcblxuICAgIC8vIGlnbm9yZSBzdXBwcmVzc2VkIGZlYXR1cmVzXG4gICAgZmVhdHVyZXMgPSBmZWF0dXJlcy5maWx0ZXIoZmVhdHVyZSA9PiAhdGhpcy5fc3VwcHJlc3NlZFZpZXdzLmluY2x1ZGVzKGZlYXR1cmUpKTtcblxuICAgIC8vIGlnbm9yZSBmZWF0dXJlcyB3aGljaCBjYW5ub3QgYmUgbWFwIHRvIERPTVxuICAgIGZlYXR1cmVzID0gZmVhdHVyZXMuZmlsdGVyKGZlYXR1cmUgPT4gdGhpcy5fc3VwcG9ydGVkRmVhdHVyZUVsZW1lbnRzLmhhcyhmZWF0dXJlKSk7XG5cbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBmZWF0dXJlcyBmb3IgUXVldWUgdG8gcHJvY2Vzcy5cbiAgICpcbiAgICogSXQgZW5zdXJlIHRvIGV4Y2x1ZGUgbGFzdCBpdGVtIGZyb20gdGhlIFF1ZXVlIChlLmcuIFNwZWNwYWNrKSwgYW5kIGFsc28gYWRkIGZpcnN0IGl0ZW0gZm9yIGluaXRpYWwgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdGVkRmVhdHVyZVxuICAgKi9cbiAgZ2V0RmVhdHVyZXNUb1Byb2Nlc3Moc2VsZWN0ZWRGZWF0dXJlKSB7XG4gICAgY29uc3QgZmVhdHVyZXMgPSB0aGlzLmdldEFjdGl2ZUZlYXR1cmVzKHNlbGVjdGVkRmVhdHVyZSk7XG4gICAgZmVhdHVyZXMucG9wKCk7XG5cbiAgICBpZiAoIXNlbGVjdGVkRmVhdHVyZSkge1xuICAgICAgcmV0dXJuIFtudWxsLCAuLi5mZWF0dXJlc107XG4gICAgfVxuXG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBvc2UgYW4gYWJzb2x1dGUgUnVsZSBFbmdpbmUgVVJMIGJhc2VkIG9uIHVzZXIgc2VsZWN0aW9uIGZvciBhIGdpdmVuIGZpbHRlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdGVkRmVhdHVyZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBidWlsZFJ1bGVFbmdpbmVVcmwoc2VsZWN0ZWRGZWF0dXJlKSB7XG4gICAgY29uc3Qgc2VhcmNoSW5kZXggPSB0aGlzLl9zdXBwb3J0ZWRGZWF0dXJlTGlzdC5maW5kSW5kZXgoZiA9PiBmID09PSBzZWxlY3RlZEZlYXR1cmUpO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2VhcmNoSW5kZXg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldERyb3Bkb3duVmFsdWUodGhpcy5fc3VwcG9ydGVkRmVhdHVyZUxpc3RbaV0pO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRSSU0gc2xhc2ggYXQgdGhlIGVuZCBvZiB0aGUgVVJMLlxuICAgIGlmICh0aGlzLmJhc2VVUkwuc2xpY2UoLTEpID09PSAnLycpIHtcbiAgICAgIHRoaXMuYmFzZVVSTCA9IHRoaXMuYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7dGhpcy5iYXNlVVJMfS8ke3ZhbHVlcy5qb2luKCdfJyl9Lmpzb25wP3ZpZXc9ZHgtZGVyaXZhdGl2ZXNgO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBvc2UgYSBSdWxlIEVuZ2luZSBEWCBEZXJpdmF0aXZlcyBWaWV3IEFQSSBjYWxsIGJhc2VkIG9uIGV4aXN0aW5nIHNlbGVjdGlvbnMsIGJ1aWxkIGRyb3AgZG93biBhbmQgYXV0b21hdGljYWxseVxuICAgKiBzZWxlY3QgZmlyc3Qgb3B0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIFF1ZXVlIFNlcnZpY2UgdG8gZW5zdXJlIGl0IGNhbiBiZSBkaXNjYXJkZWQgaWYgdXNlciBhbHRlciB0aGVpciBsaW5lYXIgam91cm5leS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmVOYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNDYW5jZWxsZWQgLSBRdWV1ZSBjYW5jZWxsYXRpb24gc3RhdHVzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVxdWVzdEFuZFByb2Nlc3NEWERlcml2YXRpdmVzVmlldyA9IChmZWF0dXJlTmFtZSwgaXNDYW5jZWxsZWQgPSBmYWxzZSkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBRdWV1ZSBoYXMgYmVlbiBjYW5jZWxsZWQgYnkgdGhlIFVzZXIsIHNvIGxldCBpZiBpdCBnby5cbiAgICAgIGlmIChpc0NhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcmMubG9hZEpzb25wKHRoaXMuYnVpbGRSdWxlRW5naW5lVXJsKGZlYXR1cmVOYW1lKSk7XG5cbiAgICAgICAgY29uc3QgYWN0aXZlRmVhdHVyZXMgPSB0aGlzLmdldEFjdGl2ZUZlYXR1cmVzKCk7XG5cbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gZmVhdHVyZU5hbWUgPyBhY3RpdmVGZWF0dXJlcy5maW5kSW5kZXgoZiA9PiBmID09PSBmZWF0dXJlTmFtZSkgKyAxIDogMDtcbiAgICAgICAgY29uc3QgbmV4dEZlYXR1cmVOYW1lID0gYWN0aXZlRmVhdHVyZXNbbmV4dEluZGV4XTtcblxuICAgICAgICBpZiAoIW5leHRGZWF0dXJlTmFtZSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmZWF0dXJlc0xpc3QgPSBfZ2V0KGRhdGEsICdmZWF0dXJlLWRpY3Rpb25hcnkuZmVhdHVyZS1saXN0JywgW10pIHx8IFtdO1xuICAgICAgICBjb25zdCBmZWF0dXJlR3JvdXAgPSBmZWF0dXJlc0xpc3RcbiAgICAgICAgICAuZmlsdGVyKGZlYXR1cmUgPT4gZmVhdHVyZS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5leHRGZWF0dXJlTmFtZSlcbiAgICAgICAgICAuc2hpZnQoKTtcblxuICAgICAgICBpZiAoIWZlYXR1cmVHcm91cCB8fCAhQXJyYXkuaXNBcnJheShmZWF0dXJlR3JvdXAuZmVhdHVyZSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZHJvcGRvd24gPSB0aGlzLmdldERyb3Bkb3duKG5leHRGZWF0dXJlTmFtZSk7XG5cbiAgICAgICAgaWYgKCFkcm9wZG93bikge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsZCBGZWF0dXJlcyBmb3IgRHJvcGRvd25cbiAgICAgICAgbGV0IGZlYXR1cmVzID0gZmVhdHVyZUdyb3VwLmZlYXR1cmU7XG5cbiAgICAgICAgLy8gRmluZCB1c2VycyBzZWxlY3Rpb25cbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0RHJvcGRvd25WYWx1ZShhY3RpdmVGZWF0dXJlc1tpXSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWx0ZXIgQnkgQ29tcGF0aWJpbGl0eVxuICAgICAgICBmZWF0dXJlcyA9IENvbXBhdGliaWxpdHlDaGVja2VyKG5leHRGZWF0dXJlTmFtZSwgdmFsdWVzLCBmZWF0dXJlcyk7XG5cbiAgICAgICAgZmVhdHVyZXMgPSBmZWF0dXJlcy5tYXAoZmVhdHVyZSA9PiAoe1xuICAgICAgICAgIGlkOiBmZWF0dXJlLmlkLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBmZWF0dXJlLmRlc2NyaXB0aW9uW3RoaXMuaXNvMkxhbmddIHx8IGZlYXR1cmUuZGVzY3JpcHRpb24uZW4gfHwgJydcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRoaXMuYnVpbGREcm9wZG93bihuZXh0RmVhdHVyZU5hbWUsIGRyb3Bkb3duLCBmZWF0dXJlcyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgb25GaW5pc2ggPSAoKSA9PiB7XG4gICAgY29uc3QgZHJvcGRvd25zQ29udGFpbmVyID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5SdWxlc0VuZ2luZURyb3Bkb3duX19kcm9wZG93bnMnKTtcbiAgICBkcm9wZG93bnNDb250YWluZXIuc2V0QXR0cmlidXRlKCdkYXRhLWl0ZW1zJywgZHJvcGRvd25zQ29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgRHhEcm9wZG93biBiYXNlZCBvbiBSdWxlIEVuZ2luZSBGZWF0dXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmVOYW1lXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRyb3Bkb3duXG4gICAqIEBwYXJhbSB7QXJyYXl9IGZlYXR1cmVzIC0gTGlzdCBvZiBmZWF0dXJlcy5cbiAgICovXG4gIGJ1aWxkRHJvcGRvd24oZmVhdHVyZU5hbWUsIGRyb3Bkb3duLCBmZWF0dXJlcykge1xuICAgIC8vIFNldHVwIExpc3RcbiAgICBSdWxlc0VuZ2luZURyb3Bkb3duLl9zZXR1cERyb3Bkb3duTGlzdChkcm9wZG93biwgZmVhdHVyZXMpO1xuXG4gICAgLy8gU2V0dXAgRHhEcm9wZG93blxuICAgIGNvbnN0IGR4RHJvcGRvd24gPSBkcm9wZG93bi5xdWVyeVNlbGVjdG9yKCcuZHhEcm9wZG93bicpO1xuICAgIG5ldyBEeERyb3Bkb3duKGR4RHJvcGRvd24pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuXG4gICAgLy8gU2V0dXAgRXZlbnRzXG4gICAgY29uc3Qgb25Vc2VyQ2hhbmdlRXZlbnQgPSAoZXZ0KSA9PiB7XG4gICAgICBjb25zdCB7IHRhcmdldDogZWwgfSA9IGV2dDtcblxuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnZHhEcm9wZG93bl9fbGlzdC1pdGVtLWxpbmsnKSkge1xuICAgICAgICBkcm9wZG93bi5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnKSk7XG4gICAgICAgIGRyb3Bkb3duLnNldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScsIGVsLmlubmVySFRNTCk7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZShmZWF0dXJlTmFtZSwgbnVsbCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRyb3Bkb3duLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25Vc2VyQ2hhbmdlRXZlbnQpO1xuXG4gICAgZHJvcGRvd24uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldnQpID0+IHtcbiAgICAgIGNvbnN0IHsgdGFyZ2V0OiBlbCB9ID0gZXZ0O1xuICAgICAgY29uc3Qga2V5ID0gZXZ0LndoaWNoIHx8IGV2dC5rZXlDb2RlO1xuXG4gICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBldmVudCBvbiBib2R5XG4gICAgICBpZiAoZWwudGFnTmFtZSA9PT0gJ0JVVFRPTicgJiYga2V5ICE9PSBLZXlDb2RlLlRBQikge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PT0gS2V5Q29kZS5SRVRVUk4pIHtcbiAgICAgICAgb25Vc2VyQ2hhbmdlRXZlbnQoZXZ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiAqXG4gICAqIENhY2hlIEVsZW1lbnQgYnkgRmVhdHVyZSBuYW1lcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cEZlYXR1cmVzRE9NKCkge1xuICAgIHRoaXMuX3N1cHBvcnRlZEZlYXR1cmVFbGVtZW50cyA9IG5ldyBNYXAoKTtcblxuICAgIHRoaXMuX3N1cHBvcnRlZEZlYXR1cmVMaXN0LmZvckVhY2goKGZlYXR1cmVOYW1lKSA9PiB7XG4gICAgICBjb25zdCBmZWF0dXJlRWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWZlYXR1cmU9XCIke2ZlYXR1cmVOYW1lfVwiXWApO1xuXG4gICAgICBpZiAoIWZlYXR1cmVFbGVtIHx8ICEoZmVhdHVyZUVsZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdXBwb3J0ZWRGZWF0dXJlRWxlbWVudHMuc2V0KGZlYXR1cmVOYW1lLCBmZWF0dXJlRWxlbSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgbGlzdCBvZiBpdGVtcyBmb3IgYSBnaXZlbiBkcm9wZG93bi5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZHJvcGRvd25cbiAgICogQHBhcmFtIHtBcnJheX0gZmVhdHVyZXMgLSBMaXN0IG9mIGZlYXR1cmVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIF9zZXR1cERyb3Bkb3duTGlzdChkcm9wZG93biwgZmVhdHVyZXMpIHtcbiAgICBjb25zdCBsaXN0ID0gZHJvcGRvd24ucXVlcnlTZWxlY3RvcignLlJ1bGVzRW5naW5lRHJvcGRvd25fX2Ryb3Bkb3duLWxpc3QnKTtcbiAgICBjb25zdCBsaXN0SXRlbSA9IGRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IoJy5SdWxlc0VuZ2luZURyb3Bkb3duX19kcm9wZG93bi1pdGVtJyk7XG5cbiAgICBsaXN0LmlubmVySFRNTCA9ICcnO1xuXG4gICAgZmVhdHVyZXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQsIGRlc2NyaXB0aW9uIH0gPSBpdGVtO1xuXG4gICAgICBjb25zdCBuZXdJdGVtID0gbGlzdEl0ZW0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgY29uc3QgaXRlbUxpbmsgPSBuZXdJdGVtLnF1ZXJ5U2VsZWN0b3IoJy5keERyb3Bkb3duX19saXN0LWl0ZW0tbGluaycpO1xuICAgICAgaXRlbUxpbmsuc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgaWQpO1xuICAgICAgaXRlbUxpbmsuaW5uZXJIVE1MID0gYnVpbGRFbmdpbmVEcm9wZG93bk1hcmt1cChkZXNjcmlwdGlvbik7XG5cbiAgICAgIGlmIChpdGVtTGluay5jbGFzc0xpc3QuY29udGFpbnMoZHhEcm9wZG93bkFjdGl2ZUNsYXNzKSkge1xuICAgICAgICBpdGVtTGluay5jbGFzc0xpc3QucmVtb3ZlKGR4RHJvcGRvd25BY3RpdmVDbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGxpc3QuYXBwZW5kQ2hpbGQobmV3SXRlbSk7XG5cbiAgICAgIC8vIEF1dG8gc2VsZWN0IGZpcnN0IG9wdGlvblxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIGRyb3Bkb3duLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsIGlkKTtcbiAgICAgICAgZHJvcGRvd24uc2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJywgZGVzY3JpcHRpb24pO1xuXG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IoJy5SdWxlc0VuZ2luZURyb3Bkb3duX19kcm9wZG93bi1idXR0b24nKTtcbiAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9IGJ1aWxkRW5naW5lRHJvcGRvd25NYXJrdXAoZGVzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCJjb25zdCBERUxJTUlURVIgPSAnfCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEVuZ2luZURyb3Bkb3duTWFya3VwKHRleHQpIHtcbiAgaWYgKCF0ZXh0IHx8IHRleHQuaW5kZXhPZihERUxJTUlURVIpID09PSAtMSkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgY29uc3QgW2VuZ2luZSwgY29uc3VtcHRpb25dID0gdGV4dC5zcGxpdChERUxJTUlURVIpO1xuXG4gIHJldHVybiBgXG4gIDxzcGFuIGNsYXNzPVwiUnVsZXNFbmdpbmVEcm9wZG93bl9fZW5naW5lXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJSdWxlc0VuZ2luZURyb3Bkb3duX19lbmdpbmUtbGFiZWxcIj4ke2VuZ2luZX08L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJSdWxlc0VuZ2luZURyb3Bkb3duX19lbmdpbmUtY29uc3VtcHRpb25cIj4ke2NvbnN1bXB0aW9ufTwvc3Bhbj5cbiAgPC9zcGFuPmA7XG59XG4iLCJpbXBvcnQgX2dldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBfZmluZCBmcm9tICdsb2Rhc2gvZmluZCc7XG5pbXBvcnQgUnVsZXNFbmdpbmVEcm9wZG93biBmcm9tICcuLi8uLi9SdWxlc0VuZ2luZURyb3Bkb3duL2pzL1J1bGVzRW5naW5lRHJvcGRvd24nO1xuaW1wb3J0IER4QWNjb3JkaW9uIGZyb20gJy4uLy4uL0R4QWNjb3JkaW9uL2pzL0R4QWNjb3JkaW9uJztcbmltcG9ydCB7IGJ1aWxkQWNjb3JkaW9uLCBhcGlDYWxsIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2VzL2Rldi9qcy91dGlscy90ZWNoU3BlY3MnO1xuXG5leHBvcnQgY2xhc3MgVmVoaWNsZVNwZWNzUnVsZXNFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihlbCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsO1xuICAgIHRoaXMuZHJvcGRvd25TZWN0aW9uID0gZWwucXVlcnlTZWxlY3RvcignLlJ1bGVzRW5naW5lRHJvcGRvd24nKTtcbiAgICB0aGlzLnNwZWNzU2VjdGlvbiA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5WZWhpY2xlU3BlY3NSdWxlc0VuZ2luZV9fc3BlY3MnKTtcbiAgICB0aGlzLmVycm9yU2VjdGlvbiA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5WZWhpY2xlU3BlY3NSdWxlc0VuZ2luZV9fZXJyb3InKTtcbiAgICB0aGlzLmJhc2VVcmwgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3BlY3MtdXJsJyk7XG4gICAgdGhpcy5sYW5nID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWxhbmcnKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBkcm9wZG93bkNvbnRhaW5lciA9IHRoaXMuZHJvcGRvd25TZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5SdWxlc0VuZ2luZURyb3Bkb3duX19kcm9wZG93bnMtY29udGFpbmVyJyk7XG5cbiAgICAgIGlmIChkcm9wZG93bkNvbnRhaW5lciAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzdWJtaXRCdXR0b24gPSB0aGlzLmRyb3Bkb3duU2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcuUnVsZXNFbmdpbmVEcm9wZG93bl9fc3VibWl0LWJ1dHRvbicpO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIGRyb3Bkb3duIHRvIGZpbmlzaCBiZWZvcmUgd2UgY2FuIG1ha2UgYSBzcGVjIGFwaSBjYWxsLlxuICAgICAgICB0aGlzLmluaXREcm9wZG93blNlY3Rpb24oKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBhY2NvcmRpb24gPSB0aGlzLnNwZWNzU2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcuVmVoaWNsZVNwZWNzUnVsZXNFbmdpbmVfX3NwZWNzLWFjY29yZGlvbicpO1xuICAgICAgICAgIFZlaGljbGVTcGVjc1J1bGVzRW5naW5lLmluaXRBY2NvcmRpb24oYWNjb3JkaW9uKTtcblxuICAgICAgICAgIHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgICAgIHN1Ym1pdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuZ2V0RGF0YSgpKTtcbiAgICAgICAgICBWZWhpY2xlU3BlY3NSdWxlc0VuZ2luZS5yZW1vdmVDbGFzcyh0aGlzLnNwZWNzU2VjdGlvbiwgJ1ZlaGljbGVTcGVjc1J1bGVzRW5naW5lX19zcGVjcy0taGlkZScpO1xuXG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFZlaGljbGVTcGVjc1J1bGVzRW5naW5lLnJlbW92ZUNsYXNzKHRoaXMuZXJyb3JTZWN0aW9uLCAnaGlkZGVuJyk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgY29uc3QgYm9keXN0eWxlRHJvcGRvd24gPSB0aGlzLmRyb3Bkb3duU2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcuUnVsZXNFbmdpbmVEcm9wZG93bl9fZHJvcGRvd24tLWJvZHlzdHlsZScpO1xuICAgIGNvbnN0IG1vZGVsRHJvcGRvd24gPSB0aGlzLmRyb3Bkb3duU2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcuUnVsZXNFbmdpbmVEcm9wZG93bl9fZHJvcGRvd24tLW1vZGVsJyk7XG4gICAgY29uc3QgZW5naW5lRHJvcGRvd24gPSB0aGlzLmRyb3Bkb3duU2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcuUnVsZXNFbmdpbmVEcm9wZG93bl9fZHJvcGRvd24tLWVuZ2luZScpO1xuICAgIGNvbnN0IHNwZWNEcm9wZG93biA9IHRoaXMuZHJvcGRvd25TZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5SdWxlc0VuZ2luZURyb3Bkb3duX19kcm9wZG93bi0tc3BlY3BhY2snKTtcblxuICAgIHRoaXMuc2V0U3BlY3NUaXRsZShib2R5c3R5bGVEcm9wZG93biwgbW9kZWxEcm9wZG93biwgZW5naW5lRHJvcGRvd24sIHNwZWNEcm9wZG93bik7XG5cbiAgICBjb25zdCBib2R5c3R5bGUgPSBib2R5c3R5bGVEcm9wZG93biAhPT0gbnVsbCA/IGAke2JvZHlzdHlsZURyb3Bkb3duLmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpfV9gIDogJyc7XG4gICAgY29uc3QgbW9kZWwgPSBtb2RlbERyb3Bkb3duICE9PSBudWxsID8gYCR7bW9kZWxEcm9wZG93bi5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnKX1fYCA6ICcnO1xuICAgIGNvbnN0IGVuZ2luZSA9IGAke2VuZ2luZURyb3Bkb3duLmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpfV9gO1xuICAgIGNvbnN0IHNwZWMgPSBzcGVjRHJvcGRvd24uZ2V0QXR0cmlidXRlKCdkYXRhLWlkJyk7XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7Ym9keXN0eWxlfSR7bW9kZWx9JHtlbmdpbmV9JHtzcGVjfS5qc29ucD92aWV3PWR4LXNwZWNzYDtcbiAgICBsZXQgY21zID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyNWZWhpY2xlU3BlY3NSdWxlc0VuZ2luZUNtcycpLmlubmVySFRNTDtcblxuICAgIGlmIChjbXMgIT09IHVuZGVmaW5lZCAmJiBjbXMgIT09IG51bGwgJiYgY21zICE9PSAnJykge1xuICAgICAgY21zID0gSlNPTi5wYXJzZShjbXMpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcmljaW5nVXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7Ym9keXN0eWxlfSR7bW9kZWx9JHtlbmdpbmV9JHtzcGVjfS5qc29ucD92aWV3PWR4LXByb2R1Y3RzYDtcbiAgICAgIGNvbnN0IHByb2R1Y3REYXRhID0gYXdhaXQgYXBpQ2FsbChwcmljaW5nVXJsKTtcbiAgICAgIGNvbnN0IHsgZmVhdHVyZTogZmVhdHVyZXMgfSA9IF9maW5kKF9nZXQocHJvZHVjdERhdGEsICdmZWF0dXJlLWRpY3Rpb25hcnkuZmVhdHVyZS1saXN0JyksIHsgbmFtZTogJ1BST0RVQ1QnIH0pO1xuXG4gICAgICBjb25zdCBwcmljaW5nRGF0YSA9IGZlYXR1cmVzLmZpbHRlcihmZWF0dXJlID0+IGZlYXR1cmUuYXZhaWxhYmlsaXR5ID09PSAnZGVmYXVsdCcgfHwgZmVhdHVyZS5hdmFpbGFiaWxpdHkgPT09ICdzZWxlY3RlZCcpO1xuXG4gICAgICBjb25zdCBzcGVjc0RhdGEgPSBhd2FpdCBhcGlDYWxsKHVybCwgY21zKTtcbiAgICAgIGNvbnN0IHNwZWNzRmVhdHVyZSA9IF9maW5kKF9nZXQoc3BlY3NEYXRhLCAnZmVhdHVyZS1kaWN0aW9uYXJ5LmZlYXR1cmUtbGlzdCcpLCB7IG5hbWU6ICdQUk9EVUNUJyB9KTtcbiAgICAgIHNwZWNzRmVhdHVyZS5mZWF0dXJlID0gcHJpY2luZ0RhdGE7XG5cbiAgICAgIHRoaXMub25TdWNjZXNzKHNwZWNzRGF0YSwgY21zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5vbkVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgb25TdWNjZXNzKGRhdGEsIGNtcykge1xuICAgIGJ1aWxkQWNjb3JkaW9uKGRhdGEsIHRoaXMuZWxlbWVudCwgJ1ZlaGljbGVTcGVjc1J1bGVzRW5naW5lX19zcGVjcy1hY2NvcmRpb24nLCB0aGlzLmxhbmcsIGNtcywgdGhpcy5vblByaWNpbmdFcnJvci5iaW5kKHRoaXMpKTtcbiAgICBWZWhpY2xlU3BlY3NSdWxlc0VuZ2luZS5hZGRDbGFzcyh0aGlzLmVycm9yU2VjdGlvbiwgJ2hpZGRlbicpO1xuICAgIHRoaXMuc2hvd1NwZWNzKCk7XG4gIH1cblxuICBvbkVycm9yKCkge1xuICAgIFZlaGljbGVTcGVjc1J1bGVzRW5naW5lLnJlbW92ZUNsYXNzKHRoaXMuZXJyb3JTZWN0aW9uLCAnaGlkZGVuJyk7XG4gICAgdGhpcy5oaWRlU3BlY3MoKTtcbiAgfVxuXG4gIG9uUHJpY2luZ0Vycm9yKGVyck1lc3NhZ2UpIHtcbiAgICB0aGlzLmVycm9yU2VjdGlvbi5zZXRBdHRyaWJ1dGUoJ2RhdGEtZXJyb3InLCBlcnJNZXNzYWdlKTtcbiAgfVxuXG4gIHNldFNwZWNzVGl0bGUoYm9keXN0eWxlLCBtb2RlbCwgZW5naW5lLCBzcGVjKSB7XG4gICAgY29uc3QgYm9keXN0eWxlVGV4dCA9IGJvZHlzdHlsZSAhPT0gbnVsbCA/IGJvZHlzdHlsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnKSA6ICcnO1xuICAgIGNvbnN0IGVuZ2luZVRleHQgPSBlbmdpbmUuZ2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJyk7XG4gICAgY29uc3Qgc3BlY1RleHQgPSBzcGVjLmdldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScpO1xuXG4gICAgbGV0IHNwZWNzVGl0bGVUZXh0ID0gYCR7Ym9keXN0eWxlVGV4dH0gfCAke3NwZWNUZXh0fWA7XG4gICAgc3BlY3NUaXRsZVRleHQgPSBWZWhpY2xlU3BlY3NSdWxlc0VuZ2luZS5yZXBsYWNlQWxsKHNwZWNzVGl0bGVUZXh0LCAnLScsICcmIzgyMDk7Jyk7XG5cbiAgICBjb25zdCBlbmdpbmVUaXRsZVRleHQgPSBWZWhpY2xlU3BlY3NSdWxlc0VuZ2luZS5yZXBsYWNlQWxsKGVuZ2luZVRleHQsICctJywgJyYjODIwOTsnKTtcblxuICAgIGNvbnN0IHNwZWNzVGl0bGUgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcignLlZlaGljbGVTcGVjc1J1bGVzRW5naW5lX19zcGVjcy10aXRsZScpO1xuICAgIHNwZWNzVGl0bGUuaW5uZXJIVE1MID0gdGhpcy5oYXNNdWx0aXBsZUJvZHlTdHlsZXMoKSA/IHNwZWNzVGl0bGVUZXh0IDogc3BlY1RleHQ7XG5cbiAgICBjb25zdCBlbmdpbmVUaXRsZSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuVmVoaWNsZVNwZWNzUnVsZXNFbmdpbmVfX3NwZWNzLWVuZ2luZScpO1xuICAgIGVuZ2luZVRpdGxlLmlubmVySFRNTCA9IGVuZ2luZVRpdGxlVGV4dDtcbiAgfVxuXG4gIGhhc011bHRpcGxlQm9keVN0eWxlcygpIHtcbiAgICBjb25zdCBib2R5c3R5bGVzID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5SdWxlc0VuZ2luZURyb3Bkb3duX19kcm9wZG93bi0tYm9keXN0eWxlJyk7XG5cbiAgICBpZiAoIWJvZHlzdHlsZXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IGJvZHlzdHlsZXMucXVlcnlTZWxlY3RvckFsbCgnLlJ1bGVzRW5naW5lRHJvcGRvd25fX2Ryb3Bkb3duLWl0ZW0nKTtcblxuICAgIHJldHVybiBpdGVtcy5sZW5ndGggPiAwO1xuICB9XG5cbiAgc3RhdGljIHJlcGxhY2VBbGwoc3RyaW5nLCBzZWFyY2gsIHJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHN0cmluZyA/IHN0cmluZy5zcGxpdChzZWFyY2gpLmpvaW4ocmVwbGFjZW1lbnQpIDogJyc7XG4gIH1cblxuICBzaG93U3BlY3MoKSB7XG4gICAgY29uc3QgZWxzID0gdGhpcy5zcGVjc1NlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnLmhpZGRlbicpO1xuXG4gICAgaWYgKGVscy5sZW5ndGgpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWxzLCAoZWwpID0+IHtcbiAgICAgICAgVmVoaWNsZVNwZWNzUnVsZXNFbmdpbmUucmVtb3ZlQ2xhc3MoZWwsICdoaWRkZW4nKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGhpZGVTcGVjcygpIHtcbiAgICBjb25zdCBlbHNUb0hpZGUgPSB0aGlzLnNwZWNzU2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCcuVmVoaWNsZVNwZWNzUnVsZXNFbmdpbmVfX3NwZWNzLWhlYWRpbmcsIC5WZWhpY2xlU3BlY3NSdWxlc0VuZ2luZV9fc3BlY3MtYWNjb3JkaW9uJyk7XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsc1RvSGlkZSwgKGVsKSA9PiB7XG4gICAgICBWZWhpY2xlU3BlY3NSdWxlc0VuZ2luZS5hZGRDbGFzcyhlbCwgJ2hpZGRlbicpO1xuICAgIH0pO1xuICB9XG5cbiAgaW5pdERyb3Bkb3duU2VjdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PlxuICAgICAgbmV3IFJ1bGVzRW5naW5lRHJvcGRvd24odGhpcy5kcm9wZG93blNlY3Rpb24sIHRoaXMuYmFzZVVybCwgdGhpcy5sYW5nLCByZXNvbHZlKSk7XG4gIH1cblxuICBzdGF0aWMgaW5pdEFjY29yZGlvbihlbCkge1xuICAgIHJldHVybiBuZXcgRHhBY2NvcmRpb24oZWwpO1xuICB9XG5cbiAgc3RhdGljIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYWRkQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgIGlmICghZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgVmVoaWNsZVNwZWNzUnVsZXNFbmdpbmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLlZlaGljbGVTcGVjc1J1bGVzRW5naW5lJyk7XG5cbkFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoVmVoaWNsZVNwZWNzUnVsZXNFbmdpbmVzLCAoZWwpID0+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSBuZXcgVmVoaWNsZVNwZWNzUnVsZXNFbmdpbmUoZWwpO1xuICBpbnN0YW5jZS5pbml0KCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufSk7XG4iLCJleHBvcnQgY29uc3QgS2V5Q29kZSA9IHtcbiAgQkFDS1NQQUNFOiA4LFxuICBERUxFVEU6IDQ2LFxuICBET1dOOiA0MCxcbiAgRU5EOiAzNSxcbiAgRVNDOiAyNyxcbiAgSE9NRTogMzYsXG4gIExFRlQ6IDM3LFxuICBQQUdFX0RPV046IDM0LFxuICBQQUdFX1VQOiAzMyxcbiAgUkVUVVJOOiAxMyxcbiAgUklHSFQ6IDM5LFxuICBTUEFDRTogMzIsXG4gIFRBQjogOSxcbiAgVVA6IDM4XG59O1xuIiwiZXhwb3J0IGNvbnN0IGJyZWFrcG9pbnRzID0ge1xuICBzbWFsbDogNzQwLFxuICBtZWRpdW06IDkwMCxcbiAgd2lkZXI6IDEwMDAsXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbmV4cG9ydCBjb25zdCBnZXREZXZpY2VPcmllbnRhdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgJHdpbmRvdyA9ICQod2luZG93KTtcbiAgcmV0dXJuICR3aW5kb3cud2lkdGgoKSA+ICR3aW5kb3cuaGVpZ2h0KCkgPyAnbGFuZHNjYXBlJyA6ICdwb3J0cmFpdCc7XG59O1xuXG5jb25zdCBnZXRMYXJnZXJCcmVha3BvaW50ID0gd2lkdGggPT4gKFxuICB3aWR0aCA8PSBicmVha3BvaW50cy5tZWRpdW0gPyAnbWVkaXVtJyA6ICdsYXJnZSdcbik7XG5cbmV4cG9ydCBjb25zdCBnZXRCcmVha3BvaW50U2l6ZSA9IChvbGRDYWxjID0gdHJ1ZSkgPT4ge1xuICBjb25zdCB3aWR0aCA9IG9sZENhbGMgPyAkKHdpbmRvdykud2lkdGgoKSA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICByZXR1cm4gKHdpZHRoIDw9IGJyZWFrcG9pbnRzLnNtYWxsKSA/ICdzbWFsbCcgOiBnZXRMYXJnZXJCcmVha3BvaW50KHdpZHRoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0JyZWFrcG9pbnRTbWFsbCA9IChvbGRDYWxjID0gdHJ1ZSkgPT4ge1xuICByZXR1cm4gZ2V0QnJlYWtwb2ludFNpemUob2xkQ2FsYykgPT09ICdzbWFsbCc7XG59O1xuXG5leHBvcnQgY29uc3QgaXNCcmVha3BvaW50TWVkaXVtID0gKG9sZENhbGMgPSB0cnVlKSA9PiB7XG4gIHJldHVybiBnZXRCcmVha3BvaW50U2l6ZShvbGRDYWxjKSA9PT0gJ21lZGl1bSc7XG59O1xuXG5leHBvcnQgY29uc3QgaXNNb2JpbGVEZXZpY2UgPSAoKSA9PiB7XG4gIHJldHVybiAoKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNoIHx8IG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufTtcblxuZXhwb3J0IGNvbnN0IGlzTm90TW9iaWxlRGV2aWNlID0gKCkgPT4ge1xuICByZXR1cm4gIWlzTW9iaWxlRGV2aWNlKCk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNUYWJsZXREZXZpY2UgPSAoKSA9PiB7XG4gIHJldHVybiAvKGlwYWR8dGFibGV0fChhbmRyb2lkKD8hLiptb2JpbGUpKXwod2luZG93cyg/IS4qcGhvbmUpKC4qdG91Y2gpKXxraW5kbGV8cGxheWJvb2t8c2lsa3wocHVmZmluKD8hLiooSVB8QVB8V1ApKSkpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNJT1MgPSAoKSA9PiB7XG4gIHJldHVybiAoLyhpcGFkfGlwaG9uZXxpcG9kKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKSk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNOb3RJT1MgPSAoKSA9PiB7XG4gIHJldHVybiAhaXNJT1MoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc1dpbmRvd3NQaG9uZSA9ICgpID0+IHtcbiAgcmV0dXJuIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2luZG93cyBwaG9uZScpICE9PSAtMSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QW5kcm9pZFZlcnNpb24gPSAoKSA9PiB7XG4gIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAodWEuaW5kZXhPZignQW5kcm9pZCcpID49IDApIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh1YS5zbGljZSh1YS5pbmRleE9mKCdBbmRyb2lkJykgKyA4KSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QnJvd3NlclVzZXJBZ2VudCA9ICgpID0+IHtcbiAgY29uc3QgeyB1c2VyQWdlbnQgfSA9IG5hdmlnYXRvcjtcbiAgcmV0dXJuIHVzZXJBZ2VudDtcbn07XG5cbmV4cG9ydCBjb25zdCBkZXRlY3RCcm93c2VycyA9ICgpID0+IHtcbiAgY29uc3QgdXNlckFnZW50ID0gZ2V0QnJvd3NlclVzZXJBZ2VudCgpO1xuICBjb25zdCBicm93c2VycyA9IHtcbiAgICBpc0Nocm9tZTogdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEsXG4gICAgaXNNc0VkZ2U6IHVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPiAtMSxcbiAgICBpc0V4cGxvcmVyOiB1c2VyQWdlbnQuaW5kZXhPZignTVNJRScpID4gLTEgfHwgdXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA+IC0xLCAvLyBNU0lFID0gSUUxMCBhbmQgYmVsb3csIFRyaWRlbnQgPSBJRTExXG4gICAgaXNGaXJlZm94OiB1c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEsXG4gICAgaXNTYWZhcmk6IHVzZXJBZ2VudC5pbmRleE9mKCdTYWZhcmknKSA+IC0xLFxuICAgIGlzT3BlcmE6IHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ29wJykgPiAtMVxuICB9O1xuXG4gIGlmIChicm93c2Vycy5pc0Nocm9tZSAmJiBicm93c2Vycy5pc1NhZmFyaSkge1xuICAgIGJyb3dzZXJzLmlzU2FmYXJpID0gZmFsc2U7XG4gIH1cblxuICBpZiAoYnJvd3NlcnMuaXNDaHJvbWUgJiYgYnJvd3NlcnMuaXNPcGVyYSkge1xuICAgIGJyb3dzZXJzLmlzQ2hyb21lID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYnJvd3NlcnM7XG59O1xuXG5leHBvcnQgY29uc3QgaXNJZSA9ICgpID0+IHtcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwnKS5jbGFzc0xpc3QuY29udGFpbnMoJ2llJyk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNNc0VkZ2UgPSAoKSA9PiB7XG4gIHJldHVybiBkZXRlY3RCcm93c2VycygpLmlzTXNFZGdlO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzSWUxMSA9ICgpID0+IHtcbiAgcmV0dXJuICghd2luZG93LkFjdGl2ZVhPYmplY3QgJiYgJ0FjdGl2ZVhPYmplY3QnIGluIHdpbmRvdyk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Vmlld3BvcnRTaXplID0gKCkgPT4ge1xuICBjb25zdCB0ZXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgdGVzdC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBmaXhlZDt0b3A6IDA7bGVmdDogMDtib3R0b206IDA7cmlnaHQ6IDA7JztcbiAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0ZXN0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZmlyc3RDaGlsZCk7XG5cbiAgY29uc3QgZGltcyA9IHsgd2lkdGg6IHRlc3Qub2Zmc2V0V2lkdGgsIGhlaWdodDogdGVzdC5vZmZzZXRIZWlnaHQgfTtcbiAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRlc3QpO1xuXG4gIHJldHVybiBkaW1zO1xufTtcblxuZXhwb3J0IGNvbnN0IHNjcm9sbFRvRWxlbWVudCA9IChlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCAkZWxlbWVudCA9IGVsZW1lbnQgaW5zdGFuY2VvZiBqUXVlcnkgPyBlbGVtZW50IDogJChlbGVtZW50KTtcblxuICAvLyBPcHRpb25zIGFyZSBvcHRpb25hbFxuICBsZXQgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gU2V0IGRlZmF1bHRzXG4gIG9wdHMgPSAkLmV4dGVuZCh7XG4gICAgYWRqdXN0bWVudDogMCxcbiAgICBlYXNlOiAnZWFzZU91dFNpbmUnLFxuICAgIGR1cmF0aW9uOiA4MDAsXG4gICAgY29udGFpbmVyOiAkKCdib2R5LCBodG1sJylcbiAgfSwgb3B0cyk7XG5cbiAgLy8gSGFzIGFuIGVsZW1lbnQgYmVlbiBzdXBwbGllZD9cbiAgaWYgKCRlbGVtZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFNjcm9sbCB0byB0aGUgdGFyZ2V0IGVsZW1lbnQgYWxsb3dpbmcgZm9yIHRoZSB1dGlsaXR5IG1lbnVcbiAgb3B0cy5jb250YWluZXIuc3RvcCgpLmFuaW1hdGUoe1xuICAgIHNjcm9sbFRvcDogJGVsZW1lbnQub2Zmc2V0KCkudG9wIC0gb3B0cy5hZGp1c3RtZW50XG4gIH0sIG9wdHMuZHVyYXRpb24sIG9wdHMuZWFzZSwgKCkgPT4ge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEZvciB1bml0IHRlc3RzXG4gIHJldHVybiBvcHRzO1xufTtcblxuLyoqXG4gKiBEZXRlY3QgTW9kZXJuIEJyb3dzZXIgYnkgYXZhaWxhYmlsaXR5IG9mIEJpZ0ludCBmZWF0dXJlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNCaWdJbnRTdXBwb3J0ID0gKCkgPT4ge1xuICByZXR1cm4gKHR5cGVvZiBCaWdJbnQgPT09ICdmdW5jdGlvbicpO1xufTtcbiIsImltcG9ydCB7IFJ1bGVzQ29ubmVjdCB9IGZyb20gJ0Bjb25maWd1cmVjb25uZWN0L3J1bGVzY29ubmVjdGpzJztcblxuZXhwb3J0IGRlZmF1bHQgKHByaWNlLCBmb3JtYXQpID0+IHtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICBtZXRhZGF0YToge1xuICAgICAgbWV0YToge31cbiAgICB9XG4gIH07XG5cbiAgaWYgKGZvcm1hdCkge1xuICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8nPyZuYnNwOyc/L2csICcgJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgfVxuXG4gIGRhdGEubWV0YWRhdGEubWV0YVsnY3VycmVuY3ktZm9ybWF0J10gPSBmb3JtYXQ7XG5cbiAgY29uc3QgcmMgPSBuZXcgUnVsZXNDb25uZWN0KCk7XG4gIHJjLnJlYWRDdXJyZW5jeUZvcm1hdHMoZGF0YSk7XG4gIHJldHVybiByYy5nZXRGb3JtYXR0ZWRQcmljZShwcmljZSwgZm9ybWF0KTtcbn07XG4iLCIvKiBnbG9iYWwgYXBwUmVhZHlUaW1lciAqL1xuXG5pbXBvcnQgeyBpc0JyZWFrcG9pbnRTbWFsbCwgZ2V0QnJlYWtwb2ludFNpemUgfSBmcm9tICcuL2Jyb3dzZXJEZXRlY3Rpb24nO1xuaW1wb3J0IHsgS2V5Q29kZSB9IGZyb20gJy4vYXJpYSc7XG5cbmNvbnN0ICRuYXZIZWFkZXIgPSAkKCcjaGVhZGVyLCAuZHhuYXYtaGVhZGVyJyk7XG5leHBvcnQgY29uc3Qgc3RpY2t5TmF2aWdhdGlvbkVuYWJsZWQgPSAkbmF2SGVhZGVyLmF0dHIoJ2RhdGEtbmF2LXR5cGUnKSA9PT0gJ3N0aWNreSc7XG5leHBvcnQgY29uc3Qgc3RpY2t5TmF2aWdhdGlvblRyYW5zaXRpb25Qb2ludCA9IDIwMDtcbmNvbnN0IHRlbXBsYXRlQ2FjaGUgPSB7fTtcblxuZXhwb3J0IGNvbnN0IGdvb2dsZU1hcFN0eWxlcyA9IFtcbiAge1xuICAgIGZlYXR1cmVUeXBlOiAnYWRtaW5pc3RyYXRpdmUubG9jYWxpdHknLFxuICAgIGVsZW1lbnRUeXBlOiAnbGFiZWxzLnRleHQuZmlsbCcsXG4gICAgc3R5bGVyczogW3tcbiAgICAgIGNvbG9yOiAnIzY2NjY2NidcbiAgICB9XVxuICB9LFxuICB7XG4gICAgZmVhdHVyZVR5cGU6ICdsYW5kc2NhcGUubWFuX21hZGUnLFxuICAgIGVsZW1lbnRUeXBlOiAnZ2VvbWV0cnkuZmlsbCcsXG4gICAgc3R5bGVyczogW3tcbiAgICAgIGNvbG9yOiAnI2Y4ZjZmNCdcbiAgICB9XVxuICB9LFxuICB7XG4gICAgZmVhdHVyZVR5cGU6ICdwb2knLFxuICAgIGVsZW1lbnRUeXBlOiAnbGFiZWxzJyxcbiAgICBzdHlsZXJzOiBbe1xuICAgICAgdmlzaWJpbGl0eTogJ29mZidcbiAgICB9XVxuICB9LFxuICB7XG4gICAgZmVhdHVyZVR5cGU6ICdyb2FkLmhpZ2h3YXknLFxuICAgIGVsZW1lbnRUeXBlOiAnZ2VvbWV0cnkuZmlsbCcsXG4gICAgc3R5bGVyczogW3tcbiAgICAgIGNvbG9yOiAnI2FmYWJhNCdcbiAgICB9XVxuICB9LFxuICB7XG4gICAgZmVhdHVyZVR5cGU6ICdyb2FkLmhpZ2h3YXknLFxuICAgIGVsZW1lbnRUeXBlOiAnZ2VvbWV0cnkuc3Ryb2tlJyxcbiAgICBzdHlsZXJzOiBbe1xuICAgICAgY29sb3I6ICcjZTZlNmU2J1xuICAgIH1dXG4gIH0sXG4gIHtcbiAgICBmZWF0dXJlVHlwZTogJ3JvYWQuaGlnaHdheScsXG4gICAgZWxlbWVudFR5cGU6ICdsYWJlbHMnLFxuICAgIHN0eWxlcnM6IFt7XG4gICAgICBzYXR1cmF0aW9uOiAtMTVcbiAgICB9XVxuICB9LFxuICB7XG4gICAgZmVhdHVyZVR5cGU6ICdyb2FkLmhpZ2h3YXkuY29udHJvbGxlZF9hY2Nlc3MnLFxuICAgIGVsZW1lbnRUeXBlOiAnZ2VvbWV0cnkuZmlsbCcsXG4gICAgc3R5bGVyczogW3tcbiAgICAgIGNvbG9yOiAnI2FmYWJhNCdcbiAgICB9XVxuICB9LFxuICB7XG4gICAgZmVhdHVyZVR5cGU6ICdyb2FkLmhpZ2h3YXkuY29udHJvbGxlZF9hY2Nlc3MnLFxuICAgIGVsZW1lbnRUeXBlOiAnbGFiZWxzLmljb24nLFxuICAgIHN0eWxlcnM6IFt7XG4gICAgICBzYXR1cmF0aW9uOiAtMTAwXG4gICAgfV1cbiAgfSxcbiAge1xuICAgIGZlYXR1cmVUeXBlOiAncm9hZC5sb2NhbCcsXG4gICAgZWxlbWVudFR5cGU6ICdnZW9tZXRyeS5maWxsJyxcbiAgICBzdHlsZXJzOiBbe1xuICAgICAgY29sb3I6ICcjZmZmZmZmJ1xuICAgIH1dXG4gIH0sXG4gIHtcbiAgICBmZWF0dXJlVHlwZTogJ3JvYWQubG9jYWwnLFxuICAgIGVsZW1lbnRUeXBlOiAnbGFiZWxzLmljb24nLFxuICAgIHN0eWxlcnM6IFt7XG4gICAgICBzYXR1cmF0aW9uOiAnNzcnXG4gICAgfV1cbiAgfSxcbiAge1xuICAgIGZlYXR1cmVUeXBlOiAndHJhbnNpdCcsXG4gICAgZWxlbWVudFR5cGU6ICdsYWJlbHMuaWNvbicsXG4gICAgc3R5bGVyczogW3tcbiAgICAgIHNhdHVyYXRpb246ICctMTAwJ1xuICAgIH1dXG4gIH0sXG4gIHtcbiAgICBmZWF0dXJlVHlwZTogJ3dhdGVyJyxcbiAgICBlbGVtZW50VHlwZTogJ2dlb21ldHJ5LmZpbGwnLFxuICAgIHN0eWxlcnM6IFtcbiAgICAgIHtcbiAgICAgICAgY29sb3I6ICcjYzVkN2RlJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbGlnaHRuZXNzOiAtOVxuICAgICAgfVxuICAgIF1cbiAgfVxuXTtcblxuZXhwb3J0IGNvbnN0IGlzUnRsID0gKCkgPT4ge1xuICBjb25zdCBodG1sID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2h0bWwnKVswXTtcbiAgcmV0dXJuIGh0bWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdydGwnKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDYWNoZWRTY3JpcHQgPSAodXJsLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IG5ld09wdGlvbnMgPSAkLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgZGF0YVR5cGU6ICdzY3JpcHQnLFxuICAgIGNhY2hlOiB0cnVlLFxuICAgIHVybFxuICB9KTtcblxuICByZXR1cm4gJC5hamF4KG5ld09wdGlvbnMpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEhlaWdodCA9IChlbGVtKSA9PiB7XG4gIHJldHVybiAoZWxlbSA/IGVsZW0uY2xpZW50SGVpZ2h0IDogMCk7XG59O1xuXG4vLyBtYWtlIHN1cmUgdG8gcGFzcyAnb2xkQ2FsY3VsYXRpb24gPSBmYWxzZScgdG8gdXNlIHRoZSBuZXcgcmVmaW5lZCBjYWxjdWxhdGlvblxuLy8gb3IgdXNlIGdldFN0aWNreU5hdkhlaWdodFYyKClcbmV4cG9ydCBjb25zdCBnZXRTdGlja3lOYXZIZWlnaHQgPSAoeVBvcywgb2xkQ2FsY3VsYXRpb24gPSB0cnVlKSA9PiB7XG4gIGNvbnN0IHlQb3NpdGlvbiA9IHR5cGVvZiB5UG9zICE9PSAnbnVtYmVyJyA/IDAgOiB5UG9zO1xuICBjb25zdCBzaGFyZWRIZWFkZXIgPSAkKCcuZHhuYXYtaGVhZGVyJyk7XG4gIGNvbnN0ICRoZWFkZXIgPSBzaGFyZWRIZWFkZXIubGVuZ3RoID8gc2hhcmVkSGVhZGVyIDogJCgnI2hlYWRlcicpO1xuICBjb25zdCAkaW5QYWdlTmF2ID0gJCgnLkluUGFnZU5hdmlnYXRpb24nKTtcbiAgY29uc3QgJGluUGFnZU5hdlN0aWNreSA9ICQoJy5JblBhZ2VOYXZpZ2F0aW9uLS1zdGlja3knKTtcbiAgY29uc3QgJGluUGFnZU5hdkJhciA9ICQoJy5JblBhZ2VOYXZpZ2F0aW9uX19iYXInKTtcbiAgY29uc3QgZHhOYXZQcmltYXJ5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmR4bmF2X19wcmltYXJ5Jyk7XG4gIGNvbnN0IGJyZWFrcG9pbnQgPSBnZXRCcmVha3BvaW50U2l6ZSgpO1xuICBjb25zdCBjaGVja1N0aWNreU5hdiA9ICRoZWFkZXIubGVuZ3RoID4gMCA/ICRoZWFkZXIuY3NzKCdwb3NpdGlvbicpID09PSAnZml4ZWQnIDogZmFsc2U7XG4gIGNvbnN0IGluUGFnZU5hdlRvcCA9ICRpblBhZ2VOYXYubGVuZ3RoID4gMCA/ICRpblBhZ2VOYXYub2Zmc2V0KCkudG9wIDogbnVsbDtcbiAgY29uc3QgaXNTdGlja3lOYXYgPSBzaGFyZWRIZWFkZXIubGVuZ3RoID8gdHJ1ZSA6IGNoZWNrU3RpY2t5TmF2O1xuICBsZXQgaGVpZ2h0ID0gMDtcblxuICBpZiAoIWlzU3RpY2t5TmF2KSB7XG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfVxuXG4gIC8vIGhhcmQgY29kaW5nIHZhbHVlcyBoZXJlIHRvIHByZXZlbnQgaGF2aW5nIHRvIHJlcGVhdGVkbHkgY2xvbmUgYW5kIG1lYXN1cmUgdGhlIGhlYWRlclxuICBjb25zdCBvbGROYXZCcmVha3BvaW50ID0gOTYwO1xuXG4gIC8vIGFkZGVkICRpblBhZ2VOYXYuY3NzKCdkaXNwbGF5JykgY2hlY2sgZm9yIExSQS0xMDg1MVxuICBpZiAoaW5QYWdlTmF2VG9wICE9PSBudWxsICYmIHlQb3NpdGlvbiA+PSBpblBhZ2VOYXZUb3AgJiYgYnJlYWtwb2ludCA9PT0gJ2xhcmdlJyAmJiAkaW5QYWdlTmF2LmNzcygnZGlzcGxheScpICE9PSAnbm9uZScpIHtcbiAgICByZXR1cm4gJGluUGFnZU5hdi5vdXRlckhlaWdodCgpO1xuICB9XG5cbiAgY29uc3Qgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcblxuICAvLyB0aGlzIGlzIHRoZSBvbGQgbmF2aWdhdGlvbiwgb25seSBzaG93biB3aGVuIE5hYVMgaXMgZG93biwgaGFyZCBjb2RpbmcgdmFsdWVzIHRvIHByZXZlbnQgaGF2aW5nIHRvIGNsb25lL21lYXN1cmUgdGhlIERPTSBlbGVtZW50cyBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICBjb25zdCBnZXROYXZpZ2F0aW9uSGVpZ2h0ID0gKCkgPT4ge1xuICAgIGlmICh3aW5kb3dXaWR0aCA+PSBvbGROYXZCcmVha3BvaW50ICYmIHlQb3NpdGlvbiA8IDIwMCkge1xuICAgICAgcmV0dXJuIDEwNjtcbiAgICB9XG4gICAgcmV0dXJuIDUwO1xuICB9O1xuXG4gIGNvbnN0IGdldE5hYVNIZWlnaHQgPSAob2xkKSA9PiB7XG4gICAgbGV0IHByaW1hcnlOYXZIZWlnaHQ7XG5cbiAgICBpZiAob2xkKSB7XG4gICAgICBwcmltYXJ5TmF2SGVpZ2h0ID0gZ2V0SGVpZ2h0KGR4TmF2UHJpbWFyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByaW1hcnlOYXZIZWlnaHQgPSAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmR4bmF2LXNjcm9sbERvd24nKSA9PT0gbnVsbCAmJiAhJGluUGFnZU5hdlN0aWNreS5sZW5ndGgpID8gZ2V0SGVpZ2h0KGR4TmF2UHJpbWFyeSkgKyBwYXJzZUludChzaGFyZWRIZWFkZXIuY3NzKCd0b3AnKSwgMTApIDogMDtcbiAgICB9XG5cbiAgICBsZXQgYnJlYWRjcnVtYk5hdkhlaWdodCA9IGdldEhlaWdodChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZHhuYXZfX2JyZWFkY3J1bWJzLWNvbnRhaW5lcicpKTtcbiAgICBjb25zdCBub3RpZmljYXRpb25IZWlnaHQgPSBnZXRIZWlnaHQoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm5vdGlmaWNhdGlvbkJhcnNXcmFwcGVyJykpO1xuICAgIGxldCBpblBhZ2VOYXZpZ2F0aW9uSGVpZ2h0ID0gMDtcbiAgICBpZiAoJGluUGFnZU5hdi5sZW5ndGgpIHtcbiAgICAgIGlmICgkaW5QYWdlTmF2U3RpY2t5Lmxlbmd0aCkge1xuICAgICAgICBicmVhZGNydW1iTmF2SGVpZ2h0ID0gMDtcbiAgICAgICAgaWYgKHBhcnNlSW50KCRpblBhZ2VOYXZCYXIuY3NzKCd0b3AnKSwgMTApID09PSAwKSB7XG4gICAgICAgICAgaW5QYWdlTmF2aWdhdGlvbkhlaWdodCA9ICRpblBhZ2VOYXYuaW5uZXJIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VJbnQoJGluUGFnZU5hdkJhci5jc3MoJ3RvcCcpLCAxMCkgPCAwKSB7XG4gICAgICAgICAgaW5QYWdlTmF2aWdhdGlvbkhlaWdodCA9IE1hdGgubWF4KCRpblBhZ2VOYXYub3V0ZXJIZWlnaHQoKSArIHBhcnNlSW50KCRpblBhZ2VOYXZCYXIuY3NzKCd0b3AnKSwgMTApLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJpbWFyeU5hdkhlaWdodCArIGJyZWFkY3J1bWJOYXZIZWlnaHQgKyBub3RpZmljYXRpb25IZWlnaHQgKyAob2xkID8gMCA6IGluUGFnZU5hdmlnYXRpb25IZWlnaHQpO1xuICB9O1xuXG4gIGlmIChzaGFyZWRIZWFkZXIubGVuZ3RoKSB7XG4gICAgaGVpZ2h0ID0gZ2V0TmFhU0hlaWdodChvbGRDYWxjdWxhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgaGVpZ2h0ID0gZ2V0TmF2aWdhdGlvbkhlaWdodCgpO1xuICB9XG5cbiAgcmV0dXJuIGhlaWdodDtcbn07XG5cbi8vIHNob3VsZCBiZSB1c2VkIHVudGlsIG1lcmdlZCB3aXRoIGdldE5hdmlnYXRpb25IZWlnaHRcbmV4cG9ydCBjb25zdCBnZXRTdGlja3lOYXZIZWlnaHRWMiA9ICh5UG9zKSA9PiB7XG4gIHJldHVybiBnZXRTdGlja3lOYXZIZWlnaHQoeVBvcywgZmFsc2UpO1xufTtcblxuXG5leHBvcnQgY29uc3Qgc2Nyb2xsVG8gPSAodGFyZ2V0LCBkdXJhdGlvbiwgY2FsbGJhY2ssIGVhc2luZywgaWdub3JlU3RpY2t5TmF2LCB5T2Zmc2V0ID0gMCkgPT4ge1xuICBjb25zdCBuZXdEdXJhdGlvbiA9ICh0eXBlb2YgZHVyYXRpb24gIT09ICdudW1iZXInKSA/IDgwMCA6IGR1cmF0aW9uO1xuICBjb25zdCBuZXdDYWxsYmFjayA9ICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpID8gbnVsbCA6IGNhbGxiYWNrO1xuICBjb25zdCBuZXdFYXNpbmcgPSAodHlwZW9mIGVhc2luZyAhPT0gJ3N0cmluZycpID8gJ2Vhc2VPdXRTaW5lJyA6IGVhc2luZztcbiAgbGV0IHBvc2l0aW9uID0gMDtcblxuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ251bWJlcicpIHsgLy8gUHggdmFsdWVcbiAgICBwb3NpdGlvbiA9IHRhcmdldDtcbiAgfSBlbHNlIHsgLy8gRWxlbWVudFxuICAgIGNvbnN0ICR0YXJnZXRFbCA9IHRhcmdldCB8fCAkKCdib2R5Jyk7XG4gICAgcG9zaXRpb24gPSAkdGFyZ2V0RWwub2Zmc2V0KCkudG9wO1xuICB9XG5cbiAgaWYgKGlnbm9yZVN0aWNreU5hdiAhPT0gdHJ1ZSkge1xuICAgIHBvc2l0aW9uIC09IGdldFN0aWNreU5hdkhlaWdodChwb3NpdGlvbik7XG4gIH1cblxuICAkKCdodG1sLCBib2R5Jykuc3RvcCgpLmFuaW1hdGUoXG4gICAgeyBzY3JvbGxUb3A6IHBvc2l0aW9uICsgeU9mZnNldCB9LFxuICAgIG5ld0R1cmF0aW9uLFxuICAgIG5ld0Vhc2luZ1xuICApXG4gICAgLnByb21pc2UoKVxuICAgIC5kb25lKG5ld0NhbGxiYWNrKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjaGVja0RlZXBMaW5rID0gKGhyZWYpID0+IHtcbiAgbGV0IGRlZXBMaW5rID0gZmFsc2U7XG4gIGNvbnN0IHNwZWVkID0gMi41O1xuXG4gIGNvbnN0IGhhc2hQb3MgPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hQb3MgKyAxIDwgaHJlZi5sZW5ndGggJiYgaGFzaFBvcyAhPT0gLTEpIHtcbiAgICBjb25zdCBpZCA9IGhyZWYuc3Vic3RyaW5nKGhhc2hQb3MsIGhyZWYubGVuZ3RoKTtcbiAgICBpZiAoJChpZCkubGVuZ3RoID09PSAxKSB7XG4gICAgICBsZXQgbG9jYXRpb24gPSAkKGlkKTtcbiAgICAgIGxldCBkdXJhdGlvbiA9IGxvY2F0aW9uLm9mZnNldCgpLnRvcCAvIHNwZWVkO1xuXG4gICAgICAvLyBMUkEtMTM3OTQgfCBBY2NvcmRpb25Db250YWluZXIgfCBPcGVuIGFjY29yZGlvbiBmaXJzdCBpZiBkZWVwbGluayBpcyBpbnNpZGVcbiAgICAgIGlmICgkKCdoZWFkIFtuYW1lPVwiYWNjb3JkaW9uT25Nb2JpbGVcIl0nKS5sZW5ndGggJiYgaXNCcmVha3BvaW50U21hbGwoKSkge1xuICAgICAgICBjb25zdCBhY2NvcmRpb25QYXJlbnQgPSBsb2NhdGlvbi5jbG9zZXN0KCcuYWNjb3JkaW9uLWdyb3VwJyk7XG4gICAgICAgIGNvbnN0IGFjY29yZGlvblRpdGxlID0gYWNjb3JkaW9uUGFyZW50LmZpbmQoJy5hY2NvcmRpb24tZ3JvdXAtdGl0bGUnKTtcblxuICAgICAgICBpZiAoYWNjb3JkaW9uUGFyZW50Lmxlbmd0aCAmJiBhY2NvcmRpb25UaXRsZS5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBPcGVuIGFjY29yZGlvbiBpZiBjbG9zZWRcbiAgICAgICAgICBpZiAoIWFjY29yZGlvblBhcmVudC5oYXNDbGFzcygnb3BlbicpKSB7XG4gICAgICAgICAgICBhY2NvcmRpb25UaXRsZS5jbGljaygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IHRoZSBoZWlnaHQgb2YgdGhlIGFjY29yZGlvbiB0aXRsZVxuICAgICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24ub2Zmc2V0KCkudG9wIC0gYWNjb3JkaW9uVGl0bGUub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgICAgIHNjcm9sbFRvKGxvY2F0aW9uLCA4MDAsIG51bGwsICdlYXNlT3V0U2luZScpO1xuICAgICAgICAgIGRlZXBMaW5rID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxvY2F0aW9uLnBhcmVudHMoJy5UYWJiZWRDb250YWluZXInKS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgJGNvbnRhaW5lciA9IGxvY2F0aW9uLmNsb3Nlc3QoJy5UYWJiZWRDb250YWluZXInKTtcbiAgICAgICAgY29uc3QgJHRhYnMgPSAkY29udGFpbmVyLmZpbmQoJy50YWInKTtcbiAgICAgICAgY29uc3QgJHRhYkxpbmtzID0gJGNvbnRhaW5lci5maW5kKCcudGFiLWxpbmsnKTtcbiAgICAgICAgbGV0IHRhYkluZGV4ID0gMDtcblxuICAgICAgICAkdGFicy5lYWNoKChpLCBlbCkgPT4ge1xuICAgICAgICAgIGNvbnN0ICRsb2NhdGlvbiA9ICQoZWwpLmZpbmQobG9jYXRpb24pO1xuICAgICAgICAgIGlmICgkbG9jYXRpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YWJJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAkdGFiTGlua3MuZWFjaCgoaSwgZWwpID0+IHtcbiAgICAgICAgICBpZiAoaSA9PT0gdGFiSW5kZXgpIHtcbiAgICAgICAgICAgICQoZWwpLmNsaWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsb2NhdGlvbiA9ICRjb250YWluZXIub2Zmc2V0KCkudG9wO1xuICAgICAgICBkdXJhdGlvbiA9IGxvY2F0aW9uIC8gc3BlZWQ7XG5cbiAgICAgICAgc2Nyb2xsVG8obG9jYXRpb24sIDgwMCwgbnVsbCwgJ2Vhc2VTdGFydEZhc3RFbmRTbG93Jyk7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB9XG5cbiAgICAgIC8vIExSQS0xMjcwMSB8IEw0NjIgVGVzdCB8IE9wZW4gYWNjb3JkaW9uIGZpcnN0IGlmIGRlZXBsaW5rIGlzIGluc2lkZVxuICAgICAgaWYgKCQoJ2JvZHknKS5oYXNDbGFzcygndmVoaWNsZXNEaXNjb3ZlcnknKSkge1xuICAgICAgICBjb25zdCBhY2NvcmRpb25QYXJlbnQgPSBsb2NhdGlvbi5wYXJlbnRzKCcuQWNjb3JkaW9uQ29udGFpbmVyJyk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSAkKGxvY2F0aW9uKTtcblxuICAgICAgICBpZiAoYWNjb3JkaW9uUGFyZW50Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGFjY29yZGlvbkhlYWRlciA9IGFjY29yZGlvblBhcmVudC5maW5kKCcuaGVhZGVyJyk7XG5cbiAgICAgICAgICBpZiAoIWFjY29yZGlvbkhlYWRlci5oYXNDbGFzcygnYWNjb3JkaW9uLW9wZW4nKSkge1xuICAgICAgICAgICAgYWNjb3JkaW9uSGVhZGVyLmNsaWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFjY29yZGlvbkhlYWRlci5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgaWYgKCFsb2NhdGlvbi5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICBlbGVtZW50LmNzcygnZGlzcGxheScsICdibG9jaycpO1xuICAgICAgICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uLm9mZnNldCgpLnRvcFxuICAgICAgICAgICAgICAgIC0gYWNjb3JkaW9uSGVhZGVyLm91dGVySGVpZ2h0KCk7XG4gICAgICAgICAgICAgIGVsZW1lbnQuY3NzKCdkaXNwbGF5JywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9jYXRpb24gPSBsb2NhdGlvbi5vZmZzZXQoKS50b3BcbiAgICAgICAgICAgICAgICAtIGFjY29yZGlvbkhlYWRlci5vdXRlckhlaWdodCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzY3JvbGxUbyhsb2NhdGlvbiwgZHVyYXRpb24sIG51bGwsICdlYXNlU3RhcnRGYXN0RW5kU2xvdycpO1xuICAgICAgZGVlcExpbmsgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IGZpbmQgZGVlcCBsaW5rIGVsZW1lbnQgd2l0aCBpZDogJHtpZH1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZXBMaW5rOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59O1xuXG5leHBvcnQgY29uc3QgaXNQYWdlSW5JZnJhbWUgPSAoKSA9PiB7XG4gIHJldHVybiB3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcDtcbn07XG5cbmV4cG9ydCBjb25zdCBpbnNpZGVUYWJiZWRDb250YWluZXIgPSAoZWwpID0+IHtcbiAgY29uc3QgaXNJbnNpZGVUYWJiZWRDb250YWluZXIgPSAhIWVsLnBhcmVudHMoJy5UYWJiZWRDb250YWluZXInKS5ub3QoJ1tkYXRhLXRvdGFsPVwiMVwiXScpLmxlbmd0aDtcblxuICBpZiAoaXNJbnNpZGVUYWJiZWRDb250YWluZXIpIHtcbiAgICByZXR1cm4gZWwucGFyZW50cygnLlRhYmJlZENvbnRhaW5lcicpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGNvbnN0IG1vYmlsZUFjY29yZGlvbnNBY3RpdmF0ZWQgPSAoKSA9PiB7XG4gIHJldHVybiAkKCdoZWFkIFtuYW1lPVwiYWNjb3JkaW9uT25Nb2JpbGVcIl0nKS5sZW5ndGg7XG59O1xuXG5leHBvcnQgY29uc3QgcmVtb3ZlSFRNTFRhZ3MgPSAocykgPT4ge1xuICByZXR1cm4gcy50b1N0cmluZygpLnJlcGxhY2UoL1s8Pj07XS9nLCAnJyk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VXJsUGFyYW1ldGVyID0gKHNQYXJhbSkgPT4ge1xuICBmdW5jdGlvbiBkZWNvZGUocykge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoKHMgfHwgJycpLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfVxuXG4gIGNvbnN0IHNQYWdlVVJMID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSk7XG4gIGNvbnN0IHNVUkxWYXJpYWJsZXMgPSBzUGFnZVVSTC5zcGxpdCgnJicpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc1VSTFZhcmlhYmxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHNQYXJhbWV0ZXJTcGxpdCA9IHNVUkxWYXJpYWJsZXNbaV0uc3BsaXQoJz0nKTtcbiAgICBpZiAoZGVjb2RlKHNQYXJhbWV0ZXJTcGxpdFswXSkgPT09IHNQYXJhbSkge1xuICAgICAgcmV0dXJuIGRlY29kZShzUGFyYW1ldGVyU3BsaXRbMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0IGNvbnN0IGFkZFBhcmFtZXRlclRvVVJMID0gKHVybCwgcGFyYW0pID0+IHtcbiAgY29uc3QgbmV3VXJsID0gdXJsICsgKHVybC5zcGxpdCgnPycpWzFdID8gJyYnIDogJz8nKSArIHBhcmFtO1xuXG4gIHJldHVybiBwYXJhbSAhPT0gJycgPyBuZXdVcmwgOiB1cmw7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0T2JqZWN0S2V5cyA9IChvYmopID0+IHtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBmb3IgKGxldCBpIGluIG9iaikgeyAvL2VzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGtleXMucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuZXhwb3J0IGNvbnN0IGNhbnZhc0RyYXdCZ0NvdmVyID0gKGN0eCwgaW1nLCB4LCB5LCB3LCBoLCBvZmZzZXRYLCBvZmZzZXRZKSA9PiB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgeCA9IHkgPSAwO1xuICAgIHcgPSBjdHguY2FudmFzLndpZHRoO1xuICAgIGggPSBjdHguY2FudmFzLmhlaWdodDtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgb2Zmc2V0IGlzIGNlbnRlclxuICBvZmZzZXRYID0gdHlwZW9mIG9mZnNldFggPT09ICdudW1iZXInID8gb2Zmc2V0WCA6IDAuNTtcbiAgb2Zmc2V0WSA9IHR5cGVvZiBvZmZzZXRZID09PSAnbnVtYmVyJyA/IG9mZnNldFkgOiAwLjU7XG5cbiAgLy8ga2VlcCBib3VuZHMgWzAuMCwgMS4wXVxuICBpZiAob2Zmc2V0WCA8IDApIHtcbiAgICBvZmZzZXRYID0gMDtcbiAgfVxuICBpZiAob2Zmc2V0WSA8IDApIHtcbiAgICBvZmZzZXRZID0gMDtcbiAgfVxuICBpZiAob2Zmc2V0WCA+IDEpIHtcbiAgICBvZmZzZXRYID0gMTtcbiAgfVxuICBpZiAob2Zmc2V0WSA+IDEpIHtcbiAgICBvZmZzZXRZID0gMTtcbiAgfVxuXG4gIHZhciBpdyA9IGltZy53aWR0aCxcbiAgICBpaCA9IGltZy5oZWlnaHQsXG4gICAgciA9IE1hdGgubWluKHcgLyBpdywgaCAvIGloKSxcbiAgICBudyA9IGl3ICogciwgICAvLyBuZXcgcHJvcC4gd2lkdGhcbiAgICBuaCA9IGloICogciwgICAvLyBuZXcgcHJvcC4gaGVpZ2h0XG4gICAgY3gsIGN5LCBjdywgY2gsIGFyID0gMTtcblxuICAvLyBkZWNpZGUgd2hpY2ggZ2FwIHRvIGZpbGxcbiAgaWYgKG53IDwgdykge1xuICAgIGFyID0gdyAvIG53O1xuICB9XG4gIGlmIChuaCA8IGgpIHtcbiAgICBhciA9IGggLyBuaDtcbiAgfVxuICBudyAqPSBhcjtcbiAgbmggKj0gYXI7XG5cbiAgLy8gY2FsYyBzb3VyY2UgcmVjdGFuZ2xlXG4gIGN3ID0gaXcgLyAobncgLyB3KTtcbiAgY2ggPSBpaCAvIChuaCAvIGgpO1xuXG4gIGN4ID0gKGl3IC0gY3cpICogb2Zmc2V0WDtcbiAgY3kgPSAoaWggLSBjaCkgKiBvZmZzZXRZO1xuXG4gIC8vIG1ha2Ugc3VyZSBzb3VyY2UgcmVjdGFuZ2xlIGlzIHZhbGlkXG4gIGlmIChjeCA8IDApIHtcbiAgICBjeCA9IDA7XG4gIH1cbiAgaWYgKGN5IDwgMCkge1xuICAgIGN5ID0gMDtcbiAgfVxuICBpZiAoY3cgPiBpdykge1xuICAgIGN3ID0gaXc7XG4gIH1cbiAgaWYgKGNoID4gaWgpIHtcbiAgICBjaCA9IGloO1xuICB9XG5cbiAgLy8gZmlsbCBpbWFnZSBpbiBkZXN0LiByZWN0YW5nbGVcbiAgY3R4LmRyYXdJbWFnZShpbWcsIGN4LCBjeSwgY3csIGNoLCB4LCB5LCB3LCBoKTtcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbmV4cG9ydCBjb25zdCBoYXNQbGFjZWhvbGRlclN1cHBvcnQgPSAoKSA9PiB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgcmV0dXJuICgncGxhY2Vob2xkZXInIGluIGVsKTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc1BhZ2VJblhQTUZyYW1lID0gKCkgPT4ge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdy5UcmlkaW9uICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LlRyaWRpb24uV2ViLlVJLlNpdGVFZGl0ICE9PSAndW5kZWZpbmVkJztcbn07XG5cbmV4cG9ydCBjb25zdCBlbGVtZW50SW5WaWV3cG9ydCA9IChlbGVtZW50LCBhZGp1c3QsIHdpbmRvd0lubmVySGVpZ2h0KSA9PiB7XG4gIGNvbnN0ICRlbGVtZW50ID0gZWxlbWVudCBpbnN0YW5jZW9mIGpRdWVyeSA/IGVsZW1lbnQgOiAkKGVsZW1lbnQpO1xuXG4gIGlmICghJGVsZW1lbnQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgJHdpbmRvdyA9ICQod2luZG93KTtcbiAgY29uc3Qgc2Nyb2xsVG9wID0gJHdpbmRvdy5zY3JvbGxUb3AoKTtcbiAgbGV0IHdpbmRvd0hlaWdodCA9ICR3aW5kb3cuaGVpZ2h0KCk7XG4gIGxldCBhZGp1c3RUb3A7XG4gIGxldCBhZGp1c3RCb3R0b207XG5cbiAgLy8gRWxlbWVudCBzcGVjaWZpY3NcbiAgY29uc3QgZWxPZmZzZXQgPSAkZWxlbWVudC5vZmZzZXQoKTtcbiAgY29uc3QgZWxUb3AgPSBlbE9mZnNldC50b3A7XG4gIGNvbnN0IGVsQm90dG9tID0gZWxUb3AgKyAkZWxlbWVudC5oZWlnaHQoKTtcblxuICAvLyBEZWZhdWx0IHZhbHVlXG4gIGNvbnN0IGRlZmF1bHRBZGp1c3QgPSAoZ2V0QnJlYWtwb2ludFNpemUoKSA9PT0gJ3NtYWxsJykgPyAyMCA6IDUwO1xuXG4gIC8vIExSQS0xMTQ5NCBGaXggaU9TIGlzc3VlIHdpdGggd2luZG93IGhlaWdodC5cbiAgLy8gVGVtcG9yYXJpbHkgYWRkIG9wdGlvbiB0byBhbGxvdyB0aGlzIHNvIFFBIGlzIG5vdFxuICAvLyByZXF1aXJlZCBvbiBTdG9yeUdhbGxlcnkgKyBTdG9yeUFydGljbGVFbmhhbmNlZEltYWdlQmxvY2tcbiAgaWYgKHR5cGVvZiB3aW5kb3dJbm5lckhlaWdodCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93SW5uZXJIZWlnaHQpIHtcbiAgICB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB3aW5kb3dIZWlnaHQ7XG4gIH1cblxuICAvLyBTZXQgdmlld3BvcnRCb3R0b21cbiAgY29uc3Qgdmlld3BvcnRCb3R0b20gPSBzY3JvbGxUb3AgKyB3aW5kb3dIZWlnaHQ7XG5cbiAgLy8gQWxsb3cgYWRqdXN0IHRvIGJlIHNldCBkaWZmZXJlbnQgZnJvbSB0b3AvYm90dG9tXG4gIGlmICh0eXBlb2YgYWRqdXN0ID09PSAnb2JqZWN0Jykge1xuICAgIGFkanVzdFRvcCA9IGFkanVzdC50b3A7XG4gICAgYWRqdXN0Qm90dG9tID0gYWRqdXN0LmJvdHRvbTtcbiAgfSBlbHNlIHtcbiAgICBhZGp1c3RUb3AgPSBhZGp1c3QgfHwgZGVmYXVsdEFkanVzdDtcbiAgICBhZGp1c3RCb3R0b20gPSBhZGp1c3QgfHwgZGVmYXVsdEFkanVzdDtcbiAgfVxuXG4gIHJldHVybiAoISh2aWV3cG9ydEJvdHRvbSA8IGVsVG9wICsgYWRqdXN0VG9wIHx8IHNjcm9sbFRvcCA+IGVsQm90dG9tIC0gYWRqdXN0Qm90dG9tKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0UmFuZG9tU3RyaW5nID0gKGxlbmd0aCkgPT4ge1xuICBsZXQgZm9ybWF0dGVkTGVuZ3RoID0gcGFyc2VJbnQobGVuZ3RoLCAxMCkgfHwgMDtcbiAgZm9ybWF0dGVkTGVuZ3RoID0gZm9ybWF0dGVkTGVuZ3RoIDwgMCA/IDAgOiBmb3JtYXR0ZWRMZW5ndGg7XG5cbiAgY29uc3QgY2hhcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JztcbiAgY29uc3QgY2hvc2VuID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWRMZW5ndGg7IGkgKz0gMSkge1xuICAgIGNob3Nlbi5wdXNoKGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKSk7XG4gIH1cblxuICByZXR1cm4gY2hvc2VuLmpvaW4oJycpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEVhc2luZ1ZhbHVlID0gKHJhdGlvKSA9PiB7XG4gIGxldCBmb3JtYXR0ZWRSYXRpbyA9IHJhdGlvIDwgMCA/IDAgOiByYXRpbztcbiAgZm9ybWF0dGVkUmF0aW8gPSBmb3JtYXR0ZWRSYXRpbyA+IDEgPyAxIDogZm9ybWF0dGVkUmF0aW87XG5cbiAgLy8gQ29udmVydCB0aGUgcmF0aW8gdG8gYSBudW1iZXIgb2YgcmFkaWFucy4gMCBtYXBzIHRvIC1QSSwgMC41IG1hcHMgdG9cbiAgLy8gMCwgMSBtYXBzIHRvIFBJXG4gIGNvbnN0IHJhZGlhbnMgPSAoZm9ybWF0dGVkUmF0aW8gKiAoMiAqIE1hdGguUEkpKSAtIE1hdGguUEk7XG5cbiAgLy8gQ29udmVydCB0aGlzIHRvIGEgdmFsdWUgdXNpbmcgYSBjb3NpbmUgY3VydmUuIE5vdGUgdGhhdCBjb3NpbmUgZ2l2ZXNcbiAgLy8gYSB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxLCBzbyB3ZSBuZWVkIHRvIGFkZCAxIGFuZCBkaXZpZGUgYnkgMiB0b1xuICAvLyBrZWVwIGl0IGJldHdlZW4gMCBhbmQgMVxuICByZXR1cm4gKE1hdGguY29zKHJhZGlhbnMpICsgMSkgLyAyO1xufTtcblxuZXhwb3J0IGNvbnN0IGRpc2FibGVTY3JvbGwgPSAoKSA9PiB7XG4gIGNvbnN0ICR3aW5kb3cgPSAkKHdpbmRvdyk7XG4gIGNvbnN0IHNjcm9sbFRvcCA9ICR3aW5kb3cuc2Nyb2xsVG9wKCk7XG5cbiAgJHdpbmRvdy5vbihcbiAgICAnc2Nyb2xsLmRpc2FibGVTY3JvbGwgbW91c2V3aGVlbC5kaXNhYmxlU2Nyb2xsIERPTU1vdXNlU2Nyb2xsLmRpc2FibGVTY3JvbGwgdG91Y2htb3ZlLmRpc2FibGVTY3JvbGwnLFxuICAgIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICR3aW5kb3cuc2Nyb2xsVG9wKHNjcm9sbFRvcCk7XG4gICAgfVxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGVuYWJsZVNjcm9sbCA9ICgpID0+IHtcbiAgY29uc3QgJHdpbmRvdyA9ICQod2luZG93KTtcblxuICAkd2luZG93Lm9mZignc2Nyb2xsLmRpc2FibGVTY3JvbGwgbW91c2V3aGVlbC5kaXNhYmxlU2Nyb2xsIERPTU1vdXNlU2Nyb2xsLmRpc2FibGVTY3JvbGwgdG91Y2htb3ZlLmRpc2FibGVTY3JvbGwnKTtcbn07XG5cbmV4cG9ydCBjb25zdCBsaW1pdE51bWJlciA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IHtcbiAgaWYgKG1pbiA+IG1heCkge1xuICAgIGNvbnN0IG9sZE1pbiA9IG1pbjtcbiAgICBtaW4gPSBtYXg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBtYXggPSBvbGRNaW47IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBsb2FkSWdub3JlZFJlc3BvbnNpdmVJbWFnZXMgPSAoJGltYWdlcykgPT4ge1xuICAkaW1hZ2VzLnJlbW92ZUF0dHIoJ2RhdGEtcGljdHVyZS1pZ25vcmUnKTtcbiAgd2luZG93LnJpY2hzcG9uc2l2ZUltYWdlKCk7XG59O1xuXG5leHBvcnQgY29uc3QgdGhyb3R0bGUgPSAoZm4sIHRocmVzaGhvbGQsIHNjb3BlKSA9PiB7XG4gIGNvbnN0IHRocmVzaCA9IHRocmVzaGhvbGQgfHwgMjUwO1xuICBsZXQgbGFzdDtcbiAgbGV0IGRlZmVyVGltZXI7XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gc2NvcGUgfHwgdGhpcztcblxuICAgIGNvbnN0IG5vdyA9ICtuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKGxhc3QgJiYgbm93IDwgbGFzdCArIHRocmVzaCkge1xuICAgICAgLy8gaG9sZCBvbiB0byBpdFxuICAgICAgY2xlYXJUaW1lb3V0KGRlZmVyVGltZXIpO1xuICAgICAgZGVmZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsYXN0ID0gbm93O1xuICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH0sIHRocmVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBub3c7XG4gICAgICBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKiogKlxuICogTWVhc3VyZSB0ZXh0IHdpZHRoIHVzaW5nIEJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHRleHRcbiAqIEBwYXJhbSBwYXJlbnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgQ01TIFBvd2VyZWQgc29sdXRpb24gaW4gZnV0dXJlLlxuICovXG5leHBvcnQgY29uc3QgbWVhc3VyZVRleHRXaWR0aCA9ICh0ZXh0LCBwYXJlbnQpID0+IHtcbiAgaWYgKCF0ZXh0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjb25zdCBwYXIgPSBwYXJlbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gJ2F1dG8nO1xuICBjb250YWluZXIuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgY29udGFpbmVyLnN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcbiAgY29udGFpbmVyLmlubmVySFRNTCA9IHRleHQ7XG5cbiAgcGFyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gIGNvbnN0IHdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICBwYXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcblxuICByZXR1cm4gd2lkdGg7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VHJhbnNpdGlvbkVuZEV2ZW50ID0gKCkgPT4ge1xuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zha2VlbGVtZW50Jyk7XG4gIGNvbnN0IHRyYW5zaXRpb25zID0ge1xuICAgIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcbiAgICBPVHJhbnNpdGlvbjogJyBvVHJhbnNpdGlvbkVuZCcsXG4gICAgTW96VHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnLFxuICAgIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJ1xuICB9O1xuXG4gIGZvciAoY29uc3QgdHJhbnNpdGlvbiBpbiB0cmFuc2l0aW9ucykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKGVsLnN0eWxlW3RyYW5zaXRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uc1t0cmFuc2l0aW9uXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuZXhwb3J0IGNvbnN0IHRlbXBsYXRlID0gKHN0ciwgZGF0YSkgPT4ge1xuICAvLyBGaWd1cmUgb3V0IGlmIHdlJ3JlIGdldHRpbmcgYSB0ZW1wbGF0ZSwgb3IgaWYgd2UgbmVlZCB0b1xuICAvLyBsb2FkIHRoZSB0ZW1wbGF0ZSAtIGFuZCBiZSBzdXJlIHRvIGNhY2hlIHRoZSByZXN1bHQuXG4gIHZhciBmbiA9ICEvXFxXLy50ZXN0KHN0cikgP1xuICAgIHRlbXBsYXRlQ2FjaGVbc3RyXSA9IHRlbXBsYXRlQ2FjaGVbc3RyXSB8fFxuICAgIHRlbXBsYXRlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0cikuaW5uZXJIVE1MKSA6XG5cbiAgICAvLyBHZW5lcmF0ZSBhIHJldXNhYmxlIGZ1bmN0aW9uIHRoYXQgd2lsbCBzZXJ2ZSBhcyBhIHRlbXBsYXRlXG4gICAgLy8gZ2VuZXJhdG9yIChhbmQgd2hpY2ggd2lsbCBiZSBjYWNoZWQpLlxuICAgIG5ldyBGdW5jdGlvbihcIm9ialwiLFxuICAgICAgXCJ2YXIgcD1bXSxwcmludD1mdW5jdGlvbigpe3AucHVzaC5hcHBseShwLGFyZ3VtZW50cyk7fTtcIiArXG5cbiAgICAgIC8vIEludHJvZHVjZSB0aGUgZGF0YSBhcyBsb2NhbCB2YXJpYWJsZXMgdXNpbmcgd2l0aCgpe31cbiAgICAgIFwid2l0aChvYmope3AucHVzaCgnXCIgK1xuXG4gICAgICAvLyBDb252ZXJ0IHRoZSB0ZW1wbGF0ZSBpbnRvIHB1cmUgSmF2YVNjcmlwdFxuICAgICAgc3RyLnJlcGxhY2UoL1tcXHJcXHRcXG5dL2csIFwiIFwiKVxuICAgICAgICAucmVwbGFjZSgvJyg/PVteJV0qJT4pL2csIFwiXFx0XCIpXG4gICAgICAgIC5zcGxpdChcIidcIikuam9pbihcIlxcXFwnXCIpXG4gICAgICAgIC5zcGxpdChcIlxcdFwiKS5qb2luKFwiJ1wiKVxuICAgICAgICAucmVwbGFjZSgvPCU9KC4rPyklPi9nLCBcIicsJDEsJ1wiKVxuICAgICAgICAuc3BsaXQoXCI8JVwiKS5qb2luKFwiJyk7XCIpXG4gICAgICAgIC5zcGxpdChcIiU+XCIpLmpvaW4oXCJwLnB1c2goJ1wiKVxuICAgICAgKyBcIicpO31yZXR1cm4gcC5qb2luKCcnKTtcIik7XG5cbiAgLy8gUHJvdmlkZSBzb21lIGJhc2ljIGN1cnJ5aW5nIHRvIHRoZSB1c2VyXG4gIHJldHVybiBkYXRhID8gZm4oZGF0YSkgOiBmbjtcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbmV4cG9ydCBjb25zdCBpc0luVmlld3BvcnQgPSAoZWxlbWVudCkgPT4ge1xuICBjb25zdCB3aW4gPSAkKHdpbmRvdyk7XG5cbiAgY29uc3Qgdmlld3BvcnQgPSB7XG4gICAgdG9wOiB3aW4uc2Nyb2xsVG9wKCkgKyBnZXRTdGlja3lOYXZIZWlnaHQoKSxcbiAgICBib3R0b206IHdpbi5zY3JvbGxUb3AoKSArIHdpbi5oZWlnaHQoKSxcbiAgICBsZWZ0OiB3aW4uc2Nyb2xsTGVmdCgpXG4gIH07XG4gIHZpZXdwb3J0LnJpZ2h0ID0gdmlld3BvcnQubGVmdCArIHdpbi53aWR0aCgpO1xuXG4gIGNvbnN0IGJvdW5kcyA9IGVsZW1lbnQub2Zmc2V0KCk7XG4gIGJvdW5kcy5yaWdodCA9IGJvdW5kcy5sZWZ0ICsgZWxlbWVudC5vdXRlcldpZHRoKCk7XG4gIGJvdW5kcy5ib3R0b20gPSBib3VuZHMudG9wICsgZWxlbWVudC5vdXRlckhlaWdodCgpO1xuXG4gIHJldHVybiAoISh2aWV3cG9ydC5yaWdodCA8IGJvdW5kcy5sZWZ0IHx8IHZpZXdwb3J0LmxlZnQgPiBib3VuZHMucmlnaHQgfHwgdmlld3BvcnQuYm90dG9tIDwgYm91bmRzLnRvcCB8fCB2aWV3cG9ydC50b3AgPiBib3VuZHMuYm90dG9tKSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2Nyb2xsSWZOb3RJblZpZXdwb3J0ID0gKGVsZW1lbnQsIGRpc3BsYXlUb0JvdHRvbSkgPT4ge1xuICBpZiAoIWlzSW5WaWV3cG9ydChlbGVtZW50KSkge1xuICAgIC8vIE5vdCBpbiB2aWV3XG4gICAgY29uc3Qgc2Nyb2xsVG9Qb3MgPSBkaXNwbGF5VG9Cb3R0b20gPyBlbGVtZW50Lm9mZnNldCgpLnRvcCAtICQod2luZG93KS5pbm5lckhlaWdodCgpIDogKGVsZW1lbnQub2Zmc2V0KCkudG9wXG4gICAgICAtIGdldFN0aWNreU5hdkhlaWdodCgpKTtcbiAgICAkKCdodG1sLGJvZHknKS5hbmltYXRlKHsgc2Nyb2xsVG9wOiBzY3JvbGxUb1BvcyB9LCA4MDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0xhbmRSb3ZlciA9ICgpID0+IHtcbiAgcmV0dXJuICEhKCQoJ2JvZHkjbGFuZHJvdmVyJykubGVuZ3RoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRUYWJiYWJsZSA9IChlbGVtLCBjdXN0b21TZWxlY3RvcnMpID0+IHtcbiAgY29uc3QgZGVmYXVsdFNlbGVjdG9ycyA9IFtcbiAgICAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbaGlkZGVuXSknLFxuICAgICdzZWxlY3QnLFxuICAgICdhW2hyZWZdJyxcbiAgICAndGV4dGFyZWEnLFxuICAgICdidXR0b24nLFxuICAgICdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXhePVwiLVwiXSknXG4gIF07XG5cbiAgY29uc3Qgc2VsZWN0b3JUeXBlcyA9IChjdXN0b21TZWxlY3RvcnMpID8gZGVmYXVsdFNlbGVjdG9ycy5jb25jYXQoY3VzdG9tU2VsZWN0b3JzKSA6IGRlZmF1bHRTZWxlY3RvcnM7XG4gIGxldCBzZWxlY3RvcnMgPSBlbGVtLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JUeXBlcy5qb2luKCcsJykpO1xuICBzZWxlY3RvcnMgPSBBcnJheS5mcm9tKHNlbGVjdG9ycyk7XG4gIHNlbGVjdG9ycyA9IHNlbGVjdG9ycy5maWx0ZXIoKHNlbGVjdG9yKSA9PiB7XG4gICAgbGV0IHRhYmJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoIXNlbGVjdG9yLm9mZnNldFBhcmVudCB8fCBzZWxlY3Rvci5vZmZzZXRXaWR0aCA9PT0gMFxuICAgICAgfHwgc2VsZWN0b3Iub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XG4gICAgICB0YWJiYWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW52aXNpYmxlKGVsKSB7XG4gICAgICBpZiAoZWwuc3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicgfHwgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHRhYmJhYmxlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBpc0ludmlzaWJsZShlbC5wYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXNJbnZpc2libGUoc2VsZWN0b3IpO1xuICAgIGlmICh0YWJiYWJsZSkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICByZXR1cm4gc2VsZWN0b3JzO1xufTtcblxuZXhwb3J0IGNvbnN0IGxvY2tUYWJiYWJsZXMgPSAodGFiYmFibGVzKSA9PiB7XG4gIHRhYmJhYmxlcy5mb3JFYWNoKChlbCwgaSkgPT4ge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5Q29kZSAhPT0gS2V5Q29kZS5UQUIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgaWYgKHRhYmJhYmxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0YWJiYWJsZXNbMF0uZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgdGFiYmFibGVzW3RhYmJhYmxlcy5sZW5ndGggLSAxXS5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhYmJhYmxlc1tpICsgMV0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID09PSB0YWJiYWJsZXMubGVuZ3RoIC0gMSAmJiAhZS5zaGlmdEtleSkge1xuICAgICAgICB0YWJiYWJsZXNbMF0uZm9jdXMoKTtcbiAgICAgIH0gZWxzZSBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICB0YWJiYWJsZXNbaSAtIDFdLmZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWJiYWJsZXNbaSArIDFdLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGJhbGFuY2VFbGVtZW50SGVpZ2h0ID0gKGVsZW1lbnRzLCBhbGxvd2VkT2Zmc2V0ID0gMCkgPT4ge1xuICBjb25zdCBjb2x1bW5zID0ge307XG4gIGlmICghZWxlbWVudHMpIHtcbiAgICByZXR1cm4gY29sdW1ucztcbiAgfVxuICBjb25zdCBlbGVtZW50c0FycmF5ID0gW10uc2xpY2UuY2FsbChlbGVtZW50cyk7XG4gIGxldCBoZWlnaHRUb3RhbCA9IDA7XG4gIGNvbnN0IGhlaWdodHNBcnJheSA9IGVsZW1lbnRzQXJyYXkubWFwKChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgZWxlbWVudEhlaWdodCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIGhlaWdodFRvdGFsICs9IGVsZW1lbnRIZWlnaHQ7XG4gICAgcmV0dXJuIGVsZW1lbnRIZWlnaHQ7XG4gIH0pO1xuICBjb25zdCBnZXRCYWxhbmNlZEluZGV4ID0gKGFycmF5LCB0YXJnZXQsIHJ1bm5pbmdUb3RhbCA9IDAsIGluZGV4ID0gMCkgPT4ge1xuICAgIGNvbnN0IGlzUmVjdXJzaXZlID0gISFhcnJheVtpbmRleF0gJiYgcnVubmluZ1RvdGFsICsgYXJyYXlbaW5kZXhdIDw9ICh0YXJnZXQgLSBhbGxvd2VkT2Zmc2V0KTtcbiAgICByZXR1cm4gaXNSZWN1cnNpdmUgPyBnZXRCYWxhbmNlZEluZGV4KGFycmF5LCB0YXJnZXQsIHJ1bm5pbmdUb3RhbCArIGFycmF5W2luZGV4XSwgaW5kZXggKyAxKSA6IGluZGV4O1xuICB9O1xuICBjb25zdCBzcGxpdEluZGV4ID0gZ2V0QmFsYW5jZWRJbmRleChoZWlnaHRzQXJyYXksIGhlaWdodFRvdGFsIC8gMikgKyAxO1xuICBjb2x1bW5zLmNvbHVtbnMxID0gZWxlbWVudHNBcnJheS5zbGljZSgwLCBzcGxpdEluZGV4KTtcbiAgY29sdW1ucy5jb2x1bW5zMiA9IGVsZW1lbnRzQXJyYXkuc2xpY2Uoc3BsaXRJbmRleCwgZWxlbWVudHNBcnJheS5sZW5ndGgpO1xuICBjb2x1bW5zLmhlaWdodHNBcnJheSA9IGhlaWdodHNBcnJheTtcbiAgcmV0dXJuIGNvbHVtbnM7XG59O1xuXG5leHBvcnQgY29uc3QgZXZlbnRUcmlnZ2VyID0gKGVsZW0sIGV2ZW50VHlwZSwgZGV0YWlsID0ge30sIGJ1YmJsZXMgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudFR5cGUsIHsgZGV0YWlsLCBidWJibGVzIH0pO1xuICBlbGVtLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbnZlcnRFbGVtZW50Q29sbGVjdGlvblRvQXJyYXkgPSAoY29sbGVjdGlvbikgPT4ge1xuICBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGNvbGxlY3Rpb24gaW5zdGFuY2VvZiBqUXVlcnkpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVMaXN0ID8gW10uc2xpY2UuY2FsbChjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24uZ2V0KCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGNvbnN0IHJhbmRvbWlzZUVsZW1lbnRzID0gKGVsZW1lbnRzQ29sbGVjdGlvbikgPT4ge1xuICBjb25zdCBlbGVtZW50cyA9IGNvbnZlcnRFbGVtZW50Q29sbGVjdGlvblRvQXJyYXkoZWxlbWVudHNDb2xsZWN0aW9uKTtcbiAgaWYgKCFlbGVtZW50cyB8fCAhZWxlbWVudHMubGVuZ3RoKSByZXR1cm47XG4gIGNvbnN0IGNsb25lZEVsZW1lbnRzID0gZWxlbWVudHMubWFwKGVsZW1lbnQgPT4gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuICBjbG9uZWRFbGVtZW50cy5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50LCBpbmMpID0+IGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY2xvbmVkRWxlbWVudHNbaW5jXSwgZWxlbWVudCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzRWxlbWVudFZlcnRpY2FsbHlTY3JvbGxhYmxlID0gKGVsKSA9PiB7XG4gIHJldHVybiAoZWwgJiYgKGVsLnNjcm9sbEhlaWdodCA+IGVsLm9mZnNldEhlaWdodCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNoZWNrRGVmaW5lZCA9IGl0ZW0gPT4gaXRlbSAhPT0gdW5kZWZpbmVkICYmIGl0ZW0gIT09IG51bGw7XG5cbmV4cG9ydCBjb25zdCB0YWJsaXN0TmF2aWdhdGlvbiA9ICh0YWJsaXN0KSA9PiB7XG4gIGNvbnN0IG9yaWVudGF0aW9uID0gdGFibGlzdC5nZXRBdHRyaWJ1dGUoJ2FyaWEtb3JpZW50YXRpb24nKTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IG9yaWVudGF0aW9uICYmIG9yaWVudGF0aW9uID09PSAndmVydGljYWwnO1xuICBjb25zdCB0YWJzID0gdGFibGlzdC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInRhYlwiXScpO1xuICBjb25zdCBrZXlzID0gS2V5Q29kZTtcblxuICBjb25zdCBmb2N1c0ZpcnN0VGFiID0gKCkgPT4gdGFic1swXS5mb2N1cygpO1xuICBjb25zdCBmb2N1c0xhc3RUYWIgPSAoKSA9PiB0YWJzW3RhYnMubGVuZ3RoIC0gMV0uZm9jdXMoKTtcblxuICBjb25zdCBmb2N1c1ByZXZpb3VzVGFiID0gKGN1cnJlbnRUYWIpID0+IHtcbiAgICBjb25zdCB0YWJJbmRleCA9IFsuLi50YWJzXS5maW5kSW5kZXgoZWxlbWVudCA9PiBlbGVtZW50ID09PSBjdXJyZW50VGFiKTtcbiAgICBpZiAodGFiSW5kZXggPT09IDApIHtcbiAgICAgIGZvY3VzTGFzdFRhYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJzW3RhYkluZGV4IC0gMV0uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZm9jdXNOZXh0VGFiID0gKGN1cnJlbnRUYWIpID0+IHtcbiAgICBjb25zdCB0YWJJbmRleCA9IFsuLi50YWJzXS5maW5kSW5kZXgoZWxlbWVudCA9PiBlbGVtZW50ID09PSBjdXJyZW50VGFiKTtcbiAgICBjb25zdCB0YWJzTGVuZ3RoWmVyb0luZGV4ID0gdGFicy5sZW5ndGggLSAxO1xuICAgIGlmICh0YWJJbmRleCA9PT0gdGFic0xlbmd0aFplcm9JbmRleCkge1xuICAgICAgZm9jdXNGaXJzdFRhYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJzW3RhYkluZGV4ICsgMV0uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlVGFibGlzdEtleWRvd25FdmVudHMgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBrZXkgPSBldmVudC5rZXlDb2RlO1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIGtleXMuRU5EOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBmb2N1c0xhc3RUYWIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGtleXMuSE9NRTpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZm9jdXNGaXJzdFRhYigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Uga2V5cy5MRUZUOlxuICAgICAgY2FzZSBrZXlzLlVQOlxuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZm9jdXNQcmV2aW91c1RhYihldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Uga2V5cy5SSUdIVDpcbiAgICAgIGNhc2Uga2V5cy5ET1dOOlxuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZm9jdXNOZXh0VGFiKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVRhYmxpc3RLZXl1cEV2ZW50cyA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGtleSA9IGV2ZW50LmtleUNvZGU7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2Uga2V5cy5MRUZUOlxuICAgICAgICBmb2N1c1ByZXZpb3VzVGFiKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Uga2V5cy5SSUdIVDpcbiAgICAgICAgZm9jdXNOZXh0VGFiKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICB0YWJzLmZvckVhY2goKHRhYikgPT4ge1xuICAgIHRhYi5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlVGFibGlzdEtleWRvd25FdmVudHMsIGZhbHNlKTtcbiAgICBpZiAoIWlzVmVydGljYWwpIHtcbiAgICAgIHRhYi5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZVRhYmxpc3RLZXl1cEV2ZW50cywgZmFsc2UpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNFbXB0eSA9IChvYmopID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydCBjb25zdCByZXBsYWNlQWxsID0gKHN0cmluZywgc2VhcmNoLCByZXBsYWNlbWVudCkgPT4ge1xuICByZXR1cm4gc3RyaW5nLnNwbGl0KHNlYXJjaCkuam9pbihyZXBsYWNlbWVudCk7XG59O1xuXG5leHBvcnQgY29uc3QgZHhTZXRUaW1lb3V0ID0gKGNiLCB0aW1lKSA9PiB7XG4gIHNldFRpbWVvdXQoY2IsIHRpbWUpO1xuXG4gIGlmICh3aW5kb3cuYXBwUmVhZHlFdmVudC5pbml0aWF0ZWQpIHtcbiAgICBhcHBSZWFkeVRpbWVyLmFkZCh0aW1lKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuYXBwUmVhZHlFdmVudC50aW1lb3V0ICs9IHRpbWU7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBEeFJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUgPSAoY2IpID0+IHtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IoKSk7XG4gIH0pO1xufTtcblxuY29uc3QgbG9hZGluZ1NwaW5uZXJUb2dnbGVCdXR0b25TdGF0ZUFuZENvbnRlbnQgPSAodGFyZ2V0KSA9PiB7XG4gIGNvbnN0IHRhcmdldEVsZW1lbnQgPSB0YXJnZXQ7XG5cbiAgaWYgKHRhcmdldC50YWdOYW1lID09PSAnQlVUVE9OJykge1xuICAgIHRhcmdldEVsZW1lbnQuZGlzYWJsZWQgPSB0cnVlO1xuICB9XG4gIHRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbG9hZGluZycpO1xuXG4gIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRhcmdldEVsZW1lbnQ7XG4gIFsuLi5jaGlsZHJlbl0uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gY2hpbGQ7XG4gICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIGFkZER4TG9hZGluZ1NwaW5uZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCBUaGUgYnV0dG9uL2xpbmsgdGhhdCB0aGUgbG9hZGluZyBzcGlubmVyIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvXG4gKi9cbmV4cG9ydCBjb25zdCBhZGREeExvYWRpbmdTcGlubmVyID0gKHRhcmdldCkgPT4ge1xuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGljb25NYXJrdXAgPSAnPGRpdiBjbGFzcz1cIkR4TG9hZGluZ1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjxkaXYgY2xhc3M9XCJEeExvYWRpbmdfX2ljb25cIiBhcmlhLWV4cGFuZGVkPVwidHJ1ZVwiPjwvZGl2PjwvZGl2Pic7XG4gIGNvbnN0IGxvYWRpbmdJY29uID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoaWNvbk1hcmt1cCk7XG5cbiAgbG9hZGluZ1NwaW5uZXJUb2dnbGVCdXR0b25TdGF0ZUFuZENvbnRlbnQodGFyZ2V0KTtcblxuICB0YXJnZXQuYXBwZW5kQ2hpbGQobG9hZGluZ0ljb24pO1xufTtcblxuLyoqXG4gKiByZW1vdmVEeExvYWRpbmdTcGlubmVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGhlIGJ1dHRvbi9saW5rIHRoYXQgdGhlIGxvYWRpbmcgc3Bpbm5lciBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZyB8fCBIVE1MRWxlbWVudH0gcmVwbGFjZSBUaGUgc3RyaW5nIHlvdSB3b3VsZCBsaWtlIHRvIHJlcGxhY2UgdGhlIGxvYWRpbmcgc3Bpbm5lciB3aXRoIChleHBlY3RlZCB0byBiZSB0aGUgdGV4dCBvcmlnaW5hbGx5IGluIHRoZSBidXR0b24pXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVEeExvYWRpbmdTcGlubmVyID0gKHRhcmdldCkgPT4ge1xuICBjb25zdCB0YXJnZXRFbGVtZW50ID0gdGFyZ2V0O1xuXG4gIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0JVVFRPTicpIHtcbiAgICB0YXJnZXRFbGVtZW50LmRpc2FibGVkID0gZmFsc2U7XG4gIH1cbiAgdGFyZ2V0RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdsb2FkaW5nJyk7XG5cbiAgY29uc3QgbG9hZGluZ0ljb24gPSB0YXJnZXRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5EeExvYWRpbmcnKTtcbiAgdGFyZ2V0RWxlbWVudC5yZW1vdmVDaGlsZChsb2FkaW5nSWNvbik7XG5cbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGFyZ2V0RWxlbWVudDtcbiAgWy4uLmNoaWxkcmVuXS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBjaGlsZDtcbiAgICBlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBhZGREeEVsZW1lbnRMb2FkaW5nU3Bpbm5lciA9ICh0YXJnZXQpID0+IHtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBpY29uTWFya3VwID0gYDxkaXYgY2xhc3M9XCJEeExvYWRpbmdcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICA8c3ZnIHZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB2aWV3Qm94PVwiMCAwIDg4IDg4XCIgc3R5bGU9XCJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDg4IDg4O1wiIHhtbDpzcGFjZT1cInByZXNlcnZlXCI+XG4gICAgPHBhdGggZmlsbD1cIiNGRkZGRkZcIiBzdHlsZT1cIm9wYWNpdHk6IC4yO1wiIGQ9XCJNNDQsNWMyMS41LDAsMzksMTcuNSwzOSwzOVM2NS41LDgzLDQ0LDgzUzUsNjUuNSw1LDQ0UzIyLjUsNSw0NCw1IE00NCwwQzE5LjcsMCwwLDE5LjcsMCw0NHMxOS43LDQ0LDQ0LDQ0IHM0NC0xOS43LDQ0LTQ0UzY4LjMsMCw0NCwwTDQ0LDB6XCIvPlxuICAgIDxwYXRoIGZpbGw9XCIjRjBGMEYwXCIgZD1cIk04NS41LDQ2LjRjLTEuNCwwLTIuNS0xLjEtMi41LTIuNUM4MywyMi41LDY1LjUsNSw0NC4xLDVjLTEuNCwwLTIuNS0xLjEtMi41LTIuNVM0Mi43LDAsNDQuMSwwIEM2OC4zLDAsODgsMTkuNyw4OCw0My45Qzg4LDQ1LjMsODYuOSw0Ni40LDg1LjUsNDYuNHpcIj5cbiAgICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9XCJ0cmFuc2Zvcm1cIiB0eXBlPVwicm90YXRlXCIgZnJvbT1cIjAgNDQgNDRcIiB0bz1cIjM2MCA0NCA0NFwiIGR1cj1cIjEuNXNcIiByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIj48L2FuaW1hdGVUcmFuc2Zvcm0+XG4gICAgPC9wYXRoPlxuICAgIDwvc3ZnPlxuICA8L2Rpdj5gO1xuICBjb25zdCBsb2FkaW5nSWNvbiA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGljb25NYXJrdXApO1xuXG4gIGxvYWRpbmdTcGlubmVyVG9nZ2xlQnV0dG9uU3RhdGVBbmRDb250ZW50KHRhcmdldCk7XG5cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKGxvYWRpbmdJY29uKTtcbn07XG5cbmV4cG9ydCBjb25zdCBsb2NhbFN0b3JhZ2VBdmFpbGFibGUgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdmZWF0dXJlX3Rlc3QnLCAneWVzJyk7XG4gICAgICAgIGlmICh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2ZlYXR1cmVfdGVzdCcpID09PSAneWVzJykge1xuICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZmVhdHVyZV90ZXN0Jyk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBhZGRTY3JpcHRGb3JCYXphYXJWb2ljZSA9IChzY3JpcHRVUkwpID0+IHtcbiAgaWYgKHNjcmlwdFVSTC50cmltKCkgIT09ICcnICYmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBzY3JpcHRbc3JjPScke3NjcmlwdFVSTH0nXWApKS5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBiYXphYXJWb2ljZVNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIGJhemFhclZvaWNlU2NyaXB0LnNldEF0dHJpYnV0ZSgnc3JjJywgc2NyaXB0VVJMKTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGJhemFhclZvaWNlU2NyaXB0KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVxdWFsaXNlSGVpZ2h0cyA9IChlbGVtZW50cykgPT4ge1xuICBsZXQgbWF4SGVpZ2h0ID0gMDtcbiAgWy4uLmVsZW1lbnRzXS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gIH0pO1xuICBbLi4uZWxlbWVudHNdLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICBpZiAoaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XG4gICAgICBtYXhIZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICB9KTtcbiAgWy4uLmVsZW1lbnRzXS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHttYXhIZWlnaHR9cHhgO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUN1cnJlbnREYXRlID0gKCkgPT4ge1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gIHJldHVybiAoXG4gICAgRGF0ZS5VVEMoXG4gICAgICB0b2RheS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgdG9kYXkuZ2V0VVRDTW9udGgoKSxcbiAgICAgIHRvZGF5LmdldFVUQ0RhdGUoKSxcbiAgICAgIHRvZGF5LmdldFVUQ0hvdXJzKCksXG4gICAgICB0b2RheS5nZXRVVENNaW51dGVzKClcbiAgICApXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgcHJldmVudEFjdGlvbk9uRGVlcExpbmsgPSAoZXZlbnQpID0+IHtcbiAgY29uc3QgbGlua0xvY2F0aW9uID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgaWYgKGNoZWNrRGVlcExpbmsobGlua0xvY2F0aW9uKSkgeyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9XG59O1xuIiwiaW1wb3J0IHsgUnVsZXNDb25uZWN0IH0gZnJvbSAnQGNvbmZpZ3VyZWNvbm5lY3QvcnVsZXNjb25uZWN0anMnO1xuaW1wb3J0IER4QWNjb3JkaW9uIGZyb20gJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvRHhBY2NvcmRpb24vanMvRHhBY2NvcmRpb24nO1xuaW1wb3J0IHsgaXNFbXB0eSwgY2hlY2tEZWZpbmVkIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgZm9ybWF0UHJpY2UgZnJvbSAnLi9mb3JtYXRQcmljZSc7XG5cbmV4cG9ydCBjb25zdCBoYXNGYWxsYmFja1ByaWNlVHlwZSA9IChjbXNTZXR0aW5ncyA9IHt9LCBjdXJyZW50UHJpY2VUeXBlID0gJycpID0+IHtcbiAgY29uc3QgeyBkZWZhdWx0UHJpY2luZ1R5cGVLZXksIGZhbGxiYWNrUHJpY2luZ1R5cGVLZXkgfSA9IGNtc1NldHRpbmdzO1xuXG4gIGlmICghZGVmYXVsdFByaWNpbmdUeXBlS2V5IHx8ICFmYWxsYmFja1ByaWNpbmdUeXBlS2V5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIChjdXJyZW50UHJpY2VUeXBlID09PSBkZWZhdWx0UHJpY2luZ1R5cGVLZXkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGhhc05vdEZhbGxiYWNrUHJpY2VUeXBlID0gKGNtc1NldHRpbmdzLCBjdXJyZW50UHJpY2VUeXBlKSA9PlxuICAhaGFzRmFsbGJhY2tQcmljZVR5cGUoY21zU2V0dGluZ3MsIGN1cnJlbnRQcmljZVR5cGUpO1xuXG4vKipcbiAqIEFkZCBmYWxsYmFjayBwcmljZSBzdXBwb3J0IGZvdCBUZWNoIFNwZWNzIFRhYmxlXG4gKlxuICogSWYgQXV0aG9yIGhhcyBzcGVjaWZpZWQgZmFsbGJhY2sgc2V0dGluZ3MgYW5kIGRlZmF1bHQgcHJpY2UgdHlwZSBkb2VzIG5vdCBleGlzdHMgZnJvbSByZXNwb25zZSByZXR1cm5lZFxuICogZnJvbSBSdWxlIEVuZ2luZSBBUEksIHRoZW4gY29weSB0aGUgZmFsbGJhY2sgcHJpY2UgaW5mb3JtYXRpb24gaW50byBkZWZhdWx0IGFuZCByZXR1cm4gdGhlbSBhcyBhIG5ldyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNtc1NldHRpbmdzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBhZGRGYWxsYmFja1ByaWNlID0gKGNtc1NldHRpbmdzKSA9PiB7XG4gIGNvbnN0IG5ld1NldHRpbmdzID0geyAuLi5jbXNTZXR0aW5ncyB9O1xuICBjb25zdCB7IGRlZmF1bHRQcmljaW5nVHlwZUtleSwgZmFsbGJhY2tQcmljaW5nVHlwZUtleSwgZmFsbGJhY2tQcmljaW5nVHlwZUxhYmVsIH0gPSBuZXdTZXR0aW5ncztcblxuICBpZiAoIWRlZmF1bHRQcmljaW5nVHlwZUtleSB8fCAhZmFsbGJhY2tQcmljaW5nVHlwZUtleSkge1xuICAgIHJldHVybiBuZXdTZXR0aW5ncztcbiAgfVxuXG4gIGNvbnN0IHsgcHJpY2UgfSA9IG5ld1NldHRpbmdzWydmZWF0dXJlLWxpc3QnXVswXS5mZWF0dXJlWzBdO1xuXG4gIGlmIChwcmljZVtkZWZhdWx0UHJpY2luZ1R5cGVLZXldICYmIHByaWNlW2RlZmF1bHRQcmljaW5nVHlwZUtleV0udmFsdWUgPiAwKSB7XG4gICAgcmV0dXJuIG5ld1NldHRpbmdzO1xuICB9XG5cbiAgbmV3U2V0dGluZ3NbJ2ZlYXR1cmUtbGlzdCddWzBdLmZlYXR1cmVbMF0ucHJpY2VbZGVmYXVsdFByaWNpbmdUeXBlS2V5XSA9IHByaWNlW2ZhbGxiYWNrUHJpY2luZ1R5cGVLZXldO1xuXG4gIC8vIEZpbmQgJiBSZXBsYWNlIFByaWNlIExhYmVsIHRvIGZhbGxiYWNrXG4gIGlmIChmYWxsYmFja1ByaWNpbmdUeXBlTGFiZWwgJiYgQXJyYXkuaXNBcnJheShuZXdTZXR0aW5ncy50YWJsZSkpIHtcbiAgICBuZXdTZXR0aW5ncy50YWJsZSA9IG5ld1NldHRpbmdzLnRhYmxlLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgY29uc3QgbmV3SXRlbSA9IHsgLi4uaXRlbSB9O1xuICAgICAgaWYgKG5ld0l0ZW0ua2V5ID09PSBkZWZhdWx0UHJpY2luZ1R5cGVLZXkpIHtcbiAgICAgICAgbmV3SXRlbS5rZXkgPSBmYWxsYmFja1ByaWNpbmdUeXBlS2V5O1xuICAgICAgICBuZXdJdGVtLnRleHQgPSBmYWxsYmFja1ByaWNpbmdUeXBlTGFiZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJdGVtO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG5ld1NldHRpbmdzO1xufTtcblxuZXhwb3J0IGNvbnN0IHN1cHByZXNzUHJpY2luZ0lmWmVybyA9IChwcmljaW5nKSA9PiB7XG4gIGlmICghcHJpY2luZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghKCdmZWF0dXJlLWxpc3QnIGluIHByaWNpbmcpIHx8ICFBcnJheS5pc0FycmF5KHByaWNpbmdbJ2ZlYXR1cmUtbGlzdCddKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGZlYXR1cmVQcmljZXMgPSBwcmljaW5nWydmZWF0dXJlLWxpc3QnXVswXS5mZWF0dXJlWzBdLnByaWNlO1xuXG4gIE9iamVjdC5rZXlzKGZlYXR1cmVQcmljZXMpLmZvckVhY2goKHByaWNlVHlwZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VGbG9hdChmZWF0dXJlUHJpY2VzW3ByaWNlVHlwZV0udmFsdWUpO1xuXG4gICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkgfHwgdmFsdWUgPD0gMCkge1xuICAgICAgaWYgKGhhc05vdEZhbGxiYWNrUHJpY2VUeXBlKHByaWNpbmcsIHByaWNlVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYW1lcGxhdGUgY29udGFpbnMgYSBwcm9kdWN0IHdpdGggMCBwcmljZS4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGdldFRleHQgPSAob2JqLCBsYW5nKSA9PiB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICByZXR1cm4ga2V5cy5sZW5ndGggPT09IDEgPyBvYmpba2V5c1swXV0gOiBvYmpbbGFuZ107XG59O1xuXG5leHBvcnQgY29uc3QgdGFibGVUZW1wbGF0ZSA9IChoZWFkaW5ncywgZGF0YSwgbGFuZywgaXNQcmljaW5nID0gZmFsc2UsIGZvcm1hdCA9ICcnKSA9PiB7XG4gIGNvbnN0IHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcbiAgdGFibGUuY2xhc3NMaXN0LmFkZCgnVGVjaFNwZWNzVGFibGUnKTtcblxuICBjb25zdCBjYXZlYXRTZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNhdmVhdFNlY3Rpb24uY2xhc3NMaXN0LmFkZCgnVGVjaFNwZWNzVGFibGVfX2NhdmVhdHMnKTtcblxuICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGhlYWRpbmdzLCAoaGVhZGluZywgaSkgPT4ge1xuICAgIGNvbnN0IGhlYWRpbmdUZXh0ID0gaXNQcmljaW5nID8gaGVhZGluZy50ZXh0IDogZ2V0VGV4dChoZWFkaW5nLmRlc2NyaXB0aW9uLCBsYW5nKTtcbiAgICBjb25zdCBwcmljZUNhdmVhdCA9IGhlYWRpbmcuY2F2ZWF0IHx8ICcnO1xuICAgIGNvbnN0IHRkVGV4dCA9IGlzUHJpY2luZyA/IGAke2Zvcm1hdFByaWNlKGRhdGFbaGVhZGluZy5rZXldLnZhbHVlLCBmb3JtYXQpfSR7cHJpY2VDYXZlYXR9YCA6IGdldFRleHQoZGF0YVtpXS5kZXNjcmlwdGlvbiwgbGFuZyk7XG5cbiAgICBpZiAoY2hlY2tEZWZpbmVkKGhlYWRpbmdUZXh0KSAmJiBjaGVja0RlZmluZWQodGRUZXh0KSkge1xuICAgICAgY29uc3QgdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xuICAgICAgdGguY2xhc3NMaXN0LmFkZCgnVGVjaFNwZWNzVGFibGVfX2hlYWRpbmcnKTtcbiAgICAgIHRoLnNldEF0dHJpYnV0ZSgnc2NvcGUnLCAncm93Jyk7XG4gICAgICB0aC5pbm5lckhUTUwgPSBoZWFkaW5nVGV4dDtcblxuICAgICAgY29uc3QgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgdGQuY2xhc3NMaXN0LmFkZCgnVGVjaFNwZWNzVGFibGVfX2NlbGwnKTtcbiAgICAgIHRkLmlubmVySFRNTCA9IHRkVGV4dDtcblxuICAgICAgY29uc3Qgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICAgIHJvdy5jbGFzc0xpc3QuYWRkKCdUZWNoU3BlY3NUYWJsZV9fcm93Jyk7XG4gICAgICByb3cuYXBwZW5kQ2hpbGQodGgpO1xuICAgICAgcm93LmFwcGVuZENoaWxkKHRkKTtcblxuICAgICAgaWYgKGlzUHJpY2luZykge1xuICAgICAgICByb3cuc2V0QXR0cmlidXRlKCdydWxlLWVuZ2luZS1wcmljZS10eXBlJywgaGVhZGluZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICB0YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xuICAgIH0gZWxzZSBpZiAoY2hlY2tEZWZpbmVkKHRkVGV4dCkpIHtcbiAgICAgIGNvbnN0IGNhdmVhdFRvQWRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgICAgY2F2ZWF0VG9BZGQuY2xhc3NMaXN0LmFkZCgnVGVjaFNwZWNzVGFibGVfX2NhdmVhdCcpO1xuICAgICAgY2F2ZWF0VG9BZGQuaW5uZXJIVE1MID0gdGRUZXh0O1xuICAgICAgY2F2ZWF0U2VjdGlvbi5hcHBlbmRDaGlsZChjYXZlYXRUb0FkZCk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBkYXRhU2VjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkYXRhU2VjdGlvbi5jbGFzc0xpc3QuYWRkKCdUZWNoU3BlY3NUYWJsZV9fY29udGFpbmVyJyk7XG5cbiAgZGF0YVNlY3Rpb24uYXBwZW5kQ2hpbGQodGFibGUpO1xuICBkYXRhU2VjdGlvbi5hcHBlbmRDaGlsZChjYXZlYXRTZWN0aW9uKTtcblxuICByZXR1cm4gZGF0YVNlY3Rpb247XG59O1xuXG5jb25zdCBhY2NvcmRpb25TZWN0aW9uVGVtcGxhdGUgPSAodGVtcGxhdGUsIHByZWZpeCwgaSkgPT4ge1xuICBjb25zdCBuZXdTZWN0aW9uID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICBjb25zdCBidXR0b24gPSBuZXdTZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5keEFjY29yZGlvbl9fdHJpZ2dlcicpO1xuICBjb25zdCBwYW5lbCA9IG5ld1NlY3Rpb24ucXVlcnlTZWxlY3RvcignLmR4QWNjb3JkaW9uX19wYW5lbCcpO1xuICBjb25zdCBwYW5lbElkID0gYCR7cHJlZml4fS1wYW5lbC0tJHtpfWA7XG4gIGNvbnN0IGJ1dHRvbklkID0gYCR7cHJlZml4fS1idXR0b24tLSR7aX1gO1xuXG4gIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnLCBwYW5lbElkKTtcbiAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnaWQnLCBidXR0b25JZCk7XG4gIHBhbmVsLnNldEF0dHJpYnV0ZSgnaWQnLCBwYW5lbElkKTtcbiAgcGFuZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCBidXR0b25JZCk7XG5cbiAgcmV0dXJuIG5ld1NlY3Rpb247XG59O1xuXG5jb25zdCBhY2NvcmRpb25QcmljaW5nU2VjdGlvbiA9IChkYXRhLCB0ZW1wbGF0ZSwgaSwgcHJlZml4LCBsYW5nKSA9PiB7XG4gIGNvbnN0IG5ld1NlY3Rpb24gPSBhY2NvcmRpb25TZWN0aW9uVGVtcGxhdGUodGVtcGxhdGUsIHByZWZpeCwgaSk7XG4gIGNvbnN0IHtcbiAgICBhY2NvcmRpb25UaXRsZSxcbiAgICB0YWJsZSxcbiAgICBmb3JtYXQsXG4gICAgY2F2ZWF0XG4gIH0gPSBkYXRhO1xuXG4gIGNvbnN0IHRhYmxlVG9BZGQgPSB0YWJsZVRlbXBsYXRlKHRhYmxlLCBkYXRhWydmZWF0dXJlLWxpc3QnXVswXS5mZWF0dXJlWzBdLnByaWNlLCBsYW5nLCB0cnVlLCBmb3JtYXQsIGNhdmVhdCk7XG5cbiAgbmV3U2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcuZHhBY2NvcmRpb25fX3RpdGxlJykuaW5uZXJIVE1MID0gYWNjb3JkaW9uVGl0bGU7XG4gIG5ld1NlY3Rpb24ucXVlcnlTZWxlY3RvcignLmR4QWNjb3JkaW9uX19wYW5lbCcpLmFwcGVuZENoaWxkKHRhYmxlVG9BZGQpO1xuXG4gIHJldHVybiBuZXdTZWN0aW9uO1xufTtcblxuY29uc3QgYnVpbGRBY2NvcmRpb25TZWN0aW9uID0gKHRhYmxlLCB0ZW1wbGF0ZSwgaSwgcHJlZml4LCBsYW5nKSA9PiB7XG4gIGNvbnN0IHNlY3Rpb24gPSBhY2NvcmRpb25TZWN0aW9uVGVtcGxhdGUodGVtcGxhdGUsIHByZWZpeCwgaSk7XG4gIGNvbnN0IHsgZGF0YXNldHMsIGxhYmVscyB9ID0gdGFibGU7XG4gIGNvbnN0IHsgaGVhZGluZywgbGFiZWwgfSA9IGxhYmVscztcbiAgY29uc3QgdGFibGVUb0FkZCA9IHRhYmxlVGVtcGxhdGUobGFiZWwsIGRhdGFzZXRzWzBdLmRhdGEsIGxhbmcpO1xuXG4gIHNlY3Rpb24ucXVlcnlTZWxlY3RvcignLmR4QWNjb3JkaW9uX190aXRsZScpLmlubmVySFRNTCA9IGdldFRleHQoaGVhZGluZy5kZXNjcmlwdGlvbiwgbGFuZyk7XG4gIHNlY3Rpb24ucXVlcnlTZWxlY3RvcignLmR4QWNjb3JkaW9uX19wYW5lbCcpLmFwcGVuZENoaWxkKHRhYmxlVG9BZGQpO1xuXG4gIHJldHVybiBzZWN0aW9uO1xufTtcblxuZXhwb3J0IGNvbnN0IGJ1aWxkQWNjb3JkaW9uID0gKGRhdGEsIGVsLCBwcmVmaXgsIGxhbmcsIGNtcyA9IHt9LCBvblByaWNpbmdFcnJvciA9IG51bGwpID0+IHtcbiAgY29uc3QgeyBzcGVjcyB9ID0gZGF0YTtcbiAgY29uc3QgYWNjb3JkaW9uQ29udGFpbmVyID0gZWwucXVlcnlTZWxlY3RvcignLmR4QWNjb3JkaW9uJyk7XG4gIGNvbnN0IGFjY29yZGlvblRlbXBsYXRlID0gYWNjb3JkaW9uQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5keEFjY29yZGlvbl9fc2VjdGlvbicpO1xuICBjb25zdCBhY2NvcmRpb25QYW5lbCA9IGFjY29yZGlvblRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy5keEFjY29yZGlvbl9fcGFuZWwnKTtcblxuICB3aGlsZSAoYWNjb3JkaW9uQ29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICBhY2NvcmRpb25Db250YWluZXIucmVtb3ZlQ2hpbGQoYWNjb3JkaW9uQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgd2hpbGUgKGFjY29yZGlvblBhbmVsLmZpcnN0Q2hpbGQpIHtcbiAgICBhY2NvcmRpb25QYW5lbC5yZW1vdmVDaGlsZChhY2NvcmRpb25QYW5lbC5maXJzdENoaWxkKTtcbiAgfVxuXG4gIGxldCBwcmljZVBhbmVsUG9zaXRpb24gPSBwYXJzZUludChlbC5kYXRhc2V0LnByaWNlUGFuZWxQb3NpdGlvbiwgMTApO1xuICBpZiAoTnVtYmVyLmlzTmFOKHByaWNlUGFuZWxQb3NpdGlvbikgfHwgcHJpY2VQYW5lbFBvc2l0aW9uIDw9IDEpIHtcbiAgICBwcmljZVBhbmVsUG9zaXRpb24gPSAxO1xuICB9XG5cbiAgY29uc3QgYWRkUHJpY2VBY2NvcmRpb25QYW5lbCA9ICgpID0+IHtcbiAgICBjb25zdCBmZWF0dXJlRGljdGlvbmFyeSA9IGRhdGFbJ2ZlYXR1cmUtZGljdGlvbmFyeSddO1xuXG4gICAgaWYgKCFpc0VtcHR5KGZlYXR1cmVEaWN0aW9uYXJ5KSAmJiAhaXNFbXB0eShjbXMpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwcmljaW5nID0gT2JqZWN0LmFzc2lnbihjbXMsIGRhdGFbJ2ZlYXR1cmUtZGljdGlvbmFyeSddKTtcblxuICAgICAgICBzdXBwcmVzc1ByaWNpbmdJZlplcm8ocHJpY2luZyk7XG4gICAgICAgIGFjY29yZGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChhY2NvcmRpb25QcmljaW5nU2VjdGlvbihhZGRGYWxsYmFja1ByaWNlKHByaWNpbmcpLCBhY2NvcmRpb25UZW1wbGF0ZSwgMCwgcHJlZml4LCBsYW5nKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKG9uUHJpY2luZ0Vycm9yKSB7XG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgICAgb25QcmljaW5nRXJyb3IoJ0NvbXBvbmVudCBhdXRob3JlZCB0byBzaG93IHByaWNlIEJVVCB0aGVyZSBpcyBOTyB2YWxpZCBwcmljZSBmb3IgdGhlIGRlcml2YXRpdmVzIGNob3Nlbi4nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25QcmljaW5nRXJyb3IoZXJyICYmIGVyci5tZXNzYWdlID8gZXJyLm1lc3NhZ2UgOiBlcnIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGxldCBjb3VudCA9IDE7XG4gIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoc3BlY3MsIChzcGVjKSA9PiB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChzcGVjLnRhYmxlLCAodGFiKSA9PiB7XG4gICAgICBpZiAoY291bnQgPT09IHByaWNlUGFuZWxQb3NpdGlvbikge1xuICAgICAgICBhZGRQcmljZUFjY29yZGlvblBhbmVsKCk7XG4gICAgICB9XG5cbiAgICAgIGFjY29yZGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChidWlsZEFjY29yZGlvblNlY3Rpb24odGFiLCBhY2NvcmRpb25UZW1wbGF0ZSwgY291bnQsIHByZWZpeCwgbGFuZykpO1xuXG4gICAgICBjb3VudCArPSAxO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gbmV3IER4QWNjb3JkaW9uKGFjY29yZGlvbkNvbnRhaW5lcik7XG59O1xuXG5jb25zdCByYyA9IG5ldyBSdWxlc0Nvbm5lY3QoKTtcblxuZXhwb3J0IGNvbnN0IGFwaUNhbGwgPSAodXJsKSA9PiB7XG4gIHJldHVybiByYy5sb2FkSnNvbnAodXJsKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9